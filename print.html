<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="0001-transform-attribute-meta-parameter.html"><strong>1.</strong> 0001-transform-attribute-meta-parameter</a></li><li><a href="0003-block-params.html"><strong>2.</strong> 0003-block-params</a></li><li><a href="0003-cli-ember-doctor.html"><strong>3.</strong> 0003-cli-ember-doctor</a></li><li><a href="0010-engines.html"><strong>4.</strong> 0010-engines</a></li><li><a href="0011-improved-cp-syntax.html"><strong>5.</strong> 0011-improved-cp-syntax</a></li><li><a href="0012-help-json-output.html"><strong>6.</strong> 0012-help-json-output</a></li><li><a href="0015-the-road-to-ember-2-0.html"><strong>7.</strong> 0015-the-road-to-ember-2-0</a></li><li><a href="0020-sri-default.html"><strong>8.</strong> 0020-sri-default</a></li><li><a href="0023-command-line-completion.html"><strong>9.</strong> 0023-command-line-completion</a></li><li><a href="0024-bound-attributes.html"><strong>10.</strong> 0024-bound-attributes</a></li><li><a href="0028-app-import-output-file.html"><strong>11.</strong> 0028-app-import-output-file</a></li><li><a href="0029-addon-black-and-whitelist-for-apps.html"><strong>12.</strong> 0029-addon-black-and-whitelist-for-apps</a></li><li><a href="0045-internet-explorer.html"><strong>13.</strong> 0045-internet-explorer</a></li><li><a href="0046-cli-improved-release-process.html"><strong>14.</strong> 0046-cli-improved-release-process</a></li><li><a href="0046-registry-reform.html"><strong>15.</strong> 0046-registry-reform</a></li><li><a href="0050-cli-production-code-stripping.html"><strong>16.</strong> 0050-cli-production-code-stripping</a></li><li><a href="0050-improved-actions.html"><strong>17.</strong> 0050-improved-actions</a></li><li><a href="0053-helpers.html"><strong>18.</strong> 0053-helpers</a></li><li><a href="0055-anonymous-amd.html"><strong>19.</strong> 0055-anonymous-amd</a></li><li><a href="0056-improved-release-cycle.html"><strong>20.</strong> 0056-improved-release-cycle</a></li><li><a href="0057-ember-data-reference-unification.html"><strong>21.</strong> 0057-ember-data-reference-unification</a></li><li><a href="0058-helper-listing.html"><strong>22.</strong> 0058-helper-listing</a></li><li><a href="0061-ember-data-background-fetch.html"><strong>23.</strong> 0061-ember-data-background-fetch</a></li><li><a href="0064-contextual-component-lookup.html"><strong>24.</strong> 0064-contextual-component-lookup</a></li><li><a href="0065-deprecation-warning-handlers.html"><strong>25.</strong> 0065-deprecation-warning-handlers</a></li><li><a href="0080-serve-file-api.html"><strong>26.</strong> 0080-serve-file-api</a></li><li><a href="0086-firefox-in-ci.html"><strong>27.</strong> 0086-firefox-in-ci</a></li><li><a href="0090-addon-tree-caching.html"><strong>28.</strong> 0090-addon-tree-caching</a></li><li><a href="0091-cli-addon-instrumentation-experimental-hooks.html"><strong>29.</strong> 0091-cli-addon-instrumentation-experimental-hooks</a></li><li><a href="0091-weakmap.html"><strong>30.</strong> 0091-weakmap</a></li><li><a href="0092-blueprint-remove-old-files.html"><strong>31.</strong> 0092-blueprint-remove-old-files</a></li><li><a href="0095-cli-standardise-targets.html"><strong>32.</strong> 0095-cli-standardise-targets</a></li><li><a href="0095-router-service.html"><strong>33.</strong> 0095-router-service</a></li><li><a href="0096-enable-yarn-usage.html"><strong>34.</strong> 0096-enable-yarn-usage</a></li><li><a href="0101-ember-data-friendly-errors.html"><strong>35.</strong> 0101-ember-data-friendly-errors</a></li><li><a href="0105-addons-optionalDependencies.html"><strong>36.</strong> 0105-addons-optionalDependencies</a></li><li><a href="0108-add-custom-transform.html"><strong>37.</strong> 0108-add-custom-transform</a></li><li><a href="0110-packaging.html"><strong>38.</strong> 0110-packaging</a></li><li><a href="0114-add-template-lint-addon.html"><strong>39.</strong> 0114-add-template-lint-addon</a></li><li><a href="0116-qunit-dom.html"><strong>40.</strong> 0116-qunit-dom</a></li><li><a href="0120-cli-guides.html"><strong>41.</strong> 0120-cli-guides</a></li><li><a href="0120-route-serializers.html"><strong>42.</strong> 0120-route-serializers</a></li><li><a href="0121-remove-ember-cli-eslint.html"><strong>43.</strong> 0121-remove-ember-cli-eslint</a></li><li><a href="0136-contains-to-includes.html"><strong>44.</strong> 0136-contains-to-includes</a></li><li><a href="0139-isHtmlSafe.html"><strong>45.</strong> 0139-isHtmlSafe</a></li><li><a href="0143-module-unification.html"><strong>46.</strong> 0143-module-unification</a></li><li><a href="0150-factory-for.html"><strong>47.</strong> 0150-factory-for</a></li><li><a href="0176-javascript-module-api.html"><strong>48.</strong> 0176-javascript-module-api</a></li><li><a href="0178-deprecate-ember-k.html"><strong>49.</strong> 0178-deprecate-ember-k</a></li><li><a href="0181-deprecate-ember-data-initializers.html"><strong>50.</strong> 0181-deprecate-ember-data-initializers</a></li><li><a href="0186-track-unique-history-location-state.html"><strong>51.</strong> 0186-track-unique-history-location-state</a></li><li><a href="0191-deprecate-component-lifecycle-hook-args.html"><strong>52.</strong> 0191-deprecate-component-lifecycle-hook-args</a></li><li><a href="0194-deprecate-custom-event-manager.html"><strong>53.</strong> 0194-deprecate-custom-event-manager</a></li><li><a href="0213-custom-components.html"><strong>54.</strong> 0213-custom-components</a></li><li><a href="0225-ember-engines-mount-params.html"><strong>55.</strong> 0225-ember-engines-mount-params</a></li><li><a href="0226-named-blocks.html"><strong>56.</strong> 0226-named-blocks</a></li><li><a href="0229-deprecate-testing-restricted-resolver.html"><strong>57.</strong> 0229-deprecate-testing-restricted-resolver</a></li><li><a href="0232-simplify-qunit-testing-api.html"><strong>58.</strong> 0232-simplify-qunit-testing-api</a></li><li><a href="0236-deprecation-ember-string.html"><strong>59.</strong> 0236-deprecation-ember-string</a></li><li><a href="0237-deprecation-ember-map.html"><strong>60.</strong> 0237-deprecation-ember-map</a></li><li><a href="0240-es-classes.html"><strong>61.</strong> 0240-es-classes</a></li><li><a href="0252-browser-support-changes.html"><strong>62.</strong> 0252-browser-support-changes</a></li><li><a href="0268-acceptance-testing-refactor.html"><strong>63.</strong> 0268-acceptance-testing-refactor</a></li><li><a href="0272-deprecation-native-function-prototype-extensions.html"><strong>64.</strong> 0272-deprecation-native-function-prototype-extensions</a></li><li><a href="0276-named-args.html"><strong>65.</strong> 0276-named-args</a></li><li><a href="0278-template-only-components.html"><strong>66.</strong> 0278-template-only-components</a></li><li><a href="0280-remove-application-wrapper.html"><strong>67.</strong> 0280-remove-application-wrapper</a></li><li><a href="0281-es5-getters.html"><strong>68.</strong> 0281-es5-getters</a></li><li><a href="0286-block-let-template-helper.html"><strong>69.</strong> 0286-block-let-template-helper</a></li><li><a href="0287-promote-in-element-to-public-api.html"><strong>70.</strong> 0287-promote-in-element-to-public-api</a></li><li><a href="0293-record-data.html"><strong>71.</strong> 0293-record-data</a></li><li><a href="0294-optional-jquery.html"><strong>72.</strong> 0294-optional-jquery</a></li><li><a href="0297-deprecate-ember-logger.html"><strong>73.</strong> 0297-deprecate-ember-logger</a></li><li><a href="0300-rfc-process-update.html"><strong>74.</strong> 0300-rfc-process-update</a></li><li><a href="0308-deprecate-property-lookup-fallback.html"><strong>75.</strong> 0308-deprecate-property-lookup-fallback</a></li><li><a href="0311-angle-bracket-invocation.html"><strong>76.</strong> 0311-angle-bracket-invocation</a></li><li><a href="0318-array-helper.html"><strong>77.</strong> 0318-array-helper</a></li><li><a href="0322-deprecate-copy-copyable.html"><strong>78.</strong> 0322-deprecate-copy-copyable</a></li><li><a href="0324-deprecate-component-isvisible.html"><strong>79.</strong> 0324-deprecate-component-isvisible</a></li><li><a href="0326-ember-data-filter-deprecation.html"><strong>80.</strong> 0326-ember-data-filter-deprecation</a></li><li><a href="0329-deprecated-ember-evented-in-ember-data.html"><strong>81.</strong> 0329-deprecated-ember-evented-in-ember-data</a></li><li><a href="0331-deprecate-globals-resolver.html"><strong>82.</strong> 0331-deprecate-globals-resolver</a></li><li><a href="0332-ember-data-record-links-and-meta.html"><strong>83.</strong> 0332-ember-data-record-links-and-meta</a></li><li><a href="0335-deprecate-send-action.html"><strong>84.</strong> 0335-deprecate-send-action</a></li><li><a href="0337-native-class-constructor-update.html"><strong>85.</strong> 0337-native-class-constructor-update</a></li><li><a href="0340-deprecate-ember-merge.html"><strong>86.</strong> 0340-deprecate-ember-merge</a></li><li><a href="0345-discord.html"><strong>87.</strong> 0345-discord</a></li><li><a href="0364-roadmap-2018.html"><strong>88.</strong> 0364-roadmap-2018</a></li><li><a href="0369-deprecate-computed-clobberability.html"><strong>89.</strong> 0369-deprecate-computed-clobberability</a></li><li><a href="0370-deprecate-computed-volatile.html"><strong>90.</strong> 0370-deprecate-computed-volatile</a></li><li><a href="0372-ember-data-model-factory-for.html"><strong>91.</strong> 0372-ember-data-model-factory-for</a></li><li><a href="0373-Element-Modifier-Managers.html"><strong>92.</strong> 0373-Element-Modifier-Managers</a></li><li><a href="0375-deprecate-computed-property-modifier.html"><strong>93.</strong> 0375-deprecate-computed-property-modifier</a></li><li><a href="0386-remove-jquery.html"><strong>94.</strong> 0386-remove-jquery</a></li><li><a href="0391-router-helpers.html"><strong>95.</strong> 0391-router-helpers</a></li><li><a href="0392-deprecate-component-manager-string-lookup.html"><strong>96.</strong> 0392-deprecate-component-manager-string-lookup</a></li><li><a href="0395-ember-data-packages.html"><strong>97.</strong> 0395-ember-data-packages</a></li><li><a href="0398-RouteInfo-Metadata.html"><strong>98.</strong> 0398-RouteInfo-Metadata</a></li><li><a href="0408-decorators.html"><strong>99.</strong> 0408-decorators</a></li><li><a href="0410-tracked-properties.html"><strong>100.</strong> 0410-tracked-properties</a></li><li><a href="0415-render-element-modifiers.html"><strong>101.</strong> 0415-render-element-modifiers</a></li><li><a href="0416-glimmer-components.html"><strong>102.</strong> 0416-glimmer-components</a></li><li><a href="0418-deprecate-route-render-methods.html"><strong>103.</strong> 0418-deprecate-route-render-methods</a></li><li><a href="0421-deprecate-application-controller-props.html"><strong>104.</strong> 0421-deprecate-application-controller-props</a></li><li><a href="0431-guides-restructure.html"><strong>105.</strong> 0431-guides-restructure</a></li><li><a href="0432-contextual-helpers.html"><strong>106.</strong> 0432-contextual-helpers</a></li><li><a href="0435-modifier-splattributes.html"><strong>107.</strong> 0435-modifier-splattributes</a></li><li><a href="0440-decorator-support.html"><strong>108.</strong> 0440-decorator-support</a></li><li><a href="0445-deprecate-with.html"><strong>109.</strong> 0445-deprecate-with</a></li><li><a href="0446-contribution-guides.html"><strong>110.</strong> 0446-contribution-guides</a></li><li><a href="0449-deprecate-partials.html"><strong>111.</strong> 0449-deprecate-partials</a></li><li><a href="0457-nested-lookups.html"><strong>112.</strong> 0457-nested-lookups</a></li><li><a href="0459-angle-bracket-built-in-components.html"><strong>113.</strong> 0459-angle-bracket-built-in-components</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#ember-rfcs" id="ember-rfcs"><h1>Ember RFCs</h1></a>
<p>Many changes, including bug fixes and documentation improvements can be
implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put
through a bit of a design process and produce a consensus among the Ember
core teams.</p>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a
consistent and controlled path for new features to enter the framework.</p>
<p><a href="https://github.com/emberjs/rfcs/pulls">Active RFC List</a></p>
<a class="header" href="print.html#when-you-need-to-follow-this-process" id="when-you-need-to-follow-this-process"><h2>When you need to follow this process</h2></a>
<p>You need to follow this process if you intend to make &quot;substantial&quot;
changes to Ember, Ember Data, Ember CLI, their documentation, or any other
projects under the purview of the <a href="https://emberjs.com/team/">Ember core teams</a>.
What constitutes a &quot;substantial&quot; change is evolving based on community norms,
but may include the following:</p>
<ul>
<li>A new feature that creates new API surface area, and would
require a <a href="http://emberjs.com/guides/contributing/adding-new-features/">feature flag</a> if introduced.</li>
<li>The removal of features that already shipped as part of the release
channel.</li>
<li>The introduction of new idiomatic usage or conventions, even if they
do not include code changes to Ember itself.</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing or refactoring</li>
<li>Addition or removal of warnings</li>
<li>Additions that strictly improve objective, numerical quality
criteria (speedup, better browser support)</li>
<li>Additions only likely to be <em>noticed by</em> other implementors-of-Ember,
invisible to users-of-Ember.</li>
</ul>
<p>If you submit a pull request to implement a new feature without going
through the RFC process, it may be closed with a polite request to
submit an RFC first.</p>
<a class="header" href="print.html#gathering-feedback-before-submitting" id="gathering-feedback-before-submitting"><h2>Gathering feedback before submitting</h2></a>
<p>It's often helpful to get feedback on your concept before diving into the
level of API design detail required for an RFC. <strong>You may open an
issue on this repo to start a high-level discussion</strong>, with the goal of
eventually formulating an RFC pull request with the specific implementation
design. We also highly recommend sharing drafts of RFCs in <code>#dev-rfc</code> on
the <a href="https://discord.gg/emberjs">Ember Discord</a> for early feedback.</p>
<a class="header" href="print.html#the-process" id="the-process"><h2>The process</h2></a>
<p>In short, to get a major feature added to Ember, one must first get the
RFC merged into the RFC repo as a markdown file. At that point the RFC
is 'active' and may be implemented with the goal of eventual inclusion
into Ember.</p>
<ul>
<li>Fork the RFC repo http://github.com/emberjs/rfcs</li>
<li>Copy the appropriate template. For most RFCs, this is <code>0000-template.md</code>,
for deprecation RFCs it is <code>deprecation-template.md</code>.
Copy the template file to <code>text/0000-my-feature.md</code>, where
'my-feature' is descriptive. Don't assign an RFC number yet.</li>
<li>Fill in the RFC. Put care into the details: <strong>RFCs that do not
present convincing motivation, demonstrate understanding of the
impact of the design, or are disingenuous about the drawbacks or
alternatives tend to be poorly-received</strong>.</li>
<li>Fill in the relevant core teams. Use the table below to map from projects to
teams.</li>
<li>Submit a pull request. As a pull request the RFC will receive design
feedback from the larger community, and the author should be prepared
to revise it in response.</li>
<li>Find a champion on the relevant core team. The champion is responsible for
shepherding the RFC through the RFC process and representing it in core team
meetings.</li>
<li>Update the pull request to add the number of the PR to the filename and
add a link to the PR in the header of the RFC.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support
are much more likely to make progress than those that don't receive any
comments.</li>
<li>Eventually, the [core teams] will decide whether the RFC is a candidate
for inclusion in Ember.</li>
<li>RFCs that are candidates for inclusion in Ember will enter a &quot;final comment
period&quot; lasting 7 days. The beginning of this period will be signaled with a
comment and tag on the RFC's pull request. Furthermore,
<a href="https://twitter.com/emberjs">Ember's official Twitter account</a> will post a
tweet about the RFC to attract the community's attention.</li>
<li>An RFC can be modified based upon feedback from the [core teams] and community.
Significant modifications may trigger a new final comment period.</li>
<li>An RFC may be rejected by the [core teams] after public discussion has settled
and comments have been made summarizing the rationale for rejection. The RFC
will enter a &quot;final comment period to close&quot; lasting 7 days. At the end of the
&quot;FCP to close&quot; period, the PR will be closed.</li>
<li>An RFC may be accepted at the close of its final comment period. A <a href="http://emberjs.com/team/">core team</a>
member will merge the RFC's associated pull request, at which point the RFC will
become 'active'.</li>
</ul>
<a class="header" href="print.html#relevant-teams" id="relevant-teams"><h3>Relevant Teams</h3></a>
<p>The RFC template requires indicating the relevant core teams. The following table
offers a reference of teams responsible for each project. Please reach out for
further guidance.</p>
<table><thead><tr><th>   Core Team   </th><th>    Project/Topics                                            </th></tr></thead><tbody>
<tr><td> Ember.js      </td><td> Ember.js                                                     </td></tr>
<tr><td> Ember Data    </td><td> Ember Data                                                   </td></tr>
<tr><td> Ember CLI     </td><td> Ember CLI                                                    </td></tr>
<tr><td> Learning      </td><td> Documentation, Website, learning experiences                 </td></tr>
<tr><td> Steering      </td><td> Governance                                                   </td></tr>
</tbody></table>
<a class="header" href="print.html#finding-a-champion" id="finding-a-champion"><h3>Finding a champion</h3></a>
<p>The RFC Process requires finding a champion from the relevant core teams. The
champion is responsible for representing the RFC in team meetings, and for
shepherding its progress. <a href="print.html#champion-responsibilities">Read more about the Champion's job</a></p>
<ul>
<li>
<p>Discord
The <code>dev-rfc</code> channel on the <a href="https://discord.gg/emberjs">Ember Discord</a> is
reserved for the discussion of RFCs.
We highly recommend circulating early drafts of your RFC in this channel to both
receive early feedback and to find a champion.</p>
</li>
<li>
<p>Request on an issue in the RFC repo or on the RFC
We monitor the RFC repository. We will circulate requests for champions but highly
recommend discussing the RFC in Discord.</p>
</li>
</ul>
<a class="header" href="print.html#the-rfc-life-cycle" id="the-rfc-life-cycle"><h2>The RFC life-cycle</h2></a>
<p>Once an RFC becomes active the relevant teams will plan the feature and create
issues in the relevant repositories.
Becoming 'active' is not a rubber stamp, and in particular still does not mean
the feature will ultimately be merged; it does mean that the core team has agreed
to it in principle and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is
'active' implies nothing about what priority is assigned to its
implementation, nor whether anybody is currently working on it.</p>
<p>Modifications to active RFC's can be done in followup PR's. We strive
to write each RFC in a manner that it will reflect the final design of
the feature; but the nature of the process means that we cannot expect
every merged RFC to actually reflect what the end result will be at
the time of the next major release; therefore we try to keep each RFC
document somewhat in sync with the feature as planned,
tracking such changes via followup pull requests to the document.</p>
<a class="header" href="print.html#implementing-an-rfc" id="implementing-an-rfc"><h2>Implementing an RFC</h2></a>
<p>The author of an RFC is not obligated to implement it. Of course, the
RFC author (like any other developer) is welcome to post an
implementation for review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an 'active'
RFC, but cannot determine if someone else is already working on it,
feel free to ask (e.g. by leaving a comment on the associated issue).</p>
<a class="header" href="print.html#for-core-team-members" id="for-core-team-members"><h2>For Core Team Members</h2></a>
<a class="header" href="print.html#reviewing-rfcs" id="reviewing-rfcs"><h3>Reviewing RFCs</h3></a>
<p>Each core team is responsible for reviewing open RFCs. The team must ensure
that if an RFC is relevant to their team's responsibilities the team is
correctly specified in the 'Relevant Team(s)' section of the RFC front-matter.
The team must also ensure that each RFC addresses any consequences, changes, or
work required in the team's area of responsibility.</p>
<p>As it is with the wider community, the RFC process is the time for
teams and team members to push back on, encourage, refine, or otherwise comment
on proposals.</p>
<a class="header" href="print.html#referencing-rfcs" id="referencing-rfcs"><h3>Referencing RFCs</h3></a>
<ul>
<li>When mentioning RFCs that have been merged, link to the merged version,
not to the pull-request.</li>
</ul>
<a class="header" href="print.html#champion-responsibilities" id="champion-responsibilities"><h3>Champion Responsibilities</h3></a>
<ul>
<li>achieving consensus from the team(s) to move the RFC through the stages of
the RFC process.</li>
<li>ensuring the RFC follows the RFC process.</li>
<li>shepherding the planning and implementation of the RFC. Before the RFC is
accepted, the champion may remove themselves. The champion may find a replacement
champion at any time.</li>
</ul>
<a class="header" href="print.html#helpful-checklists-for-champions" id="helpful-checklists-for-champions"><h3>Helpful checklists for Champions</h3></a>
<a class="header" href="print.html#becoming-champion-of-an-rfc" id="becoming-champion-of-an-rfc"><h4>Becoming champion of an RFC</h4></a>
<ul>
<li>[ ] Assign the RFC to yourself</li>
</ul>
<a class="header" href="print.html#moving-to-fcp-to-merge" id="moving-to-fcp-to-merge"><h4>Moving to FCP to Merge</h4></a>
<ul>
<li>[ ] Achieve consensus to move to &quot;FCP to Merge&quot; from relevant core teams</li>
<li>[ ] Comment in the RFC to address any outstanding issues and to proclaim the
start of the FCP period</li>
<li>[ ] Tweet from <code>@emberjs</code> about the FCP</li>
<li>[ ] Ensure the RFC has had the filename and header updated with the PR number</li>
</ul>
<a class="header" href="print.html#move-to-fcp-to-close" id="move-to-fcp-to-close"><h4>Move to FCP to Close</h4></a>
<ul>
<li>[ ] Achieve consensus to move to &quot;FCP to Close&quot; from relevant core teams</li>
<li>[ ] Comment in the RFC to explain the decision</li>
</ul>
<a class="header" href="print.html#closing-an-rfc" id="closing-an-rfc"><h4>Closing an RFC</h4></a>
<ul>
<li>[ ] Comment about the end of the FCP period with no new info</li>
<li>[ ] Close the PR</li>
</ul>
<a class="header" href="print.html#merging-an-rfc" id="merging-an-rfc"><h4>Merging an RFC</h4></a>
<ul>
<li>[ ] Achieve consensus to merge from relevant core teams</li>
<li>[ ] Ensure the RFC has had the filename and header updated with the PR number</li>
<li>[ ] Create a tracking card for the RFC implementation at {projects}</li>
<li>[ ] Update the RFC header with a link to the tracking</li>
<li>[ ] Merge</li>
<li>[ ] Update the RFC PR with a link to the merged RFC (The <code>Rendered</code> links often
go stale when the branch or fork is deleted)</li>
<li>[ ] Ensure relevant teams plan out what is necessary to implement</li>
<li>[ ] Put relevant issues on the tracking</li>
</ul>
<p><strong>Ember's RFC process owes its inspiration to the <a href="https://github.com/rust-lang/rfcs">Rust RFC process</a></strong></p>
<ul>
<li>Start Date: 2014-08-14</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/1</li>
<li>Ember Issue: https://github.com/emberjs/data/pull/4086</li>
</ul>
<a class="header" href="print.html#summary" id="summary"><h1>Summary</h1></a>
<p>For Ember Data. Pass through attribute meta data, which includes <code>parentType</code>, <code>options</code>, <code>name</code>, etc.,
to the transform associated with that attribute. This will allow provide the following function signiture updates to <code>DS.Transform</code>:</p>
<ul>
<li><code>transform.serialize(deserialized, attributeMeta)</code></li>
<li><code>transform.deserialize(serialized, attributeMeta)</code></li>
</ul>
<a class="header" href="print.html#motivation" id="motivation"><h1>Motivation</h1></a>
<p>The main use case is to be able to configure the transform
on a per-model basis making more DRY code. So the transform can be aware of type and options on <code>DS.attr</code> can
be useful to configure the transform for DRY use.</p>
<a class="header" href="print.html#detailed-design" id="detailed-design"><h1>Detailed design</h1></a>
<a class="header" href="print.html#implementing" id="implementing"><h2>Implementing</h2></a>
<p>The change will most likely start in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/system/model/attributes.js#L193"><code>eachTransformedAttribute</code></a>, which gets the attributes for that instance via <code>get(this, 'attributes')</code>. In the <code>forEach</code> the <code>name</code> will be used to get the specific attribute, e.g.</p>
<pre><code class="language-js">var attributeMeta = attributes.get(name);
callback.call(binding, name, type, attributeMeta);
</code></pre>
<p>The next change will be in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/json_serializer.js#L117"><code>applyTransforms</code></a>, where the <code>attributeMeta</code> parameter is added and passed to <code>transform.deserialize</code> as the second argument.</p>
<p>You also have to handle the serialization part in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/json_serializer.js#L528"><code>serializeAttribute</code></a>, where you pass through the <code>attribute</code> parameter to <code>transform.serialize</code>.</p>
<a class="header" href="print.html#using" id="using"><h2>Using</h2></a>
<p>A convoluted example:</p>
<pre><code class="language-js">// Example based on https://github.com/chjj/marked library
App.PostModel = DS.Model.extend({
  title: DS.attr('string'),
  markdown: DS.attr('markdown', {
    markdown: {
      gfm: false,
      sanitize: true
    }
  })
});

App.TechnicalPostModel = DS.Model.extend({
  title: DS.attr('string'),
  gistUrl: DS.attr('string'),
  markdown: DS.attr('markdown', {
    markdown: {
      gfm: true,
      tables: true,
      sanitize: false
    }
  })
});

App.MarkdownTransform = DS.Transform.extend({
  serialize: function (deserialized, attributeMeta) {
    return deserialized.raw;
  },
  
  deserialize: function (serialized, attributeMeta) {
    var options = attributeMeta.options.markdown || {};
    
    return marked(serialized, options);
  }
});
</code></pre>
<a class="header" href="print.html#drawbacks" id="drawbacks"><h1>Drawbacks</h1></a>
<p>Extra API surface area, although not much. This could also potentially introduce tight coupling between models and transforms if used improperly, e.g. not returning a default value if using type checking.</p>
<a class="header" href="print.html#alternatives" id="alternatives"><h1>Alternatives</h1></a>
<ol>
<li>Passing the information from the server, which is a poor solution.</li>
<li>Writing a new transform for each model/attribute that needs a variation. Although this might be a good solution sometimes if you extend a base transform.</li>
</ol>
<a class="header" href="print.html#unresolved-questions" id="unresolved-questions"><h1>Unresolved questions</h1></a>
<p>Does the whole meta object need to be passed, or do we selectively pass in only the useful properties? Like
<code>options</code> and <code>parentType</code> and <code>name</code>..</p>
<ul>
<li>Start Date: 2014-08-18</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/3</li>
<li>Issues:
<ul>
<li>Ember Stream support: emberjs/ember.js#5522</li>
<li>Handlebars parser support: wycats/handlebars.js#906</li>
<li>HTMLBars compiler support: tildeio/htmlbars#147</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#summary-1" id="summary-1"><h1>Summary</h1></a>
<p>Introduce block parameters to the Handlebars language to standardize context-preserving helpers, for example:</p>
<pre><code class="language-handlebars">{{#each people as |person|}}
  {{person.name}}
{{/each}}
</code></pre>
<a class="header" href="print.html#motivation-1" id="motivation-1"><h1>Motivation</h1></a>
<a class="header" href="print.html#the-problem" id="the-problem"><h3>The Problem</h3></a>
<p>There is no idiomatic way to write a helper that preserves context and yields values to its template. This is particularly painful for components which have strict context-preserving semantics.</p>
<a class="header" href="print.html#current-workarounds" id="current-workarounds"><h3>Current workarounds</h3></a>
<ul>
<li>Don't write components that need to yield a value.
<ul>
<li><em>Problem:</em> This may not be an option.</li>
</ul>
</li>
<li>Invent a non-standard per-helper syntax (like <code>{{#with foo as bar}}</code> or <code>{{#each item in items}}</code>) that hook into the undocumented <code>keywords</code> to inject variables.
<ul>
<li><em>Problems:</em> Custom syntaxes are not in the spirit of the Handlebars language and require the consumer to know the special incantation. Component authors must an non-trivial understanding of how <code>keywords</code> work.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#new-possibilities" id="new-possibilities"><h3>New possibilities</h3></a>
<pre><code class="language-handlebars">{{#for-each obj as |key val|}}
  {{key}}: {{val}}
{{/for-each}}
</code></pre>
<pre><code class="language-handlebars">{{#form-for post as |f|}}
  {{f.input &quot;title&quot;}}
  {{f.textarea &quot;body&quot;}}
  {{f.submit}}
{{/form-for}}
</code></pre>
<a class="header" href="print.html#detailed-design-1" id="detailed-design-1"><h1>Detailed design</h1></a>
<ul>
<li>Phase 1: Add block params to the Handlebars language</li>
<li>Phase 2: Rewrite Ember's helpers to accept streams</li>
<li>Phase 3: Add block param support to <code>{{each}}</code> and <code>{{with}}</code></li>
</ul>
<a class="header" href="print.html#phase-1-add-block-params-to-the-handlebars-language" id="phase-1-add-block-params-to-the-handlebars-language"><h3>Phase 1: Add block params to the Handlebars language</h3></a>
<p>The proposed syntax is <code>{{#x-foo a b w=x y=z as |param1 param2 ... paramN|}}</code> and is only available for block helpers.</p>
<p>The names of the block parameters are compiled into the inner template, but are not known to the helper (<code>x-foo</code> in the example above). To call a template and populate its block params we use the arguments option:</p>
<pre><code class="language-javascript">var template = compile('{{person.name}}', {
  blockParams: [ 'person' ]
});

template({}, ..., [ personModel ]);
</code></pre>
<p>More commonly, block params will be defined inside of the template.</p>
<pre><code>{{#with currentPost.author as |a|}}
  {{a.name}} &lt;em&gt;{{a.email}}&lt;/em&gt;
{{/with}}
</code></pre>
<pre><code class="language-javascript">registerHelper('with', function(object, options) {
  return options.fn(this, ..., [ object ]);
});
</code></pre>
<p>For compatibility reasons, the <em>number of block params</em> are passed to the helper so that the pre-block-params behaviour of the helper can be preserved. Example:</p>
<pre><code class="language-javascript">function eachHelper(..., options) {
  if (options.blockParamsLength &gt; 0) { /* do new behaviour */ }
  else { /* do old behaviour */ }
}
</code></pre>
<a class="header" href="print.html#phase-2-rewrite-embers-helpers-to-accept-streams" id="phase-2-rewrite-embers-helpers-to-accept-streams"><h3>Phase 2: Rewrite Ember's helpers to accept streams</h3></a>
<p>In the <code>with</code> example above, if the <code>currentPost</code> changes the <code>a</code> block param should update. This means it's not sufficient to pass only the initial value of the author in the arguments. Instead, we pass a stream which emits values whenever the observed property changes.</p>
<p>In Handlebars, a block param can appear anywhere that an identifier can, for example <code>{{log a.name}}</code>. This means that all helpers would need to be modified to understand streams.</p>
<a class="header" href="print.html#phase-3-add-block-param-support-to-each-and-with" id="phase-3-add-block-param-support-to-each-and-with"><h3>Phase 3: Add block param support to <code>{{each}}</code> and <code>{{with}}</code></h3></a>
<p>Deprecate context-changing and ad-hoc keyword flavors of <code>{{each}}</code> and <code>{{with}}</code> in favor of block params.</p>
<a class="header" href="print.html#drawbacks-1" id="drawbacks-1"><h1>Drawbacks</h1></a>
<ul>
<li>Handlebars already has a similar notion of with <code>data</code> which can lead to confusion.</li>
</ul>
<a class="header" href="print.html#alternatives-1" id="alternatives-1"><h1>Alternatives</h1></a>
<p>To my knowledge, no other designs have been considered. Not implementing this feature would mean that components would continue to be difficult to compose.</p>
<a class="header" href="print.html#unresolved-questions-1" id="unresolved-questions-1"><h1>Unresolved questions</h1></a>
<p>The associated HTML syntax for HTMLBars needs to be finalized.</p>
<ul>
<li>Start Date: 2015-01-10</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/3">#3</a></li>
</ul>
<a class="header" href="print.html#summary-2" id="summary-2"><h1>Summary</h1></a>
<p>We need a way to run diagnostics on Ember CLI based projects to let developers know about potential system level incompatibilities. Developers should also be able to get a bill of health for their project for things like outdated dependencies.  This bill of health should also be extensible.  Output from running this command should be as consise and only ever log things that don't seem healthy.</p>
<a class="header" href="print.html#motivation-2" id="motivation-2"><h1>Motivation</h1></a>
<p>The motivation behind this is 2 pronged:</p>
<ol>
<li>Allows developers to submit system level information in pull requests, so that bugs can be filed and potentially replicated.</li>
<li>Gives developers the ability to know about the health of their project and to potentially help with stagnation.</li>
</ol>
<a class="header" href="print.html#detailed-design-2" id="detailed-design-2"><h1>Detailed design</h1></a>
<p>The design for this is rather simple. We would first introduce a command called <code>ember doctor</code> that would run some default checks. The default checks would do the following:</p>
<ul>
<li>Run <code>ember v --verbose</code> and complain loudly for incompatible versions</li>
<li>Run <code>npm outdated --depth 0</code> to check on outdated modules</li>
<li>Run <code>bower list</code> and display out of date bower components</li>
<li>Run check to grab OS information</li>
</ul>
<p>These are what is considered default <code>checks</code>.</p>
<p>In your project developers can setup their own Doctor <code>checks</code> that get merged in with the default checks. To allow for this Ember CLI will have <code>ember generate doctor check:service-health</code>.</p>
<p>This command will generate the following directory structure in the root of the project:</p>
<pre><code>doctor/
  checks/
    service-health.js
  index.js
</code></pre>
<p>When <code>ember doctor</code> is ran we simply will do a merge of the default checks and the ones provided by the application.</p>
<p>There should also be a way of excluding checks to be ran. Developers should be able to simply pass flags for things they do not care to run e.g. <code>ember doctor --skip=npm,os</code>.</p>
<a class="header" href="print.html#addon-design" id="addon-design"><h1>Addon Design</h1></a>
<p>Much like the project addons can add their own diagnostics as projects.
In the addons main entry point there will be a hook much like
<code>includedCommands</code> that allows Ember CLI to look up the diagnostics and
role them into the consuming project.</p>
<pre><code>var checks = require('./checks');
...
includedChecks: function() {
  return checks;
}
...
</code></pre>
<a class="header" href="print.html#expected-output" id="expected-output"><h1>Expected Output</h1></a>
<p>Output of running the doctor command should be as concise as possible.
Unless there are any issues with the project that is being analyzed, the
output should be something like the following:</p>
<pre><code>Success: All diagnostics checked out fine.
</code></pre>
<p>In the event that there is an issue with the project that is being
analyzed the output will look something like the following:</p>
<pre><code>Warning: NPM modules out of date. Below are the out of date modules.
╔══════╤═══════╤═════════╗
║ Name │ Yours │ Current ║
╟──────┼───────┼─────────╢
║ glob │ 1.1.2 │ 1.2.3   ║
╚══════╧═══════╧═════════╝
</code></pre>
<a class="header" href="print.html#drawbacks-2" id="drawbacks-2"><h1>Drawbacks</h1></a>
<p>This adds &quot;yet another thing&quot; to the Ember CLI API surface. Doctor will be bound to a network connection such as checking outdated dependencies.</p>
<a class="header" href="print.html#alternatives-2" id="alternatives-2"><h1>Alternatives</h1></a>
<p>There have been other other attempts to put checking for system level checking in various places. The BDFL's would like to consolidate this into an <code>ember doctor</code> command.</p>
<a class="header" href="print.html#unresolved-questions-2" id="unresolved-questions-2"><h1>Unresolved questions</h1></a>
<ul>
<li>Start Date: 2014-10-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/10</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/12685</li>
</ul>
<a class="header" href="print.html#summary-3" id="summary-3"><h1>Summary</h1></a>
<p>Engines allow multiple logical applications to be composed together into a
single application from the user's perspective.</p>
<a class="header" href="print.html#motivation-3" id="motivation-3"><h1>Motivation</h1></a>
<p>Large companies are increasingly adopting Ember.js to power their entire
product lines. Often this means separate teams (sometimes distributed
around the world) working on the same app. Typically, responsibility is
shared by dividing the application into one or more &quot;sections&quot;. How this
division is actually implemented varies from team to team.</p>
<p>Sometimes, each &quot;section&quot; will be a completely separate Ember app, with
a shared navigation bar allowing users to switch between each app. This
allows teams to work quickly without stepping on each others' toes, but
switching apps feels slow (especially compared to the normally speedy
route transitions in Ember) because the entire page must be thrown out,
then an entirely new set of the same assets downloaded and parsed.
Additionally, code sharing is largely accomplished via copy-and-paste.</p>
<p>Other times, the separation is enforced socially, with each team
claiming a section of the same app in the same repository.
Unfortunately, this approach leads to frequent conflicts around shared
resources, and feedback from tests gets slower and slower as test suites
grow in size.</p>
<p>A more modular approach is to break off elements of a single application into
separate <a href="http://www.ember-cli.com/user-guide/#addons">addons</a>. Addons are
essentially mixins for <a href="http://www.ember-cli.com/">ember-cli</a> applications. In
other words, the elements of an addon are merged with those of the application
that includes them. While addons allow for distributed development, testing, and
packaging, they do not provide the logical run-time separation required for
developing completely independent &quot;sections&quot; of an application. Addons must
function within the namespace, registry, and router of the application in which
they are included.</p>
<p>Engines provide an alternative to these approaches that allows for distributed
development, testing, and packaging, <em>as well as</em> logical run-time separation.
Because engines are derived from applications, they can be just as
full-featured. Each has its own namespace and registry. Even though engines are
isolated from the applications that contain them, the boundaries between them
allow for controlled sharing of resources.</p>
<p>Engines can be either &quot;routable&quot; or &quot;route-less&quot;:</p>
<ul>
<li>
<p>Routable engines provide a routing map which can be integrated with the
routing maps of parent applications or engines. Routing maps are always eager
loaded, which allows for deep linking into an engine's routes regardless of
whether the engine itself has been instantiated.</p>
</li>
<li>
<p>Route-less engines can isolate complex functionality that is not related to
routing (e.g. a chat engine in a sidebar). Route-less engines can be rendered
into outlets ad hoc as routes are loaded.</p>
</li>
</ul>
<p>The potential scope of engines is large enough that this feature merits
development and delivery in multiple phases. A minimum viable version could be
released sooner, which could be augmented with more advanced features later.</p>
<p>An initial release of engines could provide the following benefits:</p>
<ul>
<li>
<p>Distributed development - Engines can be developed and tested in isolation
within their own Ember CLI projects and included by applications or other
engines. Engines can be packaged and released as addons themselves.</p>
</li>
<li>
<p>Integrated routing - Support for mounting routable engines in the routing maps
of applications or other engines.</p>
</li>
<li>
<p>Ad hoc embedding - Support for embedding route-less engines in outlets as
needed.</p>
</li>
<li>
<p>Clean boundaries - An engine can cooperate with its parents through a few
explicit interfaces. Beyond these interfaces, engines and applications are
isolated.</p>
</li>
</ul>
<p>Subsequent releases of engines could allow for the following:</p>
<ul>
<li>
<p>Lazy loading - An engine could allow its parent to boot with only its routing
map loaded. The rest of the engine could be loaded only as required (i.e.
when a route in an engine is visited). This would allow applications to boot
faster and limit their memory consumption.</p>
</li>
<li>
<p>Namespaced access to engine resources from applications - This could open up
the potential for applications to use, and extend, an engine's resources much
like resources in other addons, but without the possibility of namespace
collisions.</p>
</li>
</ul>
<a class="header" href="print.html#detailed-design-3" id="detailed-design-3"><h2>Detailed design</h2></a>
<p>Engines are very similar to regular applications: they can be developed in
isolation in Ember CLI, include addons, and contain all the same elements,
including routes, components, initializers, etc. The primary differences are
that an engine does not boot itself and an engine does not control the router.</p>
<a class="header" href="print.html#engine-internals" id="engine-internals"><h3>Engine internals</h3></a>
<p>New <code>Engine</code> and <code>EngineInstance</code> classes will be introduced.</p>
<p>Applications and engines will share ancestry. It remains TBD whether
applications will subclass engines, or whether a common ancestor will be
introduced.</p>
<p>Engines and applications will share the same pattern for registry / container
ownership and encapsulation. Both will also have initializers and instance
initializers.</p>
<p>Engine instances will have access to their parent instances. An engine's parent
could be either an application or engine.</p>
<a class="header" href="print.html#routable-vs-route-less-engines" id="routable-vs-route-less-engines"><h4>Routable vs. route-less engines</h4></a>
<p>Routable engines will define their routes in a new <code>Ember.Routes</code> class. This
class will encapsulate the functionality provided by <code>Router#map</code>, and will be
used internally by <code>Ember.Router</code> as well (with no public interface changes of
course).</p>
<p>Route-less engines do not define routing maps nor can they contain routes.</p>
<a class="header" href="print.html#developing-engines" id="developing-engines"><h3>Developing engines</h3></a>
<p>Engines can be developed in isolation as Ember CLI addon projects or as part of
a parent application.</p>
<a class="header" href="print.html#engines-as-addons" id="engines-as-addons"><h4>Engines as addons</h4></a>
<p>Engines can be created as separate addon projects with:</p>
<pre><code>ember engine &lt;engine-name&gt;
</code></pre>
<p>This will create a special form of an ember addon. The file structure will match
that of a standard addon, but will have an <code>engine</code> directory instead of an
<code>addon</code> directory.</p>
<p>Engines can be unit tested and can also be integration tested within a dummy
app, just like standard addons.</p>
<a class="header" href="print.html#in-repo-engines" id="in-repo-engines"><h4>In-repo engines</h4></a>
<p>An engine can be created within an existing application's project using a
special <code>in-repo-engine</code> generator (similar to the <code>in-repo-addon</code> generator):</p>
<pre><code>ember g in-repo-engine &lt;engine-name&gt;
</code></pre>
<p>In-repo engines can be unit tested in isolation or integration testing with the
main application (instead of a dummy application).</p>
<blockquote>
<p>Note: In-repo addons currently are created in the <code>/lib</code> directory (e.g.
<code>/lib/my-addon</code>). Unit tests and integration tests are currently co-mingled with
tests for the main application. It's recommended that in-repo engines provide
better test separation than is provided for regular addons, and perhaps the
whole in-repo addon directory structure should be re-examined at the same time
in-repo engines are introduced.</p>
</blockquote>
<a class="header" href="print.html#engine-directory-structure" id="engine-directory-structure"><h4>Engine directory structure</h4></a>
<p>An engine's directory will contain a file structure identical to the <code>app</code>
directory in a standard ember-cli application, with the following exceptions:</p>
<ul>
<li>
<p><code>engine.js</code> instead of <code>app.js</code> - defines the <code>Engine</code> class and
loads its initializers.</p>
</li>
<li>
<p><code>routes.js</code> instead of <code>router.js</code> - defines an engine's routing map in a
<code>Routes</code> class. This file should be deleted entirely for route-less engines.</p>
</li>
</ul>
<a class="header" href="print.html#installing-engines" id="installing-engines"><h3>Installing engines</h3></a>
<p>Engines developed as addons can be installed in an application just like any
other addon:</p>
<pre><code>ember install &lt;engine-name&gt;
</code></pre>
<p>During development, you can use <code>npm link</code> to make your engine available in
another parent engine or application.</p>
<a class="header" href="print.html#mounting-routable-engines" id="mounting-routable-engines"><h3>Mounting routable engines</h3></a>
<p>The new <code>mount()</code> router DSL method is used to mount an engine at a particular
&quot;mount-point&quot; in a route map.</p>
<p>For example, the following route map mounts the <code>discourse</code> engine at the
<code>/forum</code> path:</p>
<pre><code>Router.map(function() {
  this.mount('discourse', {path: '/forum'});
});
</code></pre>
<blockquote>
<p>Note: If unspecified, <code>path</code> will match the name of the engine.</p>
</blockquote>
<p>Calls to <code>mount</code> can be nested within routes. An engine can be mounted at
multiple routes, and each will represent a new instance of the engine to be
created.</p>
<a class="header" href="print.html#mounting-route-less-engines" id="mounting-route-less-engines"><h3>Mounting route-less engines</h3></a>
<p>A <code>mount()</code> DSL will also be added to routes, which will enable embedding of
route-less engines in outlets. This can be called from <code>renderTemplate</code> (or
<code>renderComponents</code> once routable components are introduced).</p>
<p><code>mount</code> has a similar signature to <code>render</code>, although it is obviously
engine-specific instead of template-specific. <code>mount</code> can be used to specify
a target template and outlet as follows:</p>
<pre><code>renderTemplate: function() {
  // Mount the chat engine in the sidebar
  this.mount('chat', {
    into: 'main',
    outlet: 'sidebar'
  });
}
</code></pre>
<p>As a result, the engine's <code>application</code> template will be rendered into the
<code>sidebar</code> outlet in the application's <code>main</code> template.</p>
<a class="header" href="print.html#loading-phases" id="loading-phases"><h3>Loading phases</h3></a>
<p>Engines can exist in several phases:</p>
<ul>
<li>
<p>Booted - an engine that's been installed in a parent application will have
its dependencies loaded and its (non-instance) initializers invoked when the
parent application boots.</p>
</li>
<li>
<p>Mounted - Routable and route-less engines have slightly different concepts of
&quot;mounting&quot;. A routable engine is considered mounted when it has been included
by a router at one or more mount-points. A route-less engine is considered
mounted as soon as a route's <code>mount</code> call resolves.</p>
</li>
<li>
<p>Instantiated - When an engine is instantiated, an <code>EngineInstance</code> is created
and an engine's instance initializers are invoked. A routable engine is
instantiated when a route is visited at or beyond its mount-point. A
route-less engine is instantiated as soon as it is mounted.</p>
</li>
</ul>
<p>Special <code>before</code> and <code>after</code> hooks could be added to application instance
initializers that allow them to be ordered relative to engine instance
initializers.</p>
<a class="header" href="print.html#engine-boundaries" id="engine-boundaries"><h3>Engine boundaries</h3></a>
<p>Besides its routing map, an engine does not share any other resources with its
parent by default. Engines maintain their own registries and containers, which
ensure that they stay isolated. However, some explicit sharing of resources
between engines and parents is allowed.</p>
<a class="header" href="print.html#engine--parent-dependencies" id="engine--parent-dependencies"><h4>Engine / parent dependencies</h4></a>
<p>Dependencies between engines and parents can be defined imperatively or
declaratively.</p>
<p>Imperative dependencies can be defined in an engine's instance initializers.
When an engine is instantiated, the <code>parent</code> property on its <code>EngineInstance</code> is
set to its parent instance (either an <code>ApplicationInstance</code> or
<code>EngineInstance</code>). Since the engine instance is available in the instance
initializer, this <code>parent</code> property can also be accessed. This allows an engine
instance to interrogate its parent, specifically through its <code>RegistryProxy</code> and
<code>ContainerProxy</code> interfaces.</p>
<p>Alternatively, declarative dependencies can be defined on a limited basis. The
initial API will be limited: an engine can define an array of <code>services</code> that it
requires from its parent.</p>
<p>For example, the following engine expects its parent to provide <code>store</code> and
<code>session</code> services:</p>
<pre><code>import Ember from 'ember';

var Engine = Ember.Engine.extend({
  dependencies: {
    services: [
      'store',
      'session'
    ]
  }
});

export default Engine;
</code></pre>
<p>The parent application can provide a re-mapping of services from its namespace
to that of the engine via an <code>engines</code> declaration.</p>
<p>In the following example, the application shares its <code>store</code> service directly
with the <code>checkout</code> engine. It also shares its <code>current-user</code> service as the
<code>session</code> service requested by the engine.</p>
<pre><code>import Ember from 'ember';

var App = Ember.Application.extend({
  engines: {
    checkout: {
      dependencies: {
        services: [
          'store',
          {session: 'current-user'}
        ]
      }
    }
  }
});

export default App;
</code></pre>
<p>When engines are instantiated, the listed dependencies will be looked up on
the parent and made accessible within the engine.</p>
<p>Note that the <code>engines</code> declaration provides further space to define
characteristics about an engine, such as whether it should be eager or
lazy-loaded, URLs for manifest files, etc.</p>
<a class="header" href="print.html#drawbacks-3" id="drawbacks-3"><h1>Drawbacks</h1></a>
<p>This RFC introduces the new concept of engines, which increases the
learning curve of the framework. However, I believe this issue is
mitigated by the fact that engines are an opt-in packaging around
existing concepts.</p>
<p>In the end, I believe that &quot;engines&quot; are just a small API for composing
existing concepts. And they can be introduced at the top of the
conceptual ladder, once users are comfortable with the basics of Ember,
and only for those working on large teams or distributing addons.</p>
<a class="header" href="print.html#alternatives-3" id="alternatives-3"><h1>Alternatives</h1></a>
<p>Several incomplete alternatives are discussed in the Motivations section above.</p>
<p>I know of no alternatives being discussed in the Ember community that meet the
same needs as engines; namely, for development <em>and</em> run-time isolation.</p>
<a class="header" href="print.html#unresolved-questions-3" id="unresolved-questions-3"><h1>Unresolved questions</h1></a>
<a class="header" href="print.html#non-cli-users" id="non-cli-users"><h2>Non-CLI Users</h2></a>
<p>This RFC assumes Ember CLI. I would prefer to prove this out in Ember
CLI before locking down the public APIs/hooks the router exposes for
locating and mounting engines. Once this is done, however, we should
expose and document those hooks so users who cannot use Ember CLI for
whatever reason can still take advantage of composability.</p>
<a class="header" href="print.html#declarative-dependencies" id="declarative-dependencies"><h2>Declarative dependencies</h2></a>
<p>The initial scope of declarative dependency sharing is limited in scope to
services. Should other types of dependencies be declaratively shareable?
Should addons be the recommended path to share all other dependencies?</p>
<a class="header" href="print.html#async-mounting-of-route-less-engines" id="async-mounting-of-route-less-engines"><h2>Async mounting of route-less engines</h2></a>
<p><code>Route#renderTemplate</code> is called synchronously, although <code>Route#mount</code> should
surely be async. How async mounting is represented in the route lifecycle is
TBD. A solution isn't proposed here because the problem is shared by routable
and async components, and a common solution should be reached.</p>
<a class="header" href="print.html#lazy-loading-manifests" id="lazy-loading-manifests"><h2>Lazy loading manifests</h2></a>
<p>In order to facilitate lazy loading of engines, we will need to determine a
structure for manifest files that contain an engine's assets. Furthermore, an
application will need to be configurable with URLs for these manifests.</p>
<p>It's likely that an engine's routing map will always be needed at the time of
application deployment. Allowing lazy loading of routing maps would prevent the
formation of any links from a parent application into an engine's routes.</p>
<p>When developed in isolation as addons, engines will have their own sets of
dependencies. These dependencies will be treated like any other addons when
engines are deployed together with an application. However, in order to support
lazy loading, it would be ideal to dedupe dependencies in order to create a lean
and conflict-free asset manifest.</p>
<p>Reference: deduping strategy discussed by @wycats in
<a href="https://docs.google.com/a/tomdale.net/document/d/12CsR-zli5oP2TDWOef_-D28zjmbVD83hU4q9_VTk-9s/edit">this Google doc</a>.</p>
<a class="header" href="print.html#namespaced-access-to-engine-resources" id="namespaced-access-to-engine-resources"><h2>Namespaced access to engine resources</h2></a>
<p>The concept of namespaced access to engine resources is mentioned above as a
potential goal of a future release of engines. This will require further
discussion to decide how it should work both technically and semantically, and
how it applies to lazy-loaded engines.</p>
<p>If these problems can be resolved, this feature would allow for more flexibility
in parent / engine interactions. Instead of just allowing engines to look up
resources in a parent, the inverse could also be allowed.</p>
<p>For example, if the <code>authentication</code> engine contains
<code>engines/authentication/models/user.js</code>, a parent application could look up this
same model through a namespace. Perhaps as follows:</p>
<pre><code class="language-js">container.lookup('authentication@model:user');
</code></pre>
<p>Other APIs in Ember would need to be extended to support namespaces to
take full advantage of this feature. For example, components that ship
with an engine might be accessed from the primary application like this:</p>
<pre><code class="language-handlebars">{{authentication@login-form obscure-password=true}}
</code></pre>
<ul>
<li>Start Date: 2014-09-30</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/11</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/9527</li>
</ul>
<a class="header" href="print.html#summary-4" id="summary-4"><h1>Summary</h1></a>
<p>Improve computed property syntax</p>
<a class="header" href="print.html#motivation-4" id="motivation-4"><h1>Motivation</h1></a>
<p>Today, the setter variant of CP's is both confusing, and looks scary as sin.
(Too many concepts must be taught and it is too easy to screw it up.)</p>
<a class="header" href="print.html#detailed-design-4" id="detailed-design-4"><h1>Detailed design</h1></a>
<a class="header" href="print.html#today" id="today"><h2>today:</h2></a>
<pre><code class="language-js">fullName: Ember.computed('firstName', 'lastName', function(key, value) {
  if (arguments.length &gt; 1) {
    var names = value.split(' ');
    this.setProperties({
      firstName: names[0],
      lastName: names[1]
    });
    return value;
  }

  return this.get('firstName') + ' ' + this.get('lastName');
});
</code></pre>
<a class="header" href="print.html#tomorrow" id="tomorrow"><h2>Tomorrow:</h2></a>
<pre><code class="language-js">fullName: Ember.computed('firstName', 'lastName', {
  get: function(keyName) {
    return this.get('firstName') + ' ' + this.get('lastName');
  },

  set: function(keyName, fullName, oldValue) {
   var names = fullName.split(' ');

   this.setProperties({
     firstName: names[0],
     lastName: names[1]
   });

   return fullName;
  }
});
</code></pre>
<a class="header" href="print.html#notes" id="notes"><h2>Notes:</h2></a>
<ul>
<li>we should keep <code>Ember.computed(fn);</code>  as shorthand for getter only</li>
<li><code>get</code> xor <code>set</code> variants would also be possible.</li>
<li><code>{ get() { } }</code> is es6 syntax for <code>{ get: function() { } )</code></li>
</ul>
<a class="header" href="print.html#migration" id="migration"><h2>Migration</h2></a>
<ul>
<li>1.x support both, detect new behaviour by testing if the last arg is not null and typeof object</li>
<li>1.x+1 deprecate if last arg is a function and its arity is greater than 1</li>
</ul>
<a class="header" href="print.html#drawbacks-4" id="drawbacks-4"><h1>Drawbacks</h1></a>
<p>N/A</p>
<a class="header" href="print.html#alternatives-4" id="alternatives-4"><h1>Alternatives</h1></a>
<p>N/A</p>
<a class="header" href="print.html#unresolved-questions-4" id="unresolved-questions-4"><h1>Unresolved questions</h1></a>
<p>None</p>
<ul>
<li>Start Date: 2015-05-16</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/12">#12</a></li>
</ul>
<a class="header" href="print.html#summary-5" id="summary-5"><h1>Summary</h1></a>
<p>This has come up in <a href="https://github.com/ember-cli/ember-cli/issues/3699">#3699</a> and <a href="https://github.com/EmberTown/ember-hearth/issues/66">EmberTown/ember-hearth/#66</a>.</p>
<p>In short, it would be nice for tools that depend on Ember-CLI to be able to read the help output as JSON (for example <code>ember g --help --json</code>).</p>
<a class="header" href="print.html#motivation-5" id="motivation-5"><h1>Motivation</h1></a>
<p>In our specific use case in <a href="https://github.com/EmberTown/ember-hearth/">Ember Hearth</a> we would like to be able to render a dynamic GUI for some tasks, like generating blueprints. This way we could also include any blueprints added by addons. This will also apply to any other tools interfacing with Ember-CLI.</p>
<a class="header" href="print.html#detailed-design-5" id="detailed-design-5"><h1>Detailed design</h1></a>
<p>We should probably make the internal help-functions (like <code>printBasicHelp</code> and <code>printDetailedHelp</code>) use JSON internally, and parse to human readable before printing (unless <code>--json</code> is specified).</p>
<p>I'm imagining the json output would be something like this:</p>
<pre><code class="language-json">{
  &quot;name&quot;:&quot;generate&quot;,
  &quot;description&quot;:&quot;Generates new code from blueprints.&quot;,
  &quot;aliases&quot;:[&quot;g&quot;],
  &quot;flags&quot;:[
    {
      &quot;flag&quot;:&quot;--verbose&quot;,
      &quot;aliases&quot;:[&quot;-v&quot;],
      &quot;description&quot;:&quot;Verbose output&quot;
    }, {…}],
  &quot;commands&quot;:[
    {
      &quot;command&quot;:&quot;template&quot;,
      &quot;description&quot;:&quot;Generates a template.&quot;,
      &quot;arguments&quot;:[&quot;name&quot;]
    },
    {
      &quot;command&quot;:&quot;model&quot;,
      &quot;description&quot;:&quot;Generate an ember-data model.&quot;,
      &quot;arguments&quot;:[
        &quot;name&quot;,
        {
          &quot;argument&quot;:&quot;attr:type&quot;,
          &quot;description&quot;:&quot;Add attributes to the model, e.g. 'name:String age:Number'&quot;,
          &quot;multiple&quot;:true
        }]
    }, {…}]
}
</code></pre>
<p>Note that this output contains a bit more info than the current --help, specifically in the attr:type argument for the model command. This is something I feel is currently missing (I did not understand the model generator command without consulting a colleague, for example), and would be nice to add while we're at it.</p>
<p>It should be pretty straight forward to generate a human readable output from this JSON. There are a few things missing: However: The generate help command specifically groups commands by addon. I'm not sure how this should be accomplished, and if this matches the other help outputs. Ideally, any tools reading the JSON should be able to rely on the format being the same for all commands. This would keep the internals cleaner as well, including the human readable parser.</p>
<a class="header" href="print.html#drawbacks-5" id="drawbacks-5"><h1>Drawbacks</h1></a>
<ul>
<li>Requires rewrite of help methods, possibly also for some addons (unless we can provide backwards compatability)</li>
<li>Increases codebase size</li>
</ul>
<a class="header" href="print.html#alternatives-5" id="alternatives-5"><h1>Alternatives</h1></a>
<ul>
<li>We could standardize help output enough that it can be safely regexed by other tools</li>
<li>We could not do this, and require any tools to update whenever Ember-CLI changes any commands</li>
</ul>
<a class="header" href="print.html#unresolved-questions-5" id="unresolved-questions-5"><h1>Unresolved questions</h1></a>
<ul>
<li>Internal architecture specifics (rewrite printBasicHelp or create a new setup, etc)</li>
<li>Specifying JSON format details</li>
<li>List any dependencies, like docs, that will need to be updated with this change</li>
</ul>
<ul>
<li>Start Date: 2014-12-03</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/15</li>
<li>Ember Issue: This RFC is implemented over many Ember PRs</li>
</ul>
<a class="header" href="print.html#the-road-to-ember-20" id="the-road-to-ember-20"><h1>The Road to Ember 2.0</h1></a>
<a class="header" href="print.html#intro" id="intro"><h2>Intro</h2></a>
<p>Today, we're announcing our plan for Ember 2.0. While the major version
bump gives us the opportunity to simplify the framework in ways that
require breaking changes, we are designing Ember 2.0 with migration in mind.</p>
<p>This is <strong>not</strong> a big-bang rewrite; we will continue development
on the <code>master</code> branch, and roll out changes incrementally on the 1.x
release train. The 2.0.0 release will simply remove features that have
been deprecated between now and then. Our goal is that you can move
your Ember app to 2.0 incrementally, one sprint at a time.</p>
<p>This RFC captures the results of the last two core team face-to-face
meetings, where we discussed community feedback about the future of the
project. While it explains the high-level goals and tries to paint a
picture of how all the pieces fit together, this document will be
updated over time with links to individual RFCs that contain additional
implementation detail.</p>
<p>We plan to flesh out these more-detailed RFCs in the next few weeks,
as the discussion here progresses, before finalizing this plan.</p>
<p>We are announcing Ember 2.0 through our community RFC process in advance
of a release, both so our proposals can be vetted by the community and
so the community can understand the goals and contribute their own ideas
back.</p>
<a class="header" href="print.html#motivation-6" id="motivation-6"><h2>Motivation</h2></a>
<a class="header" href="print.html#stability-without-stagnation" id="stability-without-stagnation"><h3>Stability without Stagnation</h3></a>
<p>Ember is all about identifying common patterns that emerge from the web
development community and rolling them into a complete front-end stack.
This makes it easy to get started on new projects and jump into existing
ones, knowing that you will get a best-of-breed set of tools that the
community will continue to support and improve for years to come.</p>
<p>In the greater JavaScript community, getting the latest and greatest
often means rewriting parts of your apps once a year, as the community
abandons existing solutions in search of improvements. Progress is
important, but so is ending the constant cycle of writing and rewriting
that plagues so many applications.</p>
<p>The Ember community works hard to introduce new ideas with an eye
towards migration. We call this &quot;stability without stagnation&quot;, and it's
one of the cornerstones of the Ember philosophy.</p>
<p>Below, we introduce some of the major new features coming in Ember
2.0. Each section includes a transition plan, with details on how
we expect existing apps to migrate to the new API.</p>
<p>When breaking changes are absolutely necessary, we try to make those
changes ones you can apply without too much thought. We call these
&quot;mechanical&quot; refactors. Typically, they'll involve a change to
syntax without changing semantics. These are significantly easier to
adopt than those that require fundamental changes to your application
architecture.</p>
<p><strong>To further aid in these transitions, we are planning to add a new tab to the
Ember Inspector that will list all deprecations in your application</strong>,
as well as a list of the locations in the source code where the
deprecated code was triggered. This should serve as a convenient
&quot;punch list&quot; for your transitional work.</p>
<p>Every member of the core team works on up-to-date Ember applications,
and we feel the tension between stability and progress acutely. We want
to deliver cutting-edge products, but need to keep shipping, and many
companies that have adopted Ember for their products tell us the
same thing.</p>
<a class="header" href="print.html#big-bets" id="big-bets"><h3>Big Bets</h3></a>
<p>In 2014, we made big bets in two areas, and they've paid off.</p>
<p>The first bet was on open standards: JavaScript modules, promises and
Web Components. We started the year off with globals-based apps,
callbacks and &quot;views&quot;, and incrementally (and compatibly) built towards
standards-based solutions as those standards solidified.</p>
<p>The second bet was that the community was as tired as we were of
hand-rolling their own build scripts for each project. We've invested
heavily in Ember CLI, giving us a single tool that unifies the community
and provides a venue for disseminating great ideas.</p>
<p><strong>In Ember 2.0, Ember CLI and ES6 modules will become first-class parts
of the Ember experience.</strong> We will update the website, guides, documentation,
etc. to teach new users how to build Ember apps with the CLI tools and
using JavaScript's new module syntax.</p>
<p>While globals-based apps will continue to work in 2.0, we may introduce
new features that rely on either Ember CLI or ES6 modules. <strong>You should
begin moving your app to Ember CLI as soon as possible.</strong></p>
<p>All of the apps maintained by the Ember core team have been migrated to
Ember CLI, and we believe that most teams should be able to make the
transition incrementally.</p>
<a class="header" href="print.html#learning-from-the-community" id="learning-from-the-community"><h3>Learning from the Community</h3></a>
<p>We're well aware that we don't have a monopoly on good ideas, and we're
always analyzing competing frameworks and libraries to discover great
ideas that we can incorporate.</p>
<p>For example, AngularJS taught us the importance of making early on-ramp
easy, how cool directives/components could be, and how dependency
injection improves testing.</p>
<p>We've been analyzing and discussing React's approach to data flow and
rendering for some time now, and in particular how they make use of a
&quot;virtual DOM&quot; to improve performance.</p>
<p>Ember's view layer is one of the oldest parts of Ember, and was designed
for a world where IE7 and IE8 were dominant. We've spent the better part
of 2014 rethinking the view layer to be more DOM-aware, and the new
codebase (codenamed &quot;HTMLBars&quot;) borrows what we think are the
best ideas from React. We cover the specifics below.</p>
<p>React's &quot;virtual DOM&quot; abstraction also allowed them to simplify the
programming model of component-based applications. We really like these
ideas, and the new HTMLBars engine, landing in the next Ember release, lays
the groundwork for adopting the simplified data-flow model.</p>
<p><strong>In Ember 2.0, we will be adopting a &quot;virtual DOM&quot; and data flow model
that embraces the best ideas from React and simplifies communication
between components.</strong></p>
<p>Interestingly, we found that well-written Ember applications are already
written with this clear and direct data flow. This change will mostly
make the best patterns more explicit and easier for developers to find
when starting out.</p>
<a class="header" href="print.html#a-steady-flow-of-improvement" id="a-steady-flow-of-improvement"><h3>A Steady Flow of Improvement</h3></a>
<p>Ember 1.0 shipped over a year ago and we have continued to improve the
framework while maintaining backwards-compatibility. We are proud of the
fact that Ember apps tend to track released versions.</p>
<p>You might expect us to do Ember 2.0 work on a separate &quot;2.0&quot; branch,
accumulating features until we ship. We aren't going to do that.</p>
<p>Instead, <strong>we plan to do the vast majority of new work on <code>master</code> (behind
feature flags), and land new features in 1.x as they become stable.</strong></p>
<p>The <code>2.0.0</code> release <strong>will simply remove the cruft</strong> that naturally
builds up when maintaining compatibility with old releases.</p>
<p>If we add features that change Ember idioms, we will add clear
deprecation warnings with steps to refactor to new patterns.</p>
<p>Our goal is that, as much as possible, people will be able to boot up
their app on the last <code>1.x</code> version, update to the latest set of idioms
by following the deprecation prompts, and have things working on <code>2.0</code>.</p>
<p>Because going from the last version of Ember 1.x to Ember 2.0 will be
just another six-week release, there simply won't be much time for us to
make it an incredibly painful upgrade. ;)</p>
<a class="header" href="print.html#simplifying-ember-concepts" id="simplifying-ember-concepts"><h2>Simplifying Ember Concepts</h2></a>
<p>Ember evolved organically from a view-layer-only framework in 2011 into
the route-driven, complete front-end stack it is today. Along the way,
we've accumulated several concepts that are no longer widely used in idiomatic
Ember apps.</p>
<p>These vestigial concepts make file sizes larger, code more complex, and
make Ember harder to learn.</p>
<p><strong>Ember 2.0 is about simplification</strong>. This lets us reduce file sizes,
reduce code complexity, and generally make Ember apps easier to pick up
and maintain.</p>
<p>The high-level set of improvements that we have planned are:</p>
<ul>
<li>More intuitive attribute bindings</li>
<li>New HTML syntax for components</li>
<li>Block parameters for components</li>
<li>More consistent template scope</li>
<li>One-way data binding by default, with opt-in to mutable, two-way bindings</li>
<li>More explicit communication between components, which means less
implicit communication via two-way bindings</li>
<li>Routes drive components, instead of controller + template</li>
<li>Improved actions that are invoked inside components as simple callbacks</li>
</ul>
<p>In some sections, we provide estimates for when a feature will land.
These are our best-guesses, but because of the rapid-release train model
of Ember, we may be off by a version or two.</p>
<p>However, all features that are slated for &quot;before 2.0&quot; will land before
we cut over to a major new version.</p>
<a class="header" href="print.html#more-intuitive-attribute-bindings" id="more-intuitive-attribute-bindings"><h2>More Intuitive Attribute Bindings</h2></a>
<p>Today's templating engine is the oldest part of Ember.js. Under the
hood, it generates a string of HTML and then inserts it into the page.</p>
<p>One unfortunate consequence of this architecture is that it is not
possible to intuitively bind values to HTML attributes.</p>
<p>You would expect to be able type something like:</p>
<pre><code class="language-handlebars">&lt;a href=&quot;{{url}}&quot;&gt;Click here&lt;/a&gt;
</code></pre>
<p>But instead, in today's Ember, you have to learn about and use the
<code>bind-attr</code> helper:</p>
<pre><code class="language-handlebars">&lt;a {{bind-attr href=url}}&gt;Click here&lt;/a&gt;
</code></pre>
<p>The new HTMLBars template engine makes <code>bind-attr</code> a thing of the past,
allowing you to type what you mean. It also makes it possible to express
many attribute-related concepts simply:</p>
<pre><code class="language-handlebars">&lt;a class=&quot;{{active}} app-link&quot; href=&quot;{{url}}.html&quot;&gt;Click here&lt;/a&gt;
</code></pre>
<a class="header" href="print.html#transition-plan" id="transition-plan"><h3>Transition Plan</h3></a>
<p>The HTMLBars templating engine is being developed on master, and parts
of it have already landed in Ember 1.8. Doing the work this way means
that the new engine continues to support the old syntax: your existing
templates will continue to work.</p>
<p>The improved attribute syntax has not yet landed, but we expect it to
land before Ember 1.10.</p>
<p><strong>We do not plan to remove support for existing templating syntax (or
no-longer-necessary helpers like <code>bind-attr</code>) in Ember 2.0.</strong></p>
<a class="header" href="print.html#more-intuitive-components" id="more-intuitive-components"><h2>More Intuitive Components</h2></a>
<p>In today's Ember, components are represented in your templates as
Handlebars &quot;block helpers&quot;.</p>
<p>The most important problem with this approach is that Handlebars-style
components do not work well with attribute bindings or the <code>action</code>
helper. In short, a helper that is meant to be used inside an HTML tag
cannot be used inside a call to a component.</p>
<p>Beginning in Ember 1.11, we will support an HTML-based syntax for
components. <strong>The new syntax can be used to invoke existing components,
and new components can be called using the old syntax.</strong></p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}}&gt;&lt;/my-video&gt;

&lt;!-- equivalent to --&gt;

{{my-video src=movie.url}}
</code></pre>
<a class="header" href="print.html#transition-plan-1" id="transition-plan-1"><h3>Transition Plan</h3></a>
<p>The improved component syntax will (we hope) land in Ember 1.11. You can
transition existing uses of <code>{{component-name}}</code> to the new syntax
at that time. You will likely benefit by eliminating uses of computed
properties that can now be more tersely expressed using the
interpolation syntax.</p>
<p><strong>We have no plans to remove support for the old component syntax in
Ember 2.0.</strong></p>
<a class="header" href="print.html#block-parameters" id="block-parameters"><h2>Block Parameters</h2></a>
<p>In today's templates, there are two special forms of built-in Handlebars
helpers: <code>#each post in posts</code> and <code>#with post as p</code>. These allow the
template inside the helper to retain the parent context, but get a piece
of helper-provided information as a named value (such as <code>post</code> in the previous examples).</p>
<pre><code>{{#with contact.person as p}}
  {{!-- this block of code is still in the parent's scope, but
        the #with helper provided a `p` name with a
        helper-provided value --}}
  &lt;p&gt;{{p.firstName}} {{p.lastName}}&lt;/p&gt;

  {{!-- `title` here refers to the outer scope's title --}}
  &lt;p&gt;{{title}}&lt;/p&gt;
{{/with}}
</code></pre>
<p>Today, this capability is hardcoded into the two special forms,
but it can be useful for other kinds of components. For example,
you may have a calendar component (<code>ui-calendar</code>) that displays a
specified month.</p>
<p>The <code>ui-calendar</code> component may want to allow users to supply a custom
template for each day in the month, but each repetition of the template
will need information about the day it represents (its day of the week,
date number, etc.) in order to render it.</p>
<p>With the new &quot;block parameters&quot; feature, any component will have
access to the same capability as <code>#each</code> or <code>#with</code>:</p>
<pre><code class="language-handlebars">&lt;ui-calendar month={{currentMonth}} as |day|&gt;
  &lt;p class=&quot;title&quot;&gt;{{day.title}}&lt;/p&gt;
  &lt;p class=&quot;date&quot;&gt;{{day.date}}&lt;/p&gt;
&lt;/ui-calendar&gt;
</code></pre>
<p>In this case, the <code>ui-calendar</code> component iterates over all of days
in <code>currentMonth</code>, rendering each instance of the template with
information about which date it should represent.</p>
<p>We also think that this feature will be useful to allow container
components (like tabs or forms) to supply special-case component
definitions as block params. We are still working on the details,
but believe that an approach along these lines could make these
kinds of components simpler and more flexible.</p>
<a class="header" href="print.html#transition-plan-2" id="transition-plan-2"><h3>Transition Plan</h3></a>
<p>Block parameters will hopefully land in 1.12, and at that point the
two special forms for <code>{{each}}</code> and <code>{{with}}</code> will be deprecated.
You should refactor your templates to use the new block parameters
syntax once it lands, as it is a purely mechanical refactor.</p>
<p><strong>We have no plans to remove support for the <code>{{each}}</code> and <code>{{with}}</code>
special forms in Ember 2.0.</strong></p>
<a class="header" href="print.html#more-consistent-handlebars-scope" id="more-consistent-handlebars-scope"><h2>More Consistent Handlebars Scope</h2></a>
<p>In today's Ember, the <code>each</code> and <code>with</code> helpers come in two flavors: a
&quot;context-switching&quot; flavor and a &quot;named-parameter&quot; flavor.</p>
<pre><code class="language-handlebars">{{#each post in posts}}
  {{!-- the context in here is the same as the outside context,
        and `post` references the current iteration --}}
{{/each}}

{{#each posts}}
  {{!-- the context in here has shifted to the individual post.
        the outer context is no longer accessible --}}
{{/each}}
</code></pre>
<p>This has proven to be one of the more confusing parts of the Ember
templating system. It is also not clear to beginners which to use,
and when they choose the context-shifting form, they lose access to
values in the outer context that may be important.</p>
<p>Because the helper itself offers no clue about the context-shifting
behavior, it is easy (even for more experienced Ember developers)
to get confused when skimming a template about which object a value
refers to.</p>
<p>In Ember 1.10, we will deprecate the context-shifting forms of
<code>#each</code> and <code>#with</code> in favor of the named-parameter forms.</p>
<a class="header" href="print.html#transition-plan-3" id="transition-plan-3"><h3>Transition Plan</h3></a>
<p>To transition your code to the new syntax, you can change templates
that look like this:</p>
<pre><code class="language-hbs">{{#each people}}
  &lt;p&gt;{{firstName}} {{lastName}}&lt;/p&gt;
  &lt;p&gt;{{address}}&lt;/p&gt;
{{/each}}
</code></pre>
<p>with:</p>
<pre><code class="language-hbs">{{#each people as |person|}}
  &lt;p&gt;{{person.firstName}} {{person.lastName}}&lt;/p&gt;
  &lt;p&gt;{{person.address}}&lt;/p&gt;
{{/each}}
</code></pre>
<p><strong>We plan to deprecate support for the context-shifting helpers in Ember
1.10 and remove support in Ember 2.0.</strong> This change should be entirely
mechanical.</p>
<a class="header" href="print.html#one-way-bindings-by-default" id="one-way-bindings-by-default"><h2>One-Way Bindings by Default</h2></a>
<p>After a few years of having written Ember applications, we have observed
that most of the data bindings in the templating engine do not actually
require two-way bindings.</p>
<p>When we designed the original templating layer, we figured that making
all data bindings two-way wasn't very harmful: if you don't set a
two-way binding, it's a de facto one-way binding!</p>
<p>We have since realized (with some help from our friends at React), that
components want to be able to hand out data to their children without
having to be on guard for wayward mutations.</p>
<p>Additionally, communication between components is often most naturally
expressed as events or callbacks. This is possible in Ember, but the
dominance of two-way data bindings often leads people down a path of
using two-way bindings as a communication channel. Experienced Ember
developers don't (usually) make this mistake, but it's an easy one to
make.</p>
<p>When you use the new component syntax, the <code>{{}}</code> interpolation syntax
defaults to creating one-way bindings in the components.</p>
<pre><code class="language-handlebars">&lt;my-video src={{url}}&gt;&lt;/my-video&gt;
</code></pre>
<p>In this example, the component's <code>src</code> property will be updated whenever
<code>url</code> changes, but it will not be allowed to mutate it.</p>
<p>If a template wishes to allow the component to mutate a property, it can
explicitly create a two-way binding using the <code>mut</code> helper:</p>
<pre><code class="language-handlebars">&lt;my-video paused={{mut isPaused}}&gt;&lt;/my-video&gt;
</code></pre>
<p>This can help ease the transition to a more event-based style of
programming.</p>
<p>It also eliminates the boilerplate associated with an event-based style
when working with form controls. Instead of copying state out of a
model, listening for callbacks, and updating the model, the <code>input</code>
helper can be given an explicit mutable binding.</p>
<pre><code class="language-handlebars">&lt;input value={{mut firstName}}&gt;
&lt;input value={{mut lastName}}&gt;
</code></pre>
<p>This is similar to the approach taken by <a href="http://facebook.github.io/react/docs/two-way-binding-helpers.html">React.Link</a>, but we think
that the use-case of form helpers is sufficiently common to make it
ergonomic.</p>
<a class="header" href="print.html#transition-plan-4" id="transition-plan-4"><h3>Transition Plan</h3></a>
<p>The new one-way default is triggered by the use of new component syntax.
This means that component invocations in existing templates will
continue to work without changes.</p>
<p>When transitioning to the new HTML-based syntax, you will likely want to
evaluate whether bindings are actually being mutated, and avoid using
<code>mut</code> for values that the component never changes. This will make it
easier for future readers of your template to get an understanding of
what properties might be changed downstream.</p>
<p>To preserve the same semantics during a refactor to the new HTML-based
syntax, you can simply mark all bindings as <code>mut</code>.</p>
<pre><code class="language-handlebars">{{!-- these are semantically equivalent --}}

{{my-video src=movie.url paused=controller.isPaused}}

&lt;my-video src={{mut movie.url}} paused={{mut controller.isPaused}}&gt;
&lt;/my-video&gt;
</code></pre>
<p>While the above example preserves the same mutability semantics, it
should be clear that the video player component should never change the
<code>url</code> of the <code>movie</code> model.</p>
<p>To make sure you get an exception should this ever happen, simply remove
the <code>mut</code>:</p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}} paused={{mut controller.isPaused}}&gt;
&lt;/my-video&gt;
</code></pre>
<p><strong>We have no plans to remove the old-style component syntax in Ember
2.0, so the semantics of existing component invocations will not
change.</strong></p>
<a class="header" href="print.html#separated-component-parameters" id="separated-component-parameters"><h2>Separated Component Parameters</h2></a>
<p>In today's Ember, parameters passed to components as attributes become
properties of the component itself, putting them in the same place as
other internal state.</p>
<p>This can be somewhat confusing, because it may not be obvious to the
reader of a component's JavaScript or template which values are
internal, and which are passed in as part of the public API.</p>
<p>To remind themselves, many Ember users write their components like this:</p>
<pre><code class="language-js">export default Component.extend({
  /* Public API */

  src: null,
  paused: null,
  title: null,

  /* Internal */
  scrubber: null
})
</code></pre>
<p>It can also be unclear how to react to a change in the external
properties. It is possible to use observers for this purpose in Ember,
but observers feel low-level and do not coordinate very well with the
rendering process.</p>
<p>To reduce confusion, we plan to move external attributes into a new
<code>attrs</code> hash.</p>
<p>If you invoke a component like this:</p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}}&gt;&lt;/my-video&gt;
</code></pre>
<p>then the <code>my-video</code> component accesses the passed-in <code>src</code> attribute as
<code>this.attrs.src</code>.</p>
<p>We also plan to provide lifecycle callbacks (modelled after <a href="http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods">React's
lifecycle callbacks</a>) for changes to <code>attrs</code> that will
integrate with the rendering lifecycle. We plan to supplement the API
with callbacks for changes in individual properties as well.</p>
<a class="header" href="print.html#transition-plan-5" id="transition-plan-5"><h3>Transition Plan</h3></a>
<p>In Ember 1.10, we will begin installing provided attributes in the
component's <code>attrs</code> hash. If a provided attribute is accessed directly
on the component, a deprecation warning will be issued.</p>
<p>In applications, you should update your component JavaScript and
templates to access provided attributes via the component's <code>attrs</code>
property.</p>
<p><strong>In Ember 2.0, we will stop setting attributes as properties on the
component itself.</strong></p>
<p>We will also provide a transitional mixin that Ember addons can use that
will make provided attributes available as <code>attrs.*</code>. This will allow
add-ons to move to the new location, while maintaining support for older
versions of Ember. We expect people to upgrade to Ember 1.10 relatively
quickly, and do not expect addons to need to maintain support for Ember
1.9 indefinitely.</p>
<a class="header" href="print.html#routeable-components" id="routeable-components"><h2>Routeable Components</h2></a>
<p>Many people have noticed that controllers in Ember look a lot like
components, but with an arbitrary division of responsibilities. We
agree!</p>
<p>In current versions of Ember, when a route is entered, it builds a
controller, associates a model with it, and hands it off to an
(old-style) view for rendering. The view itself is invisible; you just
write a template with the correct name.</p>
<p>We plan to transition to: when a route is entered, it renders a
<strong>component</strong>, passing along the model as an <code>attr</code>. This eliminates a
vestigial use of old-style views, and associates the top-level template
with a regular component.</p>
<a class="header" href="print.html#transition-plan-6" id="transition-plan-6"><h3>Transition Plan</h3></a>
<p>Initially, we will continue to support routing to a controller+template,
so nothing will break. Going forward, routes will route to a component
instead.</p>
<p>In order to do that refactoring, several things will change:</p>
<ul>
<li>Instead of referring to model properties directly (or on <code>this</code>), you
will refer to them as <code>model.propName</code>.</li>
<li>Similarly, computed properties that move to your component will need
to depend on <code>model.propName</code> if they are migrated from an
<code>ObjectController</code>.</li>
<li>In both cases, the short version is that you can no longer rely on the
proxying behavior of <code>ObjectController</code> or <code>ArrayController</code>, but you
can remedy the situation by prefixing <code>model.</code> to the property name.</li>
<li>Unlike controllers, top-level components do not persist across
navigation. Persistent state should be stored in route objects and
passed as initial properties to routable components.</li>
<li>In addition to the asynchronous <code>model</code> hook in routes, routes will
also be able to define a <code>attrs</code> hook, which can return additional
asynchronous data that should be provided to the component.</li>
<li>Routeable Components should be placed in a &quot;pod&quot; naming convention. For
example, the component for the <code>blog-post</code> route would be
<code>app/blog-post/component.js</code>.</li>
</ul>
<p><strong>We plan to land support for routeable components in Ember 1.12, and
deprecate routeable controllers at the same time. We plan to remove
support for routeable controllers in Ember 2.0.</strong> This will allow
you to move your codebases over to routeable components piecemeal before
making the jump to 2.0.</p>
<p><strong>We will also provide an optional plugin for Ember 2.0 apps that restores
existing behavior.</strong> This plugin will be included in the Ember automated
test suite to ensure that we do not introduce accidental regressions in
future releases on the 2.x series.</p>
<p>We realize that this is the change has the largest transitional cost of
all the planned features, and we plan to dedicate time to the precise
details in the full RFC on this topic.</p>
<a class="header" href="print.html#improving-actions" id="improving-actions"><h2>Improving Actions</h2></a>
<p>Today's components can communicate with their parent component through
actions. In particular, the <code>sendAction</code> method allows a child component
to invoke a named action on the parent (inside of the <code>actions</code> hash).</p>
<p>Part of the reason for this API was a limitation in the original
Handlebars syntax:</p>
<pre><code class="language-handlebars">{{!-- we can't get too fancy with the value of key-press --}}
{{input key-press=&quot;valueChanged&quot;}}
</code></pre>
<p>In this example, when the <code>input</code> component calls
<code>this.sendAction('key-press')</code>, it invokes the <code>valueChanged</code> action on
its parent component.</p>
<p>With the new HTML syntax for components, we have more flexibility:</p>
<pre><code class="language-handlebars">&lt;input key-press={{action &quot;valueChanged&quot;}}&gt;
</code></pre>
<p>This will package up the parent's <code>valueChanged</code> action (in the
<code>actions</code> hash) as a callback function that is available to the child
component as <code>this.attrs['key-press']</code>.</p>
<pre><code class="language-js">export default Ember.Component.extend({
  keypress: function(event) {
    this.attrs['key-press'](event.target.value);
  }
});
</code></pre>
<p>The benefit of this approach is twofold:</p>
<ul>
<li>Actions are no longer treated specially in the component API. They are
simply properties packaged up to be called by the child component.</li>
<li>It is possible to pass an alternative function as the <code>key-press</code>,
reducing the child component's knowledge of what the callback is
doing. This has testing and abstraction benefits.</li>
</ul>
<a class="header" href="print.html#transition-plan-7" id="transition-plan-7"><h3>Transition Plan</h3></a>
<p>We will continue to support the <code>sendAction</code> API for the forseeable
future in today's Handlebars syntax.</p>
<p>When calling an existing component with new HTMLBars syntax, you do not
need to change your existing <code>actions</code> hash. You should change syntax
that looks like this:</p>
<pre><code class="language-handlebars">{{video-player playing=&quot;playingBegins&quot;}}
</code></pre>
<p>To this:</p>
<pre><code class="language-handlebars">&lt;video-player playing={{action &quot;playingBegins&quot;}}&gt;
</code></pre>
<p>The <code>video-player</code> component's internal use of <code>sendAction</code> will work
with both calling styles.</p>
<p>New components should use <code>this.attrs.playing()</code>, but existing components
that want to continue supporting legacy callers should continue to use
<code>sendAction</code> for now. The <code>sendAction</code> API will seamlessly support both
calling styles, and will be supported for the forseeable future.</p>
<pre><code class="language-js">// instead of
this.sendAction('progress', value);

// new code can use
this.attrs.progress(value);
</code></pre>
<a class="header" href="print.html#onward" id="onward"><h2>Onward</h2></a>
<p>Version 2.0 marks the transformation of Ember from simply an MVC framework
to a complete front-end stack. Between Ember's best-in-class router,
revamped components with virtual DOM, easy-to-use build tools, and a growing
ecosystem that makes taking advantage of additional libraries a breeze, there's
no better way to get started and stay productive developing web apps today.</p>
<p>Hopefully, this plan demonstrates that staying on the cutting-edge can be done
without rewriting your app. There are a huge number of Ember apps in production
today, and we're looking forward to a time in the very near future where they
can start to take advantage these new features.</p>
<p>Expect to see many more RFCs covering these features in depth soon (including
a roadmap for Ember Data 1.0). We look forward to hearing your feedback!</p>
<ul>
<li>Start Date: 2015-07-10</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/20">#20</a></li>
</ul>
<a class="header" href="print.html#summary-6" id="summary-6"><h1>Summary</h1></a>
<p>Enable <a href="http://www.w3.org/TR/SRI/">Subresource Integrity [SRI]</a> checks by default.</p>
<a class="header" href="print.html#motivation-7" id="motivation-7"><h1>Motivation</h1></a>
<p>To promote the use of SRI in Ember apps as a safe default. Applications should be built with integrity attributes when it is safe to do so. (Unfortunately the main advantage won't be met by default, however confirming one attribute will)</p>
<p>This solves having poisoned CDN content: <a href="https://blog.cloudflare.com/an-introduction-to-javascript-based-ddos/">An introduction to JavaScript-based DDoS</a></p>
<a class="header" href="print.html#detailed-design-6" id="detailed-design-6"><h1>Detailed design</h1></a>
<p>Install <a href="https://www.npmjs.com/package/ember-cli-sri">ember-cli-sri</a> by default.</p>
<ul>
<li>Applications with relative paths will get SRI.</li>
<li>Applications with <code>SRI.crossorigin</code> will get SRI on <code>fingerprint.prepend</code> assets</li>
<li>Applications with <code>fingerprint.prepend</code> and <code>origin</code> specified and matching get a <code>SRI.crossorigin</code> of anonymous on <code>fingerprint.prepend</code> assets</li>
</ul>
<p>By default development environments wont run SRI for performance reasons.</p>
<p>Further explanation available in: <a href="https://www.npmjs.com/package/ember-cli-sri">ember-cli-sri</a></p>
<a class="header" href="print.html#drawbacks-6" id="drawbacks-6"><h1>Drawbacks</h1></a>
<ul>
<li>SRI won't always be on for sites with prepend due to SRI requiring CORS.</li>
<li>CORS requirement adds a barrier to entry to some users.</li>
<li>Broken SRI attrs would break the application.</li>
</ul>
<a class="header" href="print.html#alternatives-6" id="alternatives-6"><h1>Alternatives</h1></a>
<p>No other alternatives appear suitable.</p>
<a class="header" href="print.html#unresolved-questions-6" id="unresolved-questions-6"><h1>Unresolved questions</h1></a>
<ul>
<li>Adding origin attribute to add a safe same-origin check that doesn't need CORS.</li>
<li>Could users be warned until they explicitly set <code>SRI.enabled = false</code> or <code>SRI.crossorigin =</code>?</li>
</ul>
<ul>
<li>Start Date: 2015-08-18</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/23">#23</a></li>
</ul>
<a class="header" href="print.html#summary-7" id="summary-7"><h1>Summary</h1></a>
<p>Adds command line completion <em>(tab completion)</em> to ember-cli that fills in partially typed commands by the user and suggests available sub commands or options. <em>(from now on i will refer to &quot;strings in the command line&quot; as &quot;cli-commands&quot; and &quot;generate&quot; and &quot;new&quot; as unprefixed &quot;commands&quot;)</em></p>
<p><img src="http://zippy.gfycat.com/PrestigiousLoneHalicore.gif" alt="" /></p>
<a class="header" href="print.html#motivation-8" id="motivation-8"><h1>Motivation</h1></a>
<p>With all the already existing commands and especially all blueprints, plus the fact that any addon can add even more blueprints to your tool kit, users can get overwhelmed. Currently, when you want to execute a specific task and you don't quite know the correct cli-command you have to invoke <code>ember help</code> which is noisy and slow <em>( especially when you just want to know the spelling of a specific thing)</em>. This feature will enable the user to choose from all existing cli-commands by pressing <strong>[tab]</strong> or just to let ember-cli fill partially typed cli-commands for speed.</p>
<a class="header" href="print.html#detailed-design-7" id="detailed-design-7"><h1>Detailed design</h1></a>
<p>The two main components of that feature are a <strong>completion function</strong> that is responsible for the actual tab-completion, and a <strong>generation function</strong> that will write the cli-command hierarchy together with metadata into a JSON file for fast processing.</p>
<a class="header" href="print.html#completion-function" id="completion-function"><h2>completion function</h2></a>
<p>To enable this feature, a <strong>completion function</strong> will run at the main entry point of the process <em>(making use of  <a href="https://github.com/f/omelettev">omelette</a> for shell completion)</em>. On every <strong>[tab]</strong> it will parse the command line and either completes a partially typed, unambiguous cli-command, or suggests possible cli-commands for the current context.</p>
<p>The user interface will work as you would expect it from a shell completion:</p>
<ul>
<li>
<p>it suggests all commands if none are typed yet</p>
<pre><code>  $ ember &lt;tab&gt;
  &gt; addon     destroy   help      install   serve     version
    build     generate  init      new       test
</code></pre>
</li>
<li>
<p>it completes partially typed commands</p>
<pre><code>  $ ember gen&lt;tab&gt;
  $ ember generate
</code></pre>
</li>
<li>
<p>it completes to suggests commands based on user input (note how it <strong>should</strong> understand aliases)</p>
<pre><code>  $ ember g ad&lt;tab&gt;
  &gt; adapter       adapter-test  addon
</code></pre>
</li>
<li>
<p>it, by default, will not suggest options</p>
<pre><code>  $ ember g resource &lt;tab&gt;
</code></pre>
</li>
<li>
<p>it will suggest options on demand (note how it <strong>should</strong> know when an option needs a value)</p>
<pre><code>  $ ember g resource post --&lt;tab&gt;
  --dry-run         --in-repo-addon=  --verbose
  --dummy           --pod
</code></pre>
</li>
</ul>
<a class="header" href="print.html#generation-function" id="generation-function"><h2>generation function</h2></a>
<p>For a good user experience we don't want to figure out those suggestions on runtime or the completion feature would not be substantially faster then the <code>ember help</code> command. So there will be a <strong>generation function</strong> that generates a JSON file once after ember-cli is installed and then during every <code>ember install some-addon</code> command to ensure that blueprints added by new addons are recognized aswell.</p>
<p>Here an example snippet of a cli-command with one cli-subcommand:</p>
<pre><code>  ...
  {
    &quot;name&quot;: &quot;command-name&quot;,
    &quot;aliases&quot;: [
      &quot;cn&quot;,
      &quot;c&quot;
    ],
    &quot;options&quot;: [
    ],
    &quot;commands&quot;: [
      {
        &quot;name&quot;: &quot;some-subcommand&quot;,
        &quot;aliases&quot;: [
        ],
        &quot;options&quot;: [
          {
            &quot;name&quot;: &quot;pods&quot;,
            &quot;type&quot;: &quot;boolean&quot;
          }
        ],
        &quot;commands&quot;: [
        ]
      }
    ]
  }
  ...
</code></pre>
<p>The <strong>generation function</strong> will, as a first step, iterate over all commands and reads the following properties:</p>
<ul>
<li><strong>name:</strong> a string, the autocompletion function will suggest</li>
<li><strong>aliases:</strong> this is what the autocompletion function will accept in the cli-command chain</li>
<li><strong>availableOptions:</strong> an array of options that need to have a <code>name</code> and a <code>type</code> property those will be accumulated for every cli-command in the cli-command chain and suggested on <code>some-command --&lt;tab&gt;</code></li>
<li><strong>cliCommands:</strong> can either be an array or a function that returns an array of objects that themselfs will be parsed for the properties in this list those cli-commands will be accepted as subcommands of the current cli-command.</li>
<li><strong>skipHelp:</strong> whenever this property is set to true, the cli-command will also not be suggested by the autocompletion</li>
</ul>
<p>Whenever an object does not have one of the above properties, a reasonable default is chosen (except for <code>name</code>. If it has no name, it will not be shown at all). This way it is easy to extend that feature in the future to handle arbitrary nested cli-commands.</p>
<a class="header" href="print.html#alternatives-7" id="alternatives-7"><h1>Alternatives</h1></a>
<ul>
<li>Currently the <strong>completion function</strong> will just expect certain properties to be on a cli-command, this way most commands and blueprints work out of the box but maybe some architectual pattern, like a cli-command mixin or the like would be more robust and obvious.</li>
<li>Someone with more experience with ember-cli could have an idea of how to generate all cli-commands fast enough at runtime. So that we would not need to store the data in a JSON file.</li>
</ul>
<a class="header" href="print.html#unresolved-questions-7" id="unresolved-questions-7"><h1>Unresolved questions</h1></a>
<p>Currently the autocompletion will figure out your default shell and configures it to allow tab-completion for ember. However on <strong>first-time usage</strong> you would need to resource your config file (or close and open your terminal) and I haven't figured out how to do this programmatically.</p>
<ul>
<li>2014-11-26</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/24</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#summary-8" id="summary-8"><h1>Summary</h1></a>
<p>Unlike Handlebars, HTMLBars parses HTML as it parses a template.
Bound attributes are one syntax now possible.</p>
<p>For example, this variable <code>color</code> is bound to set a class:</p>
<pre><code class="language-hbs">&lt;div class=&quot;{{color}}&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Though traditional HTML attribute syntax should be preserved (using
<code>class</code> and not <code>className</code> for example), the default path will be
to set attributes as properties on the DOM node.</p>
<p>However this happy path has several important exceptions, and results
in a few strange edge cases. This rfc will go into detail about the
expected behavior without talking about the implementation of attribute
on the Ember rendering pipeline.</p>
<a class="header" href="print.html#motivation-9" id="motivation-9"><h1>Motivation</h1></a>
<p><code>{{bind-attr</code> is a verbose syntax and difficult for new developers to
understand.</p>
<a class="header" href="print.html#detailed-design-8" id="detailed-design-8"><h1>Detailed design</h1></a>
<p>Given a use of bound attributes:</p>
<pre><code class="language-hbs">&lt;input type=&quot;checkbox&quot; checked={{isChecked}}&gt;
</code></pre>
<p>There are three important inputs:</p>
<ul>
<li>The element (<code>tagName</code>, <code>namespaceURI</code>)</li>
<li>The attribute name</li>
<li>The value (literal or stream)</li>
</ul>
<p>The following described the algorithm for updating the attribute/property
value on an element.</p>
<ol>
<li>If the element has an SVG namespace, use <code>setAttribute</code>. Setting SVG attributes
as properties is not supported.</li>
<li>If the attribute name is <code>style</code>, use <code>setAttribute</code>.</li>
<li>Normalize the property name as described in <code>propertyNameFor</code> below. If a normalized
name is returned, set that property on the element (<code>element[normalizedPropName]</code>).
If it is not returned, set with <code>setAttribute</code>.</li>
</ol>
<p><code>propertyNameFor</code> is a normalization setup for attribute names that takes the element
and attribute name as input.</p>
<ol>
<li>Build a list of normalized properties for the passed element <code>normalizedAttrs[element.tagName][elementAttrName.toLowerCase()] = elementAttrName</code></li>
<li>Fetch the normalized property name from this list <code>normalizedAttr = normalizedAttrs[element.tagName][passedAttrName.toLowerCase()]</code></li>
<li>Return this normalized attr. If an <code>attrName</code> is did not normalize to a property (for example <code>class</code>), null is returned</li>
</ol>
<a class="header" href="print.html#acknowledged-edge-cases" id="acknowledged-edge-cases"><h3>Acknowledged edge cases</h3></a>
<ul>
<li>Boolean attrs with blank string won't work like they would in HTML: <code>&lt;input disabled=&quot;{{blankString}}&quot;&gt;</code> would be false</li>
<li>Some selectors may not work as expected. <code>&lt;input value=&quot;{{color}}&quot;&gt;</code> will not result in a working <code>[value=red]</code> selector</li>
</ul>
<a class="header" href="print.html#drawbacks-7" id="drawbacks-7"><h1>Drawbacks</h1></a>
<p>None.</p>
<a class="header" href="print.html#alternatives-8" id="alternatives-8"><h1>Alternatives</h1></a>
<p>Two obvious alternatives considered in detail are Angular and React.</p>
<p>In <strong>Angular 2.0</strong>, <a href="http://www.beyondjava.net/blog/angularjs-2-0-sneak-preview-data-binding/">a new prop/attr/event syntax</a>
is being introduced.</p>
<p>Setting an attribute just like setting an HTML attribute:</p>
<pre><code class="language-html">&lt;pui-tab title=&quot;What a nice tab!&quot;&gt;
</code></pre>
<p>Properties are flagged with the <code>[]</code> syntax:</p>
<pre><code class="language-html">&lt;input [disabled]=&quot;controller.isInputDisabled&quot;&gt;
</code></pre>
<p>Angular is limited by it's HTML templating here. The value must be quoted
to have complex content, where as in HTMLBars it is easier to bend the
rules to introduce literal values: <code>disabled={{controller.isInputDisabled}}</code>.</p>
<p>Events are out of our immediate purview in this RFC, but for completeness
note Angular's syntax:</p>
<pre><code class="language-html">&lt;button (click)=&quot;hide()&quot;&gt;hide image&lt;/button&gt;
</code></pre>
<p><strong>React's JSX</strong> has its own <a href="http://facebook.github.io/react/docs/jsx-in-depth.html">property syntax</a>,
one that diverges from traditional HTML by focusing entirely on properties
instead of attributes. This means the templates are well prepared for
use with components, but also that JSX must maintain a large whitelist of
special cases such as <a href="http://facebook.github.io/react/docs/tags-and-attributes.html">supported tags</a>
and <a href="http://facebook.github.io/react/docs/jsx-gotchas.html">some HTML attributes</a>.</p>
<p>In general we would prefer to have Ember templates be as close to HTML
as possible, without requiring developers to learn a new set of property
names replacing the attribute names they already know.</p>
<a class="header" href="print.html#unresolved-questions-8" id="unresolved-questions-8"><h1>Unresolved questions</h1></a>
<ul>
<li>How do we deal with <code>on*</code> attributes?</li>
<li>Should we do anything special about generic element properties like <code>&lt;div outerhtml={{lol}}&gt;&lt;/div&gt;</code>?</li>
<li>Should HTMLBars unbound attributes use the same alorithm?</li>
</ul>
<p>There is a spike of significant depth <a href="https://github.com/emberjs/ember.js/pull/9721">in PR #9721</a>
and a followup <a href="https://github.com/emberjs/ember.js/pull/9977">in PR #9977</a>.</p>
<ul>
<li>Start Date: 2015-11-02</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/28">#28</a></li>
</ul>
<a class="header" href="print.html#summary-9" id="summary-9"><h1>Summary</h1></a>
<p>Allow <code>app.import</code> to specify outputFIle of a given import.
The default <code>app.import</code> would be considered to have an outputFile of
<code>assets/vendor.js</code></p>
<a class="header" href="print.html#motivation-10" id="motivation-10"><h1>Motivation</h1></a>
<p>It is common for individuals to want control over the outputFile for a given
dependency. For example, one may want to load some asm.js code independently
rather then via the single vendor.js blob.</p>
<p>It is also common for developers to want to group various dependencies
together, and then lazy-load them in the routes they are required.</p>
<p>Although not as automatic as we would like, it does provide a rather elegant
escape valve. Further work will likely continue to explore automation.</p>
<a class="header" href="print.html#detailed-design-9" id="detailed-design-9"><h1>Detailed design</h1></a>
<p><code>outputFile:</code> option, specifies the target file for the given import. If
multiple imports share an outputFile, they will be concatenated (regardless of
type, css/images/videos/js/txt) in the order they where imported.</p>
<p><code>outputFile:</code> will default to <code>assets/vendor.js</code></p>
<a class="header" href="print.html#examples" id="examples"><h2>Examples</h2></a>
<a class="header" href="print.html#variation-0-the-default" id="variation-0-the-default"><h4>variation 0: the default</h4></a>
<pre><code class="language-js">app.import('vendor/vim.js', { outputFile: 'assets/vendor.js'});
</code></pre>
<a class="header" href="print.html#variation-1-1-file---1-outputfile" id="variation-1-1-file---1-outputfile"><h4>variation 1: 1 file -&gt; 1 outputFile</h4></a>
<pre><code class="language-js">app.import('vendor/vim.js', { outputFile: 'assets/vim.js'});
</code></pre>
<ul>
<li><code>vendor/vim.js</code> becomes <code>assets/vim.js</code></li>
<li>in prod it is:
<ul>
<li>uglified (unless using the uglify options it is excluded)</li>
<li>fingerprinted (unless it is excluded via the asset-rev options)</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#variation-2-multiple-files-to-same-outputfile" id="variation-2-multiple-files-to-same-outputfile"><h4>variation 2, multiple files to same outputFile</h4></a>
<pre><code class="language-js">app.import('vendor/dependency-1.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-2.js', { outputFile: 'assets/alternate-vendor.js'});
</code></pre>
<ul>
<li>in-order of the corresponding <code>app.import</code> invocation, using sourceMap
concat, the files are combined into <code>assets/alternate-vendor.js</code>
<ul>
<li><code>vendor/dependency-1.js</code> + <code>vendor/dependency-2.js</code> &gt;&gt; <code>assets/alternative-vendor.js</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#variation-n-multiple-files-to-same-outputfile" id="variation-n-multiple-files-to-same-outputfile"><h4>variation n, multiple files to same outputFile</h4></a>
<pre><code class="language-js">app.import('vendor/dependency-1.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-2.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-n.js', { outputFile: 'assets/alternate-vendor.js'});
</code></pre>
<ul>
<li>resulting concat is:
<ul>
<li><code>vendor/dependency-1.js</code> + <code>vendor/dependency-2.js</code> ... <code>vendor/dependency-n.js</code>&gt;&gt; <code>assets/alternative-vendor.js</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#drawbacks-8" id="drawbacks-8"><h1>Drawbacks</h1></a>
<ul>
<li>potential overlap with @chadhietala's packager/linker work</li>
<li>does not offer additional build-pipeline hooks for these files</li>
</ul>
<a class="header" href="print.html#alternatives-9" id="alternatives-9"><h1>Alternatives</h1></a>
<p>Alternatives exist, such as adding support to the linker/packager
effort, or instructing developers to drop down and use
broccoli-funnel/source-map-concat.</p>
<p>The linker/packager effort is still a ways off, and could be thought of as
complementary.</p>
<p>Dropping down to broccoli is a solution available today, but for this problem,
it feels like a slightly too low level of abstraction.</p>
<a class="header" href="print.html#unresolved-questions-9" id="unresolved-questions-9"><h1>Unresolved questions</h1></a>
<ul>
<li>how does this relate to <code>type</code> in <code>app.import(..., { type: ... })</code> ?</li>
<li>should additional build-steps be allowed for specific output files? (I
suspect maybe, but a future RFC can likely explore)</li>
</ul>
<ul>
<li>Start Date: 2015-11-11</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/29">#29</a></li>
</ul>
<a class="header" href="print.html#summary-10" id="summary-10"><h1>Summary</h1></a>
<p>It should be possible to white- and/or blacklist addons in <code>EmberApp</code>.</p>
<a class="header" href="print.html#motivation-11" id="motivation-11"><h1>Motivation</h1></a>
<p>If there are two (or more) <code>EmberApp</code>s, it's very likely that not all applications need all addons.
E.g. if there is a main page application and one application for embeddable widgets, the main page might need all sorts of addons like <code>ember-modal-dialog</code> which adds completely useless bytes to widgets javascript and css files for the widgets. Other addons may add useless initializers or other things that have runtime performance penalties for no benefit.</p>
<a class="header" href="print.html#detailed-design-10" id="detailed-design-10"><h1>Detailed design</h1></a>
<p>When EmberApp ctor gets passed a blacklist like this</p>
<pre><code class="language-javascript">  EmberApp({
    addonBlacklist: ['ember-modal-dialog']
  });
</code></pre>
<p>it won't add addons whose <code>name</code> matches <code>ember-modal-dialog</code> to the list of addons for this app, just as if the addon's <code>isEnabled()</code> hook returned <code>false</code>.</p>
<p>C.f. https://github.com/ember-cli/ember-cli/blob/master/lib/broccoli/ember-app.js#L344, this is also were I would add this check.</p>
<p>Whitelist could work analogously.</p>
<a class="header" href="print.html#drawbacks-9" id="drawbacks-9"><h1>Drawbacks</h1></a>
<ul>
<li>
<p>It adds a bit of API surface while you (possibly) don't care for the multiple app use case of ember-cli.</p>
</li>
<li>
<p>It kinda makes the <code>name</code> of an addon public api, so people might change it, not noticing they are breaking people's build (and people might not notice it either). Some addons have names like <code>Ember CLI ic-ajax</code> which seems awkward to use as an identifier.</p>
</li>
</ul>
<a class="header" href="print.html#alternatives-10" id="alternatives-10"><h1>Alternatives</h1></a>
<ul>
<li>Add a unified way to enable/disable an addon via normal config
<ul>
<li>if that is added one day, the white/blacklist could still be an abstraction for that</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#unresolved-questions-10" id="unresolved-questions-10"><h1>Unresolved questions</h1></a>
<p>None.</p>
<ul>
<li>Start Date: 2015-06-07</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/45</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-11" id="summary-11"><h1>Summary</h1></a>
<p>Solicit feedback about the support timeframe for Internet Explorer 8 and Internet Explorer 9.</p>
<a class="header" href="print.html#motivation-12" id="motivation-12"><h1>Motivation</h1></a>
<p>As Ember heads towards version 2.0, it is a good time to evaluate our browser support matrix. Ember follows Semantic Versioning, and we consider browser compatibility to be under the umbrella of those guarantees. In other words, we will continue to support whatever browsers we officially support in Ember 2.0 until Ember 3.0.</p>
<p>Ember 1.x did not have an official browser support matrix, but we would like to correct this for Ember 2.0.</p>
<p>We want to make this decision on the basis of the browsers that our community still needs to support, while weighing that against the costs we bear as a community to support older browsers. This RFC will lay out some of those costs, so we can decide what tradeoff is most appropriate.</p>
<p>Members of the core team maintain many different kinds of apps across many different kinds of companies. Some of us work on applications with small, agile teams, while others work inside of large corporations with many engineers. When this topic came up amongst the team, we discovered that, across all these different companies and Ember apps, no one was still supporting IE8.</p>
<p>Because of this, the core team's impression is that the costs of IE8 support now far exceed the benefits, and we are considering dropping support
for IE8 in Ember 2.0. Before we make the decision, we want to hear from the rest of the community. Supporting IE8 incurs significant cost, both in terms of features and maintenance, and we want the community to help us think through the cost-benefit analysis.</p>
<p>Ember is more than just the framework's code. When people use Ember, they expect to be able to use Ember's tooling, read Ember's documentation, find solutions to problems on Stack Overflow, and read tutorials produced by community members. All of these are shackled to the limitations of IE8, and by dropping support for IE8, people can begin to rely on the improved baseline of ES5.</p>
<p>Below, we outline the costs of continuing to support IE8, so that you can help us make a considered decision.</p>
<a class="header" href="print.html#detailed-design-11" id="detailed-design-11"><h1>Detailed design</h1></a>
<a class="header" href="print.html#ie8" id="ie8"><h2>IE8</h2></a>
<a class="header" href="print.html#eliminate-get" id="eliminate-get"><h3>Eliminate <code>get()</code></h3></a>
<p>Currently, accessing properties on an Ember object requires using the <code>.get()</code> method. By using this abstraction, we have been able to implement several powerful features, such as proxies and computed properties, even on older browsers like IE8 that lack getters and setters.</p>
<p>However, ECMAScript 5, which shipped in <strong>2009</strong>, added support for getters to JavaScript itself, and we would like to use this feature in Ember to eliminate the explicit calls to <code>get</code>. Developers new to the framework tell us that having to remember to use <code>.get()</code> is a big source of confusion. More seasoned developers get used to it, but moving the Ember object model closer to the pure JavaScript object model is a major goal for Ember 2.x. While many of the features of ES6 classes can be transpiled, getters and setters require engine support, and could not be used if we needed to support IE8.</p>
<a class="header" href="print.html#more-es6-features-today" id="more-es6-features-today"><h3>More ES6 Features, Today</h3></a>
<p>While much of ES6 can be transpiled correctly to ES3 (the version of JavaScript included with IE8), transpiling ES6 modules and classes requires <code>defineProperty</code>.</p>
<p>Continued support for IE8 limits our ability to adopt new ES6 features in the internals of Ember, and to talk about them in our documentation.</p>
<p>One example: In ES6, classes define their methods as non-enumerable properties. Transpiling this to existing browsers is only possible with <code>defineProperty</code>, which is not included in IE8. Trying to transpile ES6 classes to work on IE8 would lead to apps exhibiting subtly different behavior that would be painful to debug. IE8 users would discover that the larger Ember ecosystem was incompatible with their apps in hard-to-predict ways, and we think the ecosystem is one of the biggest advantages Ember offers.</p>
<p>In other words, we don't think we can make the full transition to JavaScript classes a first-class part of the Ember experience if we still support IE8. As we did with modules, we would like to move more of our core to JavaScript features in the future, which would be significantly stymied by the lack of <code>defineProperty</code> in IE8.</p>
<a class="header" href="print.html#remove-the-jquery-dependency" id="remove-the-jquery-dependency"><h3>Remove the jQuery Dependency</h3></a>
<p>For its entire lifetime, Ember has relied on jQuery to smooth the rough edges of browser compatibility when interacting with the DOM. When people think about that dependency, they often assume that we could just replace calls to things like <code>.attr</code> with their more verbose DOM counterpart and call it a day.</p>
<p>jQuery does more than just patch over IE8 rough spots; it also serves as the central place for normalizing behavior that can differ significantly across browsers. If we tried to pick-and-choose pieces of jQuery to pull into Ember, we would also be responsible for backporting any changes made to jQuery. We'd rather just rely on jQuery directly; that's what dependencies are for.</p>
<p>The jQuery dependency has helped us with a few cross-browser areas:</p>
<ul>
<li>Portable <code>DOMContentLoaded</code> (via <code>jQuery.ready</code>)</li>
<li>Support for event delegation across a wide variety of events.</li>
<li>Attribute and property normalization, which has already been implemented by HTMLBars</li>
<li>HTML parsing, which has also been implemented by HTMLBars</li>
</ul>
<p>Of these, proper support for event delegation is the largest remaining reason to rely on jQuery. IE9's support for the capture phase of events makes it simpler to support event delegation properly across all event types without a normalization layer.</p>
<a class="header" href="print.html#support-more-event-types" id="support-more-event-types"><h3>Support More Event Types</h3></a>
<p>Many newly specified events in the web platform (such as the media events) do not bubble, which is a problem for frameworks like Ember that rely on event delegation. However, the capture API, which was added in IE9, is invoked properly for all events, and does not require a normalization layer. Not only would supporting the capture API allow us to drop the jQuery dependency, but it would allow us to properly handle these non-bubbling events. This would allow you to use events like <code>playing</code> in your components without having to manually set up event listeners.</p>
<a class="header" href="print.html#css-improvements-in-ember-2x" id="css-improvements-in-ember-2x"><h3>CSS Improvements in Ember 2.x</h3></a>
<p>Today, the main Ember framework does very little to directly help with CSS. We expect that to change in the 2.x series, as we explore ways to help tame the CSS beast.</p>
<p>However, a number of important CSS features landed in IE9: CSS3 selectors, full support for <code>querySelectorAll</code>, <code>getComputedStyle</code>, <code>calc()</code> to name a few. Productively tackling the CSS problem without these features would be like fighting with both hands tied behind our backs, and it may be impossible for us to robustly tackle the problem until Ember 3.0 if we needed to continue to support IE8.</p>
<p>While it may be theoretically possible to implement some form of this feature in IE8, it is likely that the cost of doing so in a backwards-compatible way would significantly add to development time; perhaps so significantly it would be better to wait until we drop support for IE8 than attempt to bolt it on to a browser released half a decade ago.</p>
<a class="header" href="print.html#maintenance-costs" id="maintenance-costs"><h3>Maintenance Costs</h3></a>
<p>While it's very easy to weigh the costs of features that we could not implement at all due to IE8, there is a much more pernicious cost that is harder to see.</p>
<p>Support for IE8 adds costs, sometimes significant, to every new feature we work on. For example, broken support for text nodes in IE8 significantly impeded early work on Glimmer. Every new area of work requires budgeting a significant amount of time for IE8 support.</p>
<p>This is not surprising. When asked many years ago what jQuery could do when IE6 was gone, John Resig replied that we would gain little from dropping IE6, and that the benefits would not come until jQuery could drop IE8, the last version of IE featuring the bugs that made IE6 so difficult to develop for.</p>
<p>Quite often, we will assume that a feature is ready to ship, and only discover subtle issues in IE8 very close to the release once it has been tested. We estimate that support for legacy Internet Explorer slowed down the development of HTMLBars by 2x.</p>
<p>In short, we would be able to implement more features more quickly without the burden of bugs that were first introduced 15 years ago.</p>
<a class="header" href="print.html#what-about-ie9" id="what-about-ie9"><h2>What About IE9?</h2></a>
<p>In the first decade of 2000, browsers were updated very slowly, and every new release took a long time to be supplanted by the next release. As the last version of Internet Explorer supported by Windows XP, IE8 is a relic of this bygone era. In contrast, IE9 usage was quickly supplanted by IE10, and that pattern continues with IE11.</p>
<p>The public trackers have IE9 at a lower share of total usage than IE8, so it might be worth considering dropping them together. Our decision for Ember 2.0 will likely hold until late 2016, so it's worth considering more than just the current moment when making the decision.</p>
<p>While IE9 added support for the ES5 features we need to move into the future for JavaScript, IE10 added support for the last great wave of web features. Here is a sampling:</p>
<ul>
<li>Flexbox and Grid Layout</li>
<li>Offline storage (IndexedDB, File, Blob)</li>
<li>Web Workers</li>
<li>Typed Arrays</li>
<li>Web Sockets</li>
<li>App Cache</li>
<li>History API</li>
</ul>
<p>Several of these features are required for asm.js, and in total, they make the web platform a capable application runtime. While we don't have any immediate plans to take advantage of these web features right now, the best experiments that people are doing today rely on them. By assuming IE10 as the baseline across the entire ecosystem, we would be able to do much more aggressive experimentation on the web platform.</p>
<a class="header" href="print.html#drawbacks-10" id="drawbacks-10"><h1>Drawbacks</h1></a>
<p>Many users have told us that they chose Ember because of the community's commitment to backwards compatibility. When we announced in early 2014 that we would continue to support IE8 for at least another year, other libraries and frameworks had already dropped support. That being said, there will always be organizations using Ember that exist on the tail-end of browser adoption patterns. We risk alienating or upsetting those users by dropping support for a browser that, while on the way out, is not yet completely gone.</p>
<p>However, in many cases, the requirement of IE8 support is driven by non-technical management who do not have a strong sense of the experience of using apps in IE8. In practice, many applications are not rigorously tested in older browsers, and the performance of IE8 is so bad that applications written using any framework perform poorly. Techniques that framework and application developers use to make Chrome fast quite often have pathological characteristics on browsers with a DOM and JavaScript engine written in the 90s.</p>
<p>Still, some people make it work, and dropping IE8 support may prevent those teams from staying with the community as it migrates to Ember 2.0.</p>
<a class="header" href="print.html#alternatives-11" id="alternatives-11"><h1>Alternatives</h1></a>
<a class="header" href="print.html#drop-ie8-support-during-2x" id="drop-ie8-support-during-2x"><h2>Drop IE8 Support During 2.x</h2></a>
<p>One alternative we have considered is deprecating IE8 support prior to releasing 2.0, but still maintaining it for a few point releases to give IE8 more time to lose market share.</p>
<p>After discussing with the core team, we believe that this would be a violation of our Semantic Versioning commitment to users. Specifically, we want to avoid a large group of apps getting stuck midway through the 2.x cycle. Version numbers are an important tool for developers, maintainers and ecosystems to communicate compatibility. Tools such as package managers rely on version numbers correctly indicating breaking changes.</p>
<p>We consider browser compatibility to be a feature of Ember, and dropping IE8 support in a minor release would be akin to stripping out any other major feature. While the ecosystem would muddle along in either case, such a move would cause exactly the kind of ecosystem fragmentation that Semantic Versioning is designed to prevent.</p>
<p>If we want to communicate the idea that changing versions comes with a reduction in functionality, we should do that the same way we always do, by incrementing the major version.</p>
<a class="header" href="print.html#early-30" id="early-30"><h2>Early 3.0</h2></a>
<p>Another option is to release 3.0 in six months, rather than the nearly two years between Ember 1.0 and Ember 2.0.</p>
<p>Correctly tuning the cadence of major releases is a delicate tradeoff. Semantic Versioning allows us to easily communicate about breaking changes, and some take this as a license to make them frequently. However, a robust ecosystem relies on a certain measure of stability.</p>
<p>We believe that the frustration of breaking changes every six months (or even a year) would outweigh whatever benefits it would provide. Ember's biggest goal is building a shared foundation for our ecosystem to build on, and this requires a careful commitment to stability.</p>
<p>While we could make a &quot;small&quot; breaking release soon after 2.0, breaking changes inherently fragment the ecosystem, and we hope that the years to come bring more stability for add-on authors and tool-makers, not less.</p>
<a class="header" href="print.html#bring-your-own-compatibility" id="bring-your-own-compatibility"><h2>Bring Your Own Compatibility</h2></a>
<p>Some libraries attempt to thread the needle of IE8 compatibility by asking users to bring their own compatibility libraries. They write the internals of their framework as if IE8 did not exist, and require end users to use polyfills to make the environment look equivalent to newer browsers. For example, React asks users to bring libraries such as <code>es5-shim</code>, <code>es5-sham</code>, <code>console-polyfill</code> and <code>html5shiv</code> if they want IE8 support.</p>
<p>Facebook.com supports IE8, and uses React, so there is a path to using React with IE8. This path is partially documented on the React website. This gives us a perfect opportunity to evaluate the impact of this strategy in the real world. We admire the React team's work in this area: support for IE8 is difficult and triaging and fixing IE8 bugs requires diligent effort.</p>
<p>After reviewing the <a href="https://github.com/facebook/react/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+ie8">IE8-compatibility issues filed on React.js tracker</a>, we believe there are significant user experience costs to this strategy.</p>
<p>We have spent considerable effort on first-class IE8 support in Ember 1.x, and we feel that users who require IE8 support will have a better experience using Ember 1.14 (with the subset of the ecosystem that supports 1.x) than trying to cobble together a solution that works reliably in a version of Ember with second-class, bring-your-own-compatibility support.</p>
<a class="header" href="print.html#unresolved-questions-11" id="unresolved-questions-11"><h1>Unresolved questions</h1></a>
<p>We are relying on the community to help us weigh the above tradeoffs. The more data you can provide about the browser makeup of your customers (especially as it affects revenue), the better we can reason whether now is the time to remove IE8 (and possibly IE9) support.</p>
<p>If you cannot share the information publicly, please email whatever information you consider useful to browserusage@emberjs.com. We will keep it in the strictest of confidence.</p>
<ul>
<li>Start Date: 2016-03-26</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/29">#46</a></li>
</ul>
<a class="header" href="print.html#improved-release-process" id="improved-release-process"><h1>Improved Release Process</h1></a>
<a class="header" href="print.html#summary--motivation" id="summary--motivation"><h2>Summary &amp; Motivation</h2></a>
<p>ember-cli has followed an ad hoc release process throughout its existence which has made it difficult to know exactly when releases would come out, what features would and would not be supported, and the degree to which it would support existing Ember applications. With the proposal for lockstep SemVer there were ideals of guaranteeing compatibility, which we have mostly met, but that resulted in making decisions of delaying an official 2.X release of ember-cli to avoid additional major version bumps.</p>
<p>We propose that we adopt a pattern similar to Ember itself in order to align with the expectations of the Ember community, more-clearly communicate around our release lifecycle, and provide rigor around our support structure. Anything which is not specifically called out as a difference in this document is inferred to be following the patterns specified by Ember itself.</p>
<a class="header" href="print.html#channel-design" id="channel-design"><h2>Channel Design</h2></a>
<p>To begin there will be three separate channels: canary, beta, and release. We intend to investigate an LTS channel after this process has matured.</p>
<ul>
<li><strong>Canary</strong>: represents the latest work in ember-cli, and is synonymous with the <code>HEAD</code> of the <code>master</code> branch and is the least stable of all channels.</li>
<li><strong>Beta</strong>: branched off of master every six weeks, exact commit decided upon manually. Updated and released weekly with commits that are prefixed <code>[BUGFIX beta]</code>. Less stable than <code>release</code> as it is a proving ground. No new features will be added once the branch has been created to allow for existing features to mature. Tags will match Ember's patterns, for example <code>v2.6.0-beta.1</code>. Branch name: <code>beta</code>.</li>
<li><strong>Release</strong>: branched off of Beta every six weeks. Only rarely will this be updated, but possible for security issues and uncaught regressions. Branch name: <code>release</code>.</li>
</ul>
<p>ember-cli will not support daily releases as time-based packaging doesn't make a lot of sense.</p>
<a class="header" href="print.html#new-features" id="new-features"><h2>New Features</h2></a>
<p>New features to ember-cli must be protected by feature flags. Incomplete and WIP features will be available in the Canary channel, but will not be available in the Beta or release channels.</p>
<a class="header" href="print.html#tooling-design" id="tooling-design"><h2>Tooling Design</h2></a>
<p>We must create additional tooling and patterns in order to make this efficient. Since ember-cli successfully installs and works from npm without modification we don't need to bundle and publish an asset for each Canary build. We'll publish tags to npm for <code>beta</code> and <code>release</code> channel releases so that they're not tied to a git remote URL. The <code>latest</code> tag for npm (the default when installing via <code>npm install -g ember-cli</code>) will track our <code>release</code> channel at all times. We will publish tagged releases (i.e. v2.6.0-beta.1) to the npm <code>beta</code> tag which is used via <code>npm install --save-dev ember-cli@beta</code>.</p>
<a class="header" href="print.html#timeline" id="timeline"><h2>Timeline</h2></a>
<p>Since the ember-cli project is presently designed to track Ember development, we'll run our release schedule on a one week delay from Ember itself. This ensures that we're able to incorporate the latest changes from Ember into ember-cli and gives us a week to check for Ember-introduced regressions. As Ember itself becomes an npm module this will become less of a concern and we can diverge on our release schedule as best suits the ember-cli project. We will ship the last beta coincidentally with the newest Ember release.</p>
<a class="header" href="print.html#drawbacks-11" id="drawbacks-11"><h2>Drawbacks</h2></a>
<p>The largest drawback is also a feature: we require more rigor in our release processes. This process presently requires a weekly manual review of new commits to master and their prefixes which then get cherry-picked to the appropriate <code>release</code> and <code>beta</code> branches.</p>
<p>We've also encountered issues with <code>npm</code> in the past which may require investigation into other tools.</p>
<a class="header" href="print.html#effort" id="effort"><h2>Effort</h2></a>
<p>In order to undertake this task, there are multiple workflows which must occur:</p>
<ul>
<li>[ ] Updates to the website and documentation communicating this plan.</li>
<li>[ ] Teaching new patterns to ember-cli contributors, most specifically commit tagging and feature flagging.</li>
<li>[ ] Increased automation of the release process.</li>
<li>[ ] Tooling to support feature flags.</li>
</ul>
<a class="header" href="print.html#references" id="references"><h2>References</h2></a>
<ul>
<li><a href="http://emberjs.com/blog/2013/09/06/new-ember-release-process.html">Ember's Post-1.0 Release Cycle</a></li>
<li><a href="https://github.com/emberjs/rfcs/blob/master/text/0056-improved-release-cycle.md">Ember RFC #56 - Improved Release Cycle</a></li>
<li><a href="http://emberjs.com/blog/2016/02/25/announcing-embers-first-lts.html">Announcing Ember's First LTS Release</a></li>
<li><a href="https://github.com/ember-cli/ember-cli/blob/master/RELEASE.md">ember-cli Release Instructions</a></li>
</ul>
<ul>
<li>Start Date: 2015-04-09</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/46</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/11440</li>
</ul>
<a class="header" href="print.html#summary-12" id="summary-12"><h1>Summary</h1></a>
<p>Fully encapsulate and privatize the <code>Container</code> and <code>Registry</code> classes by
exposing a select subset of public methods on <code>Application</code> and
<code>ApplicationInstance</code>.</p>
<a class="header" href="print.html#motivation-13" id="motivation-13"><h1>Motivation</h1></a>
<p>The <code>Container</code> and <code>Registry</code> classes currently lead a confusing life of
semi-private exclusion within Ember applications. They are undocumented
publicly but not fully private either, as knowledge of their particulars is
required for developing both initializers and unit tests. This situation has
become untenable as the new <code>Registry</code> class has been extracted from
<code>Container</code>, and the complexity of their usage has grown across
<code>Application</code> and <code>ApplicationInstance</code> classes.</p>
<p>We can bring sanity to this situation by continuing the work started at the
<code>Application</code> level to expose methods such as <code>register</code> and <code>inject</code> from the
internally maintained <code>Registry</code>.</p>
<p>Furthermore, once <code>Container</code> and <code>Registry</code> are fully private, their
architecture and documentation can be cleaned up. For instance, a
<code>Container</code> can freely reference its associated <code>Registry</code> as <code>registry</code>
rather than <code>_registry</code>, as it can be assumed that only framework developers
will reference this property.</p>
<a class="header" href="print.html#detailed-design-12" id="detailed-design-12"><h1>Detailed design</h1></a>
<p><code>Application</code> will expose the following methods from its internally maintained
registry:</p>
<ul>
<li><code>register</code></li>
<li><code>inject</code></li>
<li><code>registerOptions</code> - mapped to <code>Registry#options</code></li>
<li><code>registerOptionsForType</code> - mapped to <code>Registry#optionsForType</code></li>
</ul>
<p><code>ApplicationInstance</code> will also expose the the same methods. However, these
methods will be exposed from its own internally maintained registry, which
has the associated <code>Application</code>'s registry configured as a &quot;fall back&quot;. No
direct path will be provided from the <code>ApplicationInstance</code> to the
<code>Application</code>'s registry.</p>
<p><code>ApplicationInstance</code> will also expose the following methods from its
internally maintained container:</p>
<ul>
<li><code>lookup</code></li>
<li><code>lookupFactory</code></li>
</ul>
<p><code>ApplicationInstance</code> will cease exposing <code>container</code>, <code>registry</code>, and
<code>applicationRegistry</code> publicly.</p>
<p><code>Application</code> initializers will receive a single argument to <code>initialize</code>:
<code>application</code>.</p>
<p>Likewise, <code>ApplicationInstance</code> initializers will receive a single argument
to <code>initialize</code>: <code>applicationInstance</code>.</p>
<p><code>Container</code> and <code>Registry</code> will be made fully private and documented as
such. Each <code>Container</code> will freely reference its associated <code>Registry</code> as
<code>registry</code> rather than <code>_registry</code>.</p>
<p><a href="https://github.com/switchfly/ember-test-helpers">ember-test-helpers</a>
will provide an <code>isolatedApplicationInstance</code> method instead of an
<code>isolatedContainer</code> for unit testing. A mechanism will be developed to specify
which initializers should be engaged in the initialization of this instance.
In this way, we can avoid duplication of registration logic, as is currently
done in a most un-DRY manner in the <a href="https://github.com/switchfly/ember-test-helpers/blob/master/lib/ember-test-helpers/isolated-container.js#L56-L79">isolatedContainer</a>.</p>
<a class="header" href="print.html#drawbacks-12" id="drawbacks-12"><h1>Drawbacks</h1></a>
<p>This refactor will require maintaining backwards compatibility and
deprecation warnings until Ember 2.0. This will temporarily increase
internal code complexity and file sizes.</p>
<a class="header" href="print.html#alternatives-12" id="alternatives-12"><h1>Alternatives</h1></a>
<p>The obvious alternative is to make <code>Container</code> and <code>Registry</code> fully public
and documented. An application's registry would be available as a <code>registry</code>
property. An application instance's container would remain available as
<code>container</code>.</p>
<p>We could still pass an <code>Application</code> into application initializers
and an <code>ApplicationInstance</code> into application instance initializers.</p>
<p>If this alternative is taken, I would suggest that <code>Application</code> should
deprecate <code>register</code> and <code>inject</code> in favor of calling the equivalents on its
public <code>registry</code>.</p>
<p>Regardless of which alternative is chosen, we should ensure that the public
aspects of container and registry usage are well documented.</p>
<a class="header" href="print.html#unresolved-questions-12" id="unresolved-questions-12"><h1>Unresolved questions</h1></a>
<ul>
<li>
<p>Are the public methods listed above sufficient or should any others be
exposed?</p>
</li>
<li>
<p>What mechanism should be used to engage initializers in unit and
integration tests? Should test modules simply have an <code>initializers</code> array,
similar to the current <code>needs</code> array?</p>
</li>
<li>
<p>Given the semi-private nature of containers and registries, we may not need
to worry about semver for deprecations. However, we should be good citizens
and properly deprecate as much as possible. Some real world use cases in
initializers will no doubt be a surprise, so we need to tread carefully.</p>
</li>
</ul>
<ul>
<li>Start Date: 2016-04-06</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/50">#50</a></li>
</ul>
<a class="header" href="print.html#summary-13" id="summary-13"><h1>Summary</h1></a>
<p>A number of Ember framework function calls are no-ops in production. Ember CLI should strip these no-op function invocations from production builds by default.</p>
<a class="header" href="print.html#motivation-14" id="motivation-14"><h1>Motivation</h1></a>
<p>Removing code that isn't required in production results in smaller and faster applications.</p>
<a class="header" href="print.html#detailed-design-13" id="detailed-design-13"><h1>Detailed design</h1></a>
<p>The following framework function calls will be removed from ember-cli production builds by default:</p>
<ul>
<li><a href="http://emberjs.com/api/#method_assert"><code>Ember.assert</code></a></li>
<li><a href="http://emberjs.com/api/#method_debug"><code>Ember.debug</code></a></li>
<li><a href="http://emberjs.com/api/#method_deprecate"><code>Ember.deprecate</code></a></li>
<li><a href="http://emberjs.com/api/#method_info"><code>Ember.info</code></a></li>
<li><a href="http://emberjs.com/api/#method_runInDebug"><code>Ember.runInDebug</code></a></li>
<li><a href="http://emberjs.com/api/#method_warn"><code>Ember.warn</code></a></li>
</ul>
<p>The API documentation will be updated where necessary to indicate that these function calls will be stripped from production builds.</p>
<p>A babel plugin will execute the removal of these function calls based on provided configuration. The plugin will affect the code of the current app or addon only and won't affect code in child or grandchild addons. As this change becomes part of the default ember-cli configuration, addons will adopt the code stripping as they upgrade to newer ember-cli versions.</p>
<p>The plugin configuration will define an array of modules or global functions to remove. Here's an example of what this configuration might look like:</p>
<pre><code class="language-js">{
  removals: [
    {
      module: 'ember', //eg. import Em from 'ember';
      paths: [
        'assert', //Em.assert will be removed
        'debug',  //Em.debug will be removed
        'a.b.c'   //Em.a.b.c will be removed
      ]
    }, {
      global: 'Ember',
      paths: [
        'deprecate' //Ember.deprecate will be removed
      ]
    }, {
      paths: [
        'console.log' //console.log will be removed
      ]
    }
  ]
}
</code></pre>
<p>The plugin will support removal of destructured and reassigned invocations of these functions and will support both Babel 5 and 6.</p>
<p>An app or addon can disable the code removal by removing the babel plugin.</p>
<a class="header" href="print.html#how-we-teach-this" id="how-we-teach-this"><h1>How We Teach This</h1></a>
<p>This change doesn't bring any new functionality. Other than updating the Ember API docs, we don't need to make guide or other documentation changes. At the time of releasing, we may want to point out the possible side effects in a release blog post (see the <em>Drawbacks</em> section below).</p>
<p>If we want to expose the configuration options so that application authors can customize the settings, we can include a new section in the Ember CLI docs.</p>
<a class="header" href="print.html#drawbacks-13" id="drawbacks-13"><h1>Drawbacks</h1></a>
<p>This may introduce an unexpected change in production builds as arguments that have side effects will no longer be executed. For example:</p>
<pre><code class="language-js">Ember.assert('Some assertion', someSideEffect());
</code></pre>
<p>Currently, the <code>someSideEffect</code> function will be executed in production. When this RFC lands, it won't.</p>
<a class="header" href="print.html#alternatives-13" id="alternatives-13"><h1>Alternatives</h1></a>
<p>An Ember addon could provide opt-in function stripping for applications that want it. If this RFC isn't deemed a good default for Ember CLI, that option should be explored.</p>
<ul>
<li>Start Date: 2014-05-06</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/50</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-14" id="summary-14"><h1>Summary</h1></a>
<p>The <code>{{action</code> helper should be improved to allow for the creation of
closed over functions that can be passed between components and passed
the action handlers.</p>
<p>See <a href="http://emberjs.jsbin.com/rwjblue/466/edit?html,js,output">this example JSBin from @rwjblue</a>
for a demonstration of some of these ideas.</p>
<a class="header" href="print.html#motivation-15" id="motivation-15"><h1>Motivation</h1></a>
<p>Block params allow data to be passed from one component to a downstream
component, however there is currently no way to pass a callback to a downstream
component.</p>
<a class="header" href="print.html#detailed-design-14" id="detailed-design-14"><h1>Detailed design</h1></a>
<p>First, the existing uses of <code>{{action</code> will be maintained. An action can be attached to an
element by using the helper in element space:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{! submit action will hit immediate parent }}
&lt;button {{action &quot;submit&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>An action can be passed to a component as a string:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button on-click=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.sendAction('on-click');
  }
});
</code></pre>
<p>Or a default action can be passed:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button action=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.sendAction();
  }
});
</code></pre>
<p>In all these cases, <code>submit</code> is called on the parent context relative to the scope <code>action</code> is
attached in. The value <code>&quot;submit&quot;</code> is attached to the component in the last two as
<code>this.attrs.on-click</code> or <code>this.attrs.action</code>, although it is not directly used.</p>
<a class="header" href="print.html#creating-closure-actions" id="creating-closure-actions"><h3>Creating closure actions</h3></a>
<p>Closure actions are created in a template and may be used in all places a string
action name can be used. For example, this current functionality:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;submit&quot; on=&quot;click&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>Would be written using a closure action as:</p>
<pre><code class="language-hbs">&lt;button {{action (action &quot;submit&quot;) on=&quot;click&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>The functionality is exactly the same as the string-based action example.
How does that happen?</p>
<ul>
<li><code>(action &quot;submit&quot;)</code> reads the <code>submit</code> function off the current scope's
<code>actions.submit</code> property.</li>
<li>It then creates a closure to call that function.</li>
<li><code>{{action</code> receives that function as a param. It registers a listener (in
this case on click) and when fired calls the closure function.</li>
</ul>
<p>Consider usage on the calling side. With the current string-based actions:</p>
<pre><code class="language-hbs">{{my-component action=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  click: function(){
    this.sendAction(); // submit action, legacy
    // this.attrs.action is a string
    this.attrs.action; // =&gt; &quot;submit&quot;
  }
});
</code></pre>
<p>With closure actions, the action is available to call directly. The <code>(action</code> helper
wraps the action in the current context and returns a function:</p>
<pre><code class="language-hbs">{{my-component action=(action &quot;submit&quot;)}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  click: function(){
    this.sendAction(); // submit action, legacy
    // this.attrs.action is a function
    this.attrs.action(); // submit action, new style
  }
});
</code></pre>
<p>A more complete example follows, with a controller for context:</p>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    submit: function(){
      // some submission task
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button save=(action 'submit')}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.attrs.save();
    // for backwards compat, you may also this.sendAction('save');
  }
});
</code></pre>
<a class="header" href="print.html#hole-punching-with-a-closure-based-action" id="hole-punching-with-a-closure-based-action"><h3>Hole punching with a closure-based action</h3></a>
<p>The current system of action bubbling falls down quickly when you want to pass a message through multiple
levels of components. A closure based action system helps address this.</p>
<p>Instead of relying on bubbling, a closure action wraps an action from the current context's
<code>actions</code> hash in a function that will call it on that context. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form submit=(action 'submit')}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{my-button on-click=attrs.submit}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-button/template.hbs }}
&lt;button&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.attrs['on-click']();
    // for backwards compat, you may also this.sendAction();
  }
});
</code></pre>
<p>A closure action can also be called by an action handler:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form submit=(action 'submit')}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{my-button on-click=submit}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-button/template.hbs }}
&lt;button {{action on-click}}&gt;&lt;/button&gt;
</code></pre>
<p>Lastly, closure actions allow for yielding an action to a block. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form save=(action 'submit') as |submit reset|}}
  &lt;button {{action submit}}&gt;Save&lt;/button&gt;
  {{! ^ goes to my-form's save attr property, which
        is the submit action on the outer scope }}
  &lt;button {{action reset}}&gt;Reset&lt;/button&gt;
  {{! ^ goes to my-form }}
  &lt;button {{action &quot;cancel&quot;}}&gt;Cancel&lt;/button&gt;
  {{! ^ goes to outer scope }}
{{/my-form}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{yield attrs.save (action 'reset')}}
</code></pre>
<pre><code class="language-js">// app/components/my-form/component.js
export default Ember.Component.extend({
  actions: {
    reset: function(){
      // rollback
    }
  }
});
</code></pre>
<a class="header" href="print.html#currying-arguments-with-a-closure-based-action" id="currying-arguments-with-a-closure-based-action"><h3>Currying arguments with a closure-based action</h3></a>
<p>With string-based actions, an argument can be passed to the called function. For
example:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;save&quot; model}}&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  actions: {
    save: function(model) {
      model.save();
    }
  }
});
</code></pre>
<p>Closure actions allow for another opportunity to curry arguments. Arguments
set by an element action helper simply add to the end of the arguments list:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-component save=(action &quot;save&quot; model)}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-component/template.hbs }}
&lt;button {{action attrs.save prefs}}&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    save: function(model, prefs) {
      model.set('prefs', prefs);
      model.save();
    }
  }
});
</code></pre>
<p>Multiple arguments can be curried or set at any level. If an action is called ala
<code>this.attrs.save(additionalPrefs)</code>, that final argument is added
to the end of the arguments list.</p>
<a class="header" href="print.html#re-targeting-the-scope-of-a-closure-action" id="re-targeting-the-scope-of-a-closure-action"><h3>Re-targeting the scope of a closure action</h3></a>
<p>The <code>target</code> option may be provided to specify what scope the closure is called
with. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-component on-click={{action &quot;save&quot; model target=someComponentInstance}}&gt;&lt;/my-component&gt;
</code></pre>
<p>Much like with the <code>{{action</code> helper, passing both a
target and a bound argument will throw.</p>
<p>The default target for a closure is always the current scope.</p>
<ul>
<li>When routable components land, the current component will be the default target.</li>
<li>If a controller is the current scope, that controller will also be a default target.</li>
<li>A route will <em>never</em> be a closure action target. String actions will continue
to have their current behavior of bubbling to the route.</li>
</ul>
<p>A later proposal will determine how actions on a route are passed to a routable
component.</p>
<a class="header" href="print.html#return-values-of-a-closure-action" id="return-values-of-a-closure-action"><h3>Return values of a closure action</h3></a>
<p>Closure actions return the returned value of their called function. For example:</p>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    submit: function(){
      return 'great success';
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button save=(action 'submit')}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    var result = this.attrs.save();
    // for backwards compat, you may also this.sendAction('save') but
    // in that case you do not have access to the return value.
    result; // =&gt; 'great success'
  }
});
</code></pre>
<a class="header" href="print.html#actionable-object-with-invoke" id="actionable-object-with-invoke"><h3>Actionable object with INVOKE</h3></a>
<p><code>{{mut</code> is a new helper in Ember.js. It is not yet widely used in Ember apps, but its
interaction with the action helper is important to align early on.</p>
<p>Mut objects represent a modifiable value. For example with tag-based components:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-form name={{mut model.name}}&gt;&lt;/my-component&gt;
</code></pre>
<p>This will cause a mutable property to be added to <code>attrs</code>. To update the name,
<code>this.attrs.name.update(newName)</code> can be called. The value can be read (in
JavaScript) as <code>this.attrs.name.value</code>.</p>
<p>Often, a mutable value will be set as the result of an action. Mutable values
can be called actionable. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-form submit={{action (mut model.name)}}&gt;&lt;/my-component&gt;
</code></pre>
<pre><code class="language-js">// app/components/my-form/component.js
export default Ember.Component.extend({
  click() {
    const value = this.get('newValue');
    this.attrs.submit(value);
  }
});
</code></pre>
<p>What is happening here?</p>
<ul>
<li><code>(mut model.name)</code> creates a mutable object for the <code>model.name</code> value.</li>
<li><code>{{action (mut model.name)}}</code> tests the passed object for a property with the
key <code>INVOKE</code> (an internal symbol). This value is a function that updates the mutable value.</li>
<li>Action wraps the calling of the <code>INVOKE</code> property in a function like any
other action, and passes it to the <code>attrs</code>.</li>
</ul>
<p>Thus, when the action is called the argument is passed to <code>INVOKE</code> which uses
it to update the mutable value. This is a simple way to enable the &quot;actions up&quot;
part of component-driven app architecture without ceremony around changing state.</p>
<a class="header" href="print.html#plucking-a-property-from-the-first-argument-with-value" id="plucking-a-property-from-the-first-argument-with-value"><h3>Plucking a property from the first argument with value</h3></a>
<p>A component (or when Ember supports this better, an element) may emit an event
object and pass it to an action. In this case the value will need to be read off
the event before it can be passed to the action function. For example:</p>
<pre><code class="language-hbs">{{input input=(action 'setName')}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  actions: {
    setName(event) {
      this.get('model').set('name', event.target.value);
    }
  }
});
</code></pre>
<p>The action serves only to read the value off of the event. Here the <code>value</code>
option can be used as sugar to accomplish the same task:</p>
<pre><code class="language-hbs">{{input input=(action (mut model.name) value=&quot;target.value&quot;)}}
</code></pre>
<p>The <code>value</code> path is read off of whatever the first argument to the actions is.</p>
<ul>
<li><code>(mut model.name)</code> becomes a function, our action</li>
<li>When the <code>input</code> event fires, the function is called with the event as the
first argument.</li>
<li>The first argument is re-written to the value of <code>event.target.value</code></li>
<li>The function wrapping the <code>mut</code> is set</li>
<li>The <code>mut</code> is updated.</li>
</ul>
<p>This option is designed to align with future plans for <code>on-some-event</code> handlers
for html elements.</p>
<a class="header" href="print.html#drawbacks-14" id="drawbacks-14"><h1>Drawbacks</h1></a>
<p>Currently <code>{{action</code> is only used in an element space:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;booyah&quot;}}&gt;Fire&lt;/button&gt;
</code></pre>
<p>The closure usage is a new, perhaps <code>action</code> is not the right word. However the two
behaviors are pretty similar in their conceptual behavior.</p>
<ul>
<li><code>{{action</code> in element space attaches an event listener that fires a bubbling
action.</li>
<li><code>(action</code> closes over an action from the current scope so it can be attached
via <code>{{action</code> or passed around and called later.</li>
</ul>
<p>This confusion should go away as we move to an <code>on-click</code> event listener pattern,
ala <code>&lt;button on-click={{someClosureAction}}&gt;</code>.</p>
<p>Additionally, there may be developers who still have <code>{{action someActionName}}</code> instead
of the quoted version. This is long deprecated, but these apps may see some
unexpected behavior.</p>
<p>Also additionally, some emergent behaviors exist that may not be desired as real APIs. For example,
an action being a function means it can be passed directly to event handlers:</p>
<pre><code class="language-hbs">{{my-component mouseEnter=(action 'didEnter')}}
</code></pre>
<p>The actual API we plan for 2.0 (ideally) is:</p>
<pre><code class="language-hbs">{{my-component on-mouse-enter=(action 'didEnter')}}
</code></pre>
<p>These behaviors should not be documented, and we should make clear that they rely on behavior that
will be deprecated. A mitigating move is to <em>not</em> proxy actions through to
<code>get</code> on a component, and only allow them to be accessed on <code>attrs</code>.</p>
<p>Lastly, default actions may look a bit confusing:</p>
<pre><code class="language-hbs">{{my-button action=(action 'action')}}
{{! ^ this is valid }}
</code></pre>
<p>But the quoted string syntax is not being removed.</p>
<a class="header" href="print.html#alternatives-14" id="alternatives-14"><h1>Alternatives</h1></a>
<p>There is maybe a thing called <code>ref</code> that solves this same problem. There has also
been discussion of accessing properties on <code>outlet</code> across all child components
and their layouts, which would allow easy targetting of the top level component.</p>
<a class="header" href="print.html#unresolved-questions-13" id="unresolved-questions-13"><h1>Unresolved questions</h1></a>
<p>Interaction with <code>ref</code> or <code>outlet.</code> if any..</p>
<ul>
<li>Start Date: 2015-05-17</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/53</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/11278</li>
</ul>
<a class="header" href="print.html#summary-15" id="summary-15"><h1>Summary</h1></a>
<p>Ember.js 1.13 will introduce a new API for helpers. Helpers will come in two
flavors:</p>
<p><strong>Helpers</strong> are a class-based way to define HTMLBars subexpressions. Helpers:</p>
<ul>
<li>Have a single return value.</li>
<li>Must have a dash in their name.</li>
<li>Cannot be used as a block (<code>{{#some-helper}}{{/some-helper}}</code>).</li>
<li>Can store and read state.</li>
<li>Have lifecycle hooks analogous to components where appropriate. For
example, a helper may call <code>recompute</code> at any time to generate a new
value (this is akin to <code>rerender</code>).</li>
<li>Are a superset of shorthand helpers, the function-based syntax described
below. They can do more, but in many cases a shorthand helper is appropriate.</li>
</ul>
<p><strong>Shorthand helpers</strong> are a function-based way to define HTMLBars
subexpressions. Helpers written this way:</p>
<ul>
<li>Have all the limitations of regular helpers.</li>
<li>Have no instance associated with them, cannot store or read state.</li>
<li>Have no lifecycle hooks. The function is simply re-computed when any input
changes.</li>
</ul>
<p>These improved helpers fill a gap in Ember's current template APIs:</p>
<table><thead><tr><th>                   </th><th> has positional params </th><th> has layout (shadow DOM) </th><th> can yield template </th><th> has lifecycle, instance </th><th> can control rerender </th></tr></thead><tbody>
<tr><td> components        </td><td> Yes                   </td><td> Yes                     </td><td> Yes                </td><td> Yes                     </td><td> Yes                  </td></tr>
<tr><td> helpers           </td><td> Yes                   </td><td> No                      </td><td> No                 </td><td> Yes                     </td><td> Yes                  </td></tr>
<tr><td> shorthand helpers </td><td> Yes                   </td><td> No                      </td><td> No                 </td><td> No                      </td><td> No                   </td></tr>
</tbody></table>
<p>An example helper:</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.extend({
  nameBuilder: Ember.inject.service(),
  compute(params) {
    const builder = this.get('nameBuilder');
    return builder.fullName(params[0], params[1]);
  }
});
</code></pre>
<p>An example shorthand helper:</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.helper(function(params, hash) {
  let fullName = params.join(' ');
  if (hash.honorific) {
    fullName = `${hash.honorific} ${fullName}`
  }
  return fullName;
});
</code></pre>
<p>Helpers can be used anywhere an HTMLBars subexpression is valid:</p>
<pre><code class="language-hbs">{{full-name 'Bigtime' 'Beagle'}}
{{input value=(full-name 'Gyro' 'Gearloose') readonly=true}}
{{#if (eq (full-name 'Webbigail' 'Vanderquack') selectedFullName))}}
  You have chosen wisely.
{{/if}}
</code></pre>
<a class="header" href="print.html#motivation-16" id="motivation-16"><h1>Motivation</h1></a>
<p>Ember.js 1.13 make a private API change that removed the ability to access
application containers. <code>Ember.HTMLBars._registerHelper</code> was previously passed
the <code>env</code> object, and this was removed as it is an internal implementation
detail.</p>
<p>Ember's helper API has not kept pace with improvements possible
after the introduction of HTMLBars. This has resulted in the community using
a variety of private APIs, many of which leak information about the outer
context of a helpers invocation as well as the render layer implementation.</p>
<p>The current public API is:</p>
<ul>
<li><a href="http://emberjs.com/api/classes/Ember.Handlebars.html#method_makeBoundHelper">Ember.Handlebars.makeBoundHelper</a></li>
</ul>
<p>This API is sorely lacking in functionality required by addon authors.</p>
<ul>
<li>Has no access to other parts of the app, like services</li>
<li>Leaks a private API for dealing with blocks</li>
<li>Results in less efficient helpers due to the Handlebars compatibility layer</li>
<li>Has poor support for hash arguments</li>
</ul>
<p>Additionally it remains difficult to write a helper that recomputes due to
something besides the change of its input.</p>
<p>Specifically, this RFC addresses many of the concerns in
<a href="https://github.com/emberjs/ember.js/issues/11080">emberjs/ember.js#11080</a>.
Libraries such as <a href="https://github.com/yahoo/ember-intl">yahoo/ember-intl</a>,
<a href="https://github.com/dockyard/ember-cli-i18n">dockyard/ember-cli-i18n</a>, and
<a href="https://github.com/minutebase/ember-can">minutebase/ember-can</a> will be
provided a viable public API to couple to.</p>
<a class="header" href="print.html#detailed-design-15" id="detailed-design-15"><h1>Detailed design</h1></a>
<p>Helpers must have a dash in their name. In an Ember-CLI app, they can be named
according to the <code>app/helpers/full-name.js</code> convention (<code>app/full-name/helper.js</code>
in pods mode). For a globals app, naming a helper <code>App.FullNameHelper</code> is
sufficient.</p>
<a class="header" href="print.html#definition-and-lifecycle" id="definition-and-lifecycle"><h3>Definition and lifecycle</h3></a>
<p>A helper is defined as a class inheriting from <code>Ember.Helper</code>. For
example:</p>
<pre><code class="language-js">// app/helpers/hello-world.js
import Ember from &quot;ember&quot;;

// Usage: {{hello-world}}
export default Ember.Helper.extend({
  compute() {
    return &quot;Hello Helper World&quot;;
  }
});
</code></pre>
<p>Upon initial render:</p>
<ul>
<li>The helper instance is created.</li>
<li>The <code>compute</code> method is called. The return value is outputted where the
helper is used. For example in <code>&lt;div class={{some-helper}}&gt;&lt;/div&gt;</code> the return
value is set to the class.</li>
</ul>
<p>The <code>compute</code> function is always called with <code>params</code> (the bare, ordered
arguments) and <code>hash</code> (the named arguments). For example:</p>
<pre><code class="language-js">// app/helpers/greet-someone.js
import Ember from &quot;ember&quot;;

// Usage: {{greet-someone 'bob' greeting='say hello'}}
export default Ember.Helper.extend({
  compute(params, hash) {
    return `Hello ${params[0]}, nice to ${hash.greeting}`;
  }
});
</code></pre>
<p>Which functions the same as this shorthand:</p>
<pre><code class="language-js">// app/helpers/greet-someone.js
import Ember from &quot;ember&quot;;

// Usage: {{greet-someone 'bob' greeting='say hello'}}
export default Ember.Helper.helper(function(params, hash) {
  return `Hello ${params[0]}, nice to ${hash.greeting}`;
});
</code></pre>
<p>When the <code>params</code> or <code>hash</code> contents change, the <code>compute</code> method is called
again. The instance of the helper is preserved across rerenders of the parent.
A shorthand helper, having no instance, is called every time a bound
argument changes.</p>
<p>The <code>init</code> and <code>destroy</code> methods can be subclassed for setup and teardown.</p>
<a class="header" href="print.html#consuming-a-helper" id="consuming-a-helper"><h3>Consuming a helper</h3></a>
<p>Helpers can be used anywhere an HTMLBars subexpression can be
used. For example:</p>
<pre><code class="language-hbs">{{#if (can-access 'admin')}}
  {{link-to 'login'}}
{{/if}}
{{#if (eq (can-access 'admin') false)}}
  No login for you
{{/if}}
&lt;my-login-button isAdmin={{can-access 'admin'}} /&gt;
Can access? {{can-access 'admin'}}
</code></pre>
<p>Passing a helper to a <code>{{</code>- invoked component skips the auto-<code>mut</code> behavior:</p>
<pre><code class="language-hbs">{{my-login-button isAdmin=(can-access 'admin')}}
</code></pre>
<p>Let's step through exactly what happens when using an helper like this:</p>
<pre><code class="language-hbs">&lt;my-login-button isAdmin={{can-access 'admin'}} /&gt;
</code></pre>
<p>Upon initial render:</p>
<ul>
<li>The helper <code>can-access</code> is looked up on the container</li>
<li>The helper is identified as a full helper, not a shorthand helper function</li>
<li>The helper is initialized (<code>init</code> is called)</li>
<li>The <code>compute</code> function is called on the helper.</li>
<li>The return value from <code>compute</code> is passed as an <code>attr</code> to <code>my-login-button</code>.</li>
<li>The helper instance remains in memory.</li>
</ul>
<p>If the parent scope is rerendered:</p>
<ul>
<li>The <code>compute</code> function is called again.</li>
<li>The return value from <code>compute</code> is passed as an <code>attr</code> to <code>my-login-button</code>.</li>
</ul>
<p>Upon teardown:</p>
<ul>
<li>The helper is destroyed, calling the <code>destroy</code> method.</li>
</ul>
<a class="header" href="print.html#returning-a-value" id="returning-a-value"><h3>Returning a value</h3></a>
<p>The return value of helper is passed through to where their subexpression
is called. For example, given a helper (this one a shorthand helper):</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.helper(function fullName(params, hash) {
  return params.join(' ');
}
</code></pre>
<p>The following are effectively the same:</p>
<pre><code class="language-hbs">&lt;div data-name={{full-name &quot;Fenton&quot; &quot;Crackshell&quot;}}&gt;&lt;/div&gt;
&lt;div data-name={{&quot;Fenton Crackshell&quot;}}&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-hbs">{{my-component name=(full-name &quot;Magica&quot; &quot;De Spell&quot;)}}
{{my-component name=&quot;Magica De Spell&quot;}}
</code></pre>
<pre><code class="language-hbs">&lt;p&gt;{{full-name &quot;Bentina&quot; &quot;Beakley&quot;}}&lt;/p&gt;
&lt;p&gt;{{&quot;Bentina Beakley&quot;}}&lt;/p&gt;
</code></pre>
<p>An exclusion to this pattern is the following form:</p>
<pre><code class="language-hbs">&lt;div {{full-name &quot;Webbigail&quot; &quot;Vanderquack&quot;}}&gt;&lt;/div&gt;
</code></pre>
<p>This is a legacy form of mustache usage. Helpers will throw an exception when
used in this manner.</p>
<a class="header" href="print.html#consuming-services-and-recompute" id="consuming-services-and-recompute"><h3>Consuming services and recompute</h3></a>
<p>Helpers are a valid target for service injection. For example:</p>
<pre><code class="language-js">// app/helpers/current-user-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.extend({
  // Same API as components:
  session: Ember.inject.service(),
  compute() {
    return this.get('session.currentUser.name');
  }
});
</code></pre>
<p>However consuming a property from a service does not bind the data being
displayed to that property. After <code>{{current-user-name}}</code> has been computed
and rendered, it will never be invalidated.</p>
<p>For this reason, helpers are granted some control over their
computation lifecycle. A helper will recompute when:</p>
<ul>
<li>A value passed via the template changes (<code>params</code> or <code>hash</code>)</li>
<li>The <code>recompute</code> method is called</li>
</ul>
<p>For example, this helper checks if the current use has access to a
resource type:</p>
<pre><code class="language-js">// app/helpers/can-access.js
import Ember from &quot;ember&quot;;

// Usage {{if (can-access 'admin') 'Welcome, boss' 'Heck no!'}}
export default Ember.Helper.extend({
  session: Ember.inject.service(),
  onCurrentUserChange: Ember.observes('session.currentUser', function() {
    this.recompute();
  }),
  compute(params) {
    const currentUser = this.get('session.currentUser');
    return currentUser.can(params[0]);
  }
});
</code></pre>
<a class="header" href="print.html#drawbacks-15" id="drawbacks-15"><h1>Drawbacks</h1></a>
<p>Helpers may superficially appear similar to components, but in
practice they have none of the special behavior of components such as managing
DOM. The intent of this RFC is that full class-based helpers remain very close
to the spirit of a pure function (as in the shorthand). However, despite this
intent they are a new concept for the framework.</p>
<a class="header" href="print.html#alternatives-15" id="alternatives-15"><h1>Alternatives</h1></a>
<p>A <a href="https://github.com/emberjs/rfcs/pull/52">previous RFC</a> explored creating a new class called Expressions, which would have
more closely modeled the API of components (using positional params, attrs).
After discussion and consideration it was clear that a third kind of template
API would be very challenging to document and teach well.</p>
<a class="header" href="print.html#unresolved-questions-14" id="unresolved-questions-14"><h1>Unresolved questions</h1></a>
<p>Perhaps there should be hooks in place for the lifecycle, instead of relying on
<code>init</code> and <code>destroy</code>.</p>
<ul>
<li>Start Date: 2016-06-14</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/55">#55</a></li>
</ul>
<a class="header" href="print.html#summary-16" id="summary-16"><h1>Summary</h1></a>
<p>This RFC proposes extending the <code>app.import</code> API to consume anonymous AMD modules. It accompanies <a href="https://github.com/ember-cli/ember-cli/pull/5976">ember-cli PR 5976</a>.</p>
<a class="header" href="print.html#motivation-17" id="motivation-17"><h1>Motivation</h1></a>
<p>AMD modules come in two flavors: named and anonymous. <em>Anonymous AMD</em> is the more portable distribution format, but it typically requires preprocessing into <em>named AMD</em> before it can be included into an application.</p>
<pre><code>/* Anonymous AMD Examples */

// direct value
define({ color: 'black' });

// function returning value
define(function() { return { color: 'black' }; });

// function returning value, with declared dependencies
define([&quot;jquery&quot;, &quot;moment&quot;], function(jQuery, moment) {
  return {
    injectTime: function() {
      jQuery('#time-box').html(moment().format('HH:MM'));
    }
  }
});

/* Named AMD Examples */

// direct value
define('my-config', { color: 'black' });

// function returning value
define('my-config', function() { return { color: 'black' }; });

// function returning value, with declared dependencies
define('time-utils', [&quot;jquery&quot;, &quot;moment&quot;], function(jQuery, moment) {
  return {
    injectTime: function() {
      jQuery('#time-box').html(moment().format('HH:MM'));
    }
  }
});
</code></pre>
<p>Today, ember-cli users can add arbitrary third-party <em>named AMD</em> modules into their application via:</p>
<pre><code>app.import('/path/to/module.js');
</code></pre>
<p>But this does not support <em>anonymous AMD</em> modules, which is annoying because <em>anonymous AMD</em> is the better format for library distribution and is widely used.</p>
<a class="header" href="print.html#detailed-design-16" id="detailed-design-16"><h1>Detailed design</h1></a>
<p>In order to de-anonymize AMD, it's necessary to choose a name for the module for use within a given application. So I propose extending the:</p>
<pre><code>app.import('/path/to/module.js');
</code></pre>
<p>API with an additional argument:</p>
<pre><code>app.import('/path/to/module.js', {
  using: [
    { transformation: 'amd', as: 'some-dep' }
  ]
});
</code></pre>
<p><code>using</code> provides a list of transformations. Each transformation is identified by its <code>transformation</code> property. Any other properties are treated as arguments to the transformation implementation -- they are opaque to ember-cli. Transformations will run in the given order.</p>
<p>In this particular case, the <code>amd</code> transformation will run and receive the argument <code>{as: 'some-dep'}</code>.</p>
<p>The exactly meaning of the <code>amd</code> transformation is: within this Javascript file, any call(s) to the global <code>define()</code> function will be intercepted and the given module name (<code>some-dep</code> in the above example) will be prepended to the argument list.</p>
<p><a href="https://github.com/ember-cli/ember-cli/pull/5976">A complete implementation is available here</a>. (As of this edit it lags behind updates to this RFC.)</p>
<a class="header" href="print.html#learning" id="learning"><h1>Learning</h1></a>
<p>An appropriate place to document this feature is <a href="https://ember-cli.com/user-guide/#standard-amd-asset">here</a>. That existing documentation is silent on the distinction between named and anonymous AMD, which probably trips people up.</p>
<a class="header" href="print.html#drawbacks-16" id="drawbacks-16"><h1>Drawbacks</h1></a>
<p>I am not attempting to specify static error detection, mostly because doing that well would require fully parsing and understanding the imported module, which is likely to be more expensive and fragile.</p>
<p>Examples of static errors that would theoretically be nice to detect would be the presence of a <em>named AMD</em> module in the file, the lack of any AMD module in the file, or the present of multiple <em>anonymous AMD</em> modules in the file.</p>
<p>The current implementation causes any sourcemap information inside the imported file to be discarded (you don't get an invalid sourcemap, but you lose detail).</p>
<p>I have not specified a pluggable way to add additional transformations. My intent is to reserve space in our public API so that future extraction and pluggability is fully backward compatible.</p>
<a class="header" href="print.html#alternatives-16" id="alternatives-16"><h1>Alternatives</h1></a>
<p>Many libraries fall back to global variables if they cannot detect a valid AMD loader. I suspect this is the most common alternate pattern that's in use in the community.</p>
<p>Some applications include their own manually written shims in <code>vendor</code> or elsewhere.</p>
<a class="header" href="print.html#unresolved-questions-15" id="unresolved-questions-15"><h1>Unresolved questions</h1></a>
<p>We should confirm that my implementation performs well in apps with very large dependency directories.</p>
<ul>
<li>Start Date: 2015-10-02</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/56</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#refining-the-release-process" id="refining-the-release-process"><h1>Refining the Release Process</h1></a>
<p>Ember balances a desire for overall stability with a desire for continued improvements using a two-pronged approach:</p>
<ul>
<li>General adherence to Semantic Versioning, which means that we don't
make breaking changes to public, documented APIs except when the
major version changes.</li>
<li>A rapid release cycle that allows us to ship additive changes to the
framework on a regular, digestible basis.</li>
</ul>
<p>Since Ember 1.0, we have refined this approach:</p>
<ul>
<li>All new public APIs are added using feature flags onto the master
branch. Feature flagged features are not included in beta or release
builds until they are &quot;Go&quot;ed by the core team.</li>
<li>We avoid breaking heavily used but private APIs in minor versions.</li>
<li>When we feel we must break a private API that is heavily used, we
use a two-step deprecation approach: deprecate the private API in
one release and remove it in a subsequent release, once apps and
add-ons have had an opportunity to upgrade.</li>
<li>When we plan to make breaking changes in a future major release,
we first deprecate the changes in a previous minor release.</li>
<li>We never deprecate features until there is an already-landed
transition path to a new approach whose feature flag has already
been &quot;Go&quot;ed.</li>
</ul>
<p>And finally:</p>
<ul>
<li>A major release does not introduce any new breaking changes that
were not previously deprecated. Major versions simply remove
deprecated features that already landed.</li>
</ul>
<p>Ember 2.0 is the first major release cycle where we have followed these refinements; this document is an attempt to outline some additional refinements that we might adopt going forward.</p>
<a class="header" href="print.html#benefits-of-the-1x-model" id="benefits-of-the-1x-model"><h2>Benefits of the 1.x Model</h2></a>
<ul>
<li>New features are added predictably, and it's relatively easy to
follow the list of new APIs that are under development, and where
they are in the process.</li>
<li>There is little pressure for contributors to land a feature
prematurely, because missing a release deadline isn't
catastrophic–there will be another train six weeks hence.</li>
<li>We have a lot of very good automation tools that keep the trains
running–commits can be (mostly) automatically backported to the
current beta or release version.</li>
<li>Upgrading Ember itself from version to version is typically a quick
process, except when private APIs are in use. We aim for upgrades to
be possible to slot into existing product sprints, and the nature of
the process means that we tend to hit this goal for most users.</li>
<li>Upgrading Ember across a number of versions is typically pretty
straightforward, at least in theory.</li>
</ul>
<p>In total, this process provides a way for us to clearly message medium-term changes in a way that helps you make the changes predictably and as mechanically as possible.</p>
<p>The process of getting from <em>here</em> to <em>there</em> is a series of incremental releases with deprecations, which gives you a trail of breadcrumbs to follow as things change.</p>
<a class="header" href="print.html#problems-with-the-1x-model" id="problems-with-the-1x-model"><h2>Problems with the 1.x Model</h2></a>
<p>While the approach we're using has provided a lot of benefits, there are a number of areas that could still use improvement:</p>
<ul>
<li>While it is in theory possible to upgrade only once every few
releases, there is no guidance about exactly how to do that, and
little clarity about how many releases we plan to support with
security fixes. (Because of the two-step deprecations of heavily
used  private APIs, it is in practice important to go through each
intermediate release to clear deprecation warnings before
proceeding.)</li>
<li>While SemVer guarantees apply to public APIs, many addons are forced
to use private APIs as part of experiments. These experiments are a
crucial part of the evolution of the Ember ecosystem, and the Ember
1.x series has had a fair bit of churn in these APIs.</li>
<li>While the SemVer guarantees apply to Ember proper, they do not apply
to parts of the blessed experience that have not yet reached 1.0.</li>
<li>While the SemVer guarantees promise that your code will continue
working, they do not address changes to idiomatic Ember usage, which
can change over time. In practice, this means that there can be
churn in the experience of using Ember without actual breakages.</li>
<li>While deprecations technically don't force you to change anything,
in practice clearing deprecations is a part of the upgrade process.
A constant stream of deprecations, like in the lead-up to Ember 2.0,
can feel almost as bad as breaking changes.</li>
<li>In the lead-up to Ember 2.0, a desire to remove as much cruft as
quickly as possible led to a need to land new features with much
more urgency than usual.</li>
</ul>
<p>In total, these problems introduce churn in the experience of using Ember. In practice, things like moving to ES6 modules, moving to Ember CLI, and the changes in Ember Data have made the experience of &quot;keeping up&quot; more frenetic than we would have liked.</p>
<p>Because Ember releases a new version every six-weeks, it's easy to associate the overall churn with the rapid pace of releases.</p>
<a class="header" href="print.html#non-goals-of-the-improvements" id="non-goals-of-the-improvements"><h2>Non-Goals of the Improvements</h2></a>
<p>The release process does not attempt to change the overall pace of change, but rather to make changes more predictable, easy to track, and easy to upgrade to.</p>
<p>The six-week cycle can incidentally affect the pace of change, because it means that large changes usually need to be broken up into pieces that can land a bit at a time. However, in practice this speeds up ecosystem-wide adoption of the entire feature, because people do not find themselves stuck behind a big-bang change that they can't schedule the time to upgrade to.</p>
<p>A recent survey of the Ember ecosystem, which had close to 1,000 respondents, showed that the vast majority of Ember users are using one of the past three versions of Ember.</p>
<a class="header" href="print.html#proposal-lts-releases" id="proposal-lts-releases"><h2>Proposal: LTS Releases</h2></a>
<p>In theory, it's possible to upgrade every few releases, instead of every release. This has a few drawbacks:</p>
<ul>
<li>Because of the two-step deprecation process for heavily-used
private APIs that we want to remove, it is in practice necessary
to go through all intermediate releases in order to catch possible
deprecations.</li>
<li>We currently don't have any official policy about which exact
releases we backport security patches to, other than a promise
that we will always backport to the previous released version.</li>
<li>Since different people upgrade at different rates, it's hard for
add-ons and other parts of the Ember ecosystem that are not
bound by the same SemVer guarantees to know which versions to
continue to support.</li>
</ul>
<p><strong>I propose that every 4 releases is considered a &quot;Long-Term-Support (LTS) release&quot; . With the six-week cycle, that means every 24 weeks, or roughly twice per year.</strong></p>
<p>This means:</p>
<ul>
<li>We will only remove heavily used private APIs if they were
deprecated in a previous LTS release. This means that
if a feature is deprecated in 2.3, the first LTS release that
the deprecation will appear in is 2.4, and it can therefore be
removed in 2.5.</li>
<li>We will provide release notes for each LTS release that
roll up the changes for the releases it includes, including new
deprecations and new features.</li>
<li>We will use the LTS releases to provide better big-picture
messaging on the goals of any deprecations and changes to
idiomatic Ember.</li>
<li>Security fixes will always be backported to the most recent
LTS release.</li>
<li>We will encourage the Ember ecosystem to maintain support for
the LTS releases, and lead by example with our own
projects that have not yet reached SemVer stability. Ideally, this
will give more of a voice to people who are upgrading less
frequently.</li>
</ul>
<p>This means that people who want to stay on the latest and greatest can continue to upgrade every six weeks (with the same SemVer guarantees we've come to expect), and people who want to upgrade less frequently can do so.</p>
<p>In practice, since these releases still abide by SemVer, upgrading from LTS release to LTS release should not be significantly more work than upgrading along the six-week release cycle.</p>
<p>Upgrading less frequently will mean, of course, that you would need to wait to take advantage of new features, and experience less gradual changes to idioms. It will also mean that every upgrade will come with a bigger bundle of deprecations to clear.</p>
<blockquote>
<p>It is important for us to keep an eye on the situation to see whether less frequent updates result in people getting left behind.</p>
</blockquote>
<a class="header" href="print.html#proposal-svelte-releases-and-major-releases" id="proposal-svelte-releases-and-major-releases"><h2>Proposal: Svelte Releases and Major Releases</h2></a>
<p>Another problem worth addressing is that, as Ember gradually deprecates old idioms to make way for new ones, SemVer guarantees require that we continue shipping deprecated features until the next major release.</p>
<p>This has two related problems:</p>
<ol>
<li>Ember users who are not using deprecated features need to continue
shipping deprecated code, which increases both code bloat and
an opportunity to accidentally slip back into older idioms.</li>
<li>Ember itself needs to continue maintaining support for
deprecated features in its internals, which, over time, results
in cruft that impacts our ability to improve Ember.</li>
</ol>
<p>However, we also need to be cognizant of the fact that changes to Ember idioms take time to be reflected in online materials, so it's important for snippets copy-and-pasted from tutorials to continue to produce deprecation notices for some time.</p>
<p>In general, this is the question of how to &quot;garbage collect&quot; cruft in the framework gradually and with minimal impact.</p>
<p>Leading up to the 2.0 release, we thought we would address this issue with periodic &quot;cruft removal&quot; major releases. Every so often, we would issue a major release with the primary purpose of clearing out accumulated cruft. Minor releases could create deprecations, but not purge their associated code.</p>
<p>Unfortunately, because of the fact that <strong>Ember does not generally deprecate features without a clear transition to something else</strong>, this meant that the 2.0 release became a critical release for adding new features as well. In the run-up to 2.0, we felt a higher degree of urgency to add new features in the programming model to replace ones we expected to want to remove early in the 2.x series.</p>
<p>The goal of the train release model is to eliminate big-bang releases and the attendant stress on releasing particular features by a given date, and the 2.0 release has been far too disruptive to that goal.</p>
<p>In the 2.x cycle, I propose a few enhancements:</p>
<ol>
<li>Ember itself will more clearly mark deprecated features in a
similar way that it marks new features, including with the
release it was deprecated in.</li>
<li>Ember CLI will support &quot;svelte builds&quot;, which strip out
deprecated features.</li>
<li>In development mode, Ember CLI will convert deprecated features
into errors, to ensure that people running svelte builds can still
get clear messages when using code that was designed for earlier
builds, including addons.</li>
<li>We will still use major releases to remove built up cruft,
especially deeply intertwined cruft, but the svelte releases
should take the pressure off of the major release timeline.</li>
</ol>
<p><strong>The 1.x release cycle helped us establish an orderly process for adding features; this proposal establishes a more orderly process for removing them.</strong></p>
<a class="header" href="print.html#proposal-plugin-apis" id="proposal-plugin-apis"><h2>Proposal: Plugin APIs</h2></a>
<p>Since the release of Ember 1.0, we have worked on refining the public APIs while maintaining stability. However, those public APIs do not cover all possible use-cases, and add-ons have cropped up to fill the gaps.</p>
<p>Unfortunately, this has placed a heavy compatibility burden on add-on authors who want to maintain stability in their public APIs even as versions of Ember have changed the private APIs they rely on.</p>
<p>In practice, the costs of the six-week release cycle weigh most heavily on add-on authors, who are often forced into using private APIs, but still want to keep their add-ons working with every release.</p>
<p>The canary and beta cycles help to ensure that popular add-ons work by the time the release version comes out, but only because add-on authors keep a close eye on the beta releases and absorb the churn on behalf of their users.</p>
<p><strong>I propose that as of Ember 2.0, any use of a private API in a plugin is considered a bug in Ember to be fixed.</strong></p>
<p>That doesn't mean that add-on authors should never use private APIs: to the contrary, use of private APIs when no other choice is available helps us discover what APIs are missing.</p>
<p>But a major goal of the 2.x series of Ember should be to identify ways to extend the stability promises that Ember offers to application authors to add-on authors.</p>
<ul>
<li>Start Date: 2015-05-20</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/57</li>
<li>Ember Issue: https://github.com/emberjs/data/pull/3303</li>
</ul>
<a class="header" href="print.html#summary-17" id="summary-17"><h1>Summary</h1></a>
<p>This RFC adds a unified way to perform meta-operations on records, has-many relationships and belongs-to relationships:</p>
<ul>
<li>get the current local data synchronously without triggering a fetch or producing a promise</li>
<li>notify the store that a fetch for a given record has begun, and provide a promise for its result</li>
<li>similarly, notify a record that a fetch for a given relationship has begun, and provide a promise for its result</li>
<li>retrieve server-provided metadata about a record or relationship</li>
</ul>
<a class="header" href="print.html#motivation-18" id="motivation-18"><h1>Motivation</h1></a>
<p>When we initially designed the Ember Data API for relationships, we focused on consumption and mutation of the relationship data. For example, you can retrieve the value of a <code>belongsTo</code> relationship via <code>get('post')</code>, or adding new records to a has-many relationship via <code>get('comments').pushObject(newComment)</code>.</p>
<p>The top-level reading operations are designed to be <a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">zalgo</a>-proof: regardless of whether or not the record or relationship has been loaded already, you get back a promise for the result. Behind the scenes, this will trigger a fetch if needed, or simply return the current value if it has already been fetched. From a programming model perspective, this simplifies your code because you can handle locally-available data and remotely-available data in a single code path.</p>
<p>However, in sophisticated applications, there is often a need to refer to a record without triggering side effects.</p>
<p>For example, you may want to initiate the fetch for a record or relationship yourself, and provide Ember Data with a promise representing the result of that fetch. That use-case is supported by the <code>store.push</code> API, but it has a few problems:</p>
<ul>
<li>The <code>store.push</code> API supports pushing data once the fetch has completed, but no way of telling
Ember Data that a fetch has begun. As a result, any calls to <code>store.find</code> in the interim will
trigger unnecessary fetches.</li>
<li>The <code>store.push</code> API works only for top-level records with already-known types and IDs. It does
not support any way of &quot;feeding&quot; the data for a relationship to Ember Data.</li>
</ul>
<p>In sum, this makes it difficult to front-load work (especially asynchronous work). Instead, Ember Data is currently optimized for reacting to requests from the application layer, which is sometimes a very awkward way of structuring your code.</p>
<p>Second, Ember Data was originally designed with APIs that refer to data and operations on data. Over time, we have come to realize that people quite often need to look at metadata about records or relationships, as well as perform meta-operations on them.</p>
<p>Some examples:</p>
<ul>
<li>getting the expected count of a has-many relationship before it has been fetched</li>
<li>learning whether a relationship is already loaded or not</li>
<li>examining server-sent metadata</li>
<li>working with pages of records in a has-many relationship, especially when pages are loaded asynchronously (&quot;pagination&quot;)</li>
</ul>
<p>Third, because has-many relationships are represented as a <code>RecordArray</code>, we have been able to kludge around some of these issues by adding meta-operations to the has-many relationship itself. In contrast, belongs-to relationships have remained anemic. For example, there is no way to trigger a reload of a belongs-to relationship, whereas has-many relationships can be reloaded by calling <code>.reload()</code> on the <code>RecordArray</code>.</p>
<a class="header" href="print.html#detailed-design-17" id="detailed-design-17"><h1>Detailed design</h1></a>
<p>This RFC proposes the addition of three new <strong>public</strong> APIs:</p>
<ul>
<li><code>RecordReference</code></li>
<li><code>HasManyReference</code></li>
<li><code>BelongsToReference</code></li>
</ul>
<a class="header" href="print.html#getting-references" id="getting-references"><h2>Getting References</h2></a>
<ul>
<li><code>store.getReference(type, id)</code></li>
<li><code>record.getReference(name)</code></li>
</ul>
<a class="header" href="print.html#references-1" id="references-1"><h2>References</h2></a>
<a class="header" href="print.html#push" id="push"><h3><code>push</code></h3></a>
<pre><code class="language-js">/**
  This API allows you to provide a reference with new data. The simplest usage
  of this API is similar to `store.push`: you provide a normalized hash of data
  and the object represented by the reference will update.

  If you pass a promise to `push`, Ember Data will not ask the adapter for the
  data if another attempt to fetch it is made in the interim. When the promise
  resolves, the underlying object is updated with the new data, and the promise
  returned by *this function* is resolved with that object.

  For example, `recordReference.push(promise)` will be resolved with a record.

  @method
  @param {Promise|Object}
  @returns Promise&lt;T&gt; a promise for the value (record or relationship)
*/
</code></pre>
<a class="header" href="print.html#pushpayload" id="pushpayload"><h3><code>pushPayload</code></h3></a>
<pre><code class="language-js">/**
  This API is similar to `push`, but it invokes the serializer with the
  resolved data. This makes it possible to share normalization logic
  across multiple calls to `pushPayload` or between proactive pushes
  and reactive responses from the adapter.

  @method
  @param {Promise|Object}
  @returns Promise&lt;T&gt; a promise for the value (record or relationship)
*/
</code></pre>
<a class="header" href="print.html#state" id="state"><h3><code>state</code></h3></a>
<pre><code class="language-js">/**
  The current state of the entity, based on the semantics of the
  entity in question. For records, this should expose a subset of
  the named states in the internal state machine.

  @property
  @type String
*/
</code></pre>
<a class="header" href="print.html#value" id="value"><h3><code>value</code></h3></a>
<pre><code class="language-js">/**
  If the entity referred to by the reference is already loaded, it
  is present as `reference.value`. Otherwise, the value of this
  property is `null`.

  @property
*/
</code></pre>
<a class="header" href="print.html#data" id="data"><h3><code>data</code></h3></a>
<pre><code class="language-js">/**
  The value of the (normalized) representation of this entity. For
  example, `recordReference.data` will return a normalized dictionary
  of attributes and links.

  @property
*/
</code></pre>
<a class="header" href="print.html#metadata" id="metadata"><h3><code>metadata</code></h3></a>
<pre><code class="language-js">/**
  The most recent value of the metadata returned by the server for
  the value represented by this reference.

  @property
*/
</code></pre>
<a class="header" href="print.html#load" id="load"><h3><code>load</code></h3></a>
<pre><code class="language-js">/**
  Triggers a fetch for the backing entity based on its `remoteType`
  (see `remoteType` definitions per reference type).

  @method
  @param {Object} an options hash, similar to the one currently
    passed to `store.find`.
*/
</code></pre>
<a class="header" href="print.html#unload" id="unload"><h3><code>unload</code></h3></a>
<pre><code class="language-js">/**
  Unload the entity referred to by this relationship. After this
  operation, its `value`, `data` and `metadata` members will return
  to `null`, and the record itself will be purged from the identity
  map.

  @method
*/
</code></pre>
<a class="header" href="print.html#recordreference" id="recordreference"><h2>RecordReference</h2></a>
<a class="header" href="print.html#remotetype" id="remotetype"><h3><code>remoteType</code></h3></a>
<pre><code class="language-js">/**
  How the reference will be looked up with it is loaded:

  * `link`, a URL
  * `identity`, by the `type` and `id`
*/
</code></pre>
<a class="header" href="print.html#type" id="type"><h3><code>type</code></h3></a>
<pre><code class="language-js">/**
  The type of the record that this reference refers to.

  @property
*/
</code></pre>
<a class="header" href="print.html#id" id="id"><h3><code>id</code></h3></a>
<pre><code class="language-js">/**
  The `id` of the record that this reference refers to.

  Together, the `type` and `id` properties form a composite key
  for the identity map.

  @property
*/
</code></pre>
<a class="header" href="print.html#hasmanyreference" id="hasmanyreference"><h2>HasManyReference</h2></a>
<a class="header" href="print.html#remotetype-1" id="remotetype-1"><h3><code>remoteType</code></h3></a>
<pre><code class="language-js">/**
  How the reference will be looked up when it is fetched:

  * `link`, a URL provided by the server
  * `ids`, a list of IDs provided by the server
  * `dynamic`, a dynamic URL will be created based on the identity
    of the parent.

  @property
*/
</code></pre>
<a class="header" href="print.html#link" id="link"><h3><code>link</code></h3></a>
<pre><code class="language-js">/**
  If the `remoteType` is `link`, the URL to use to load the relationship.

  @property
*/
</code></pre>
<a class="header" href="print.html#ids" id="ids"><h3><code>ids</code></h3></a>
<pre><code class="language-js">/**
  If the `remoteType` is `ids`, a list of IDs that is used to formulate
  the query to the server (together with `type`).

  @property
*/
</code></pre>
<a class="header" href="print.html#type-1" id="type-1"><h3><code>type</code></h3></a>
<pre><code>/**
  The model type represented by this relationship.

  @property
*/
</code></pre>
<a class="header" href="print.html#parent" id="parent"><h3><code>parent</code></h3></a>
<pre><code class="language-js">/**
  A reference to the record that has this `hasMany` on it.

  @property
*/
</code></pre>
<a class="header" href="print.html#inverse" id="inverse"><h3><code>inverse</code></h3></a>
<pre><code class="language-js">/**
  If there is an inverse relationship, this property is a reference
  to it.

  @property
*/
</code></pre>
<a class="header" href="print.html#belongstoreference" id="belongstoreference"><h2>BelongsToReference</h2></a>
<a class="header" href="print.html#remotetype-2" id="remotetype-2"><h3><code>remoteType</code></h3></a>
<pre><code class="language-js">/**
  How the reference will be looked up when it is fetched:

  * `link`, a URL provided by the server
  * `id`, an ID to use to form the URL
  * `dynamic`, a dynamic URL will be created based on the identity
    of the parent.

  @property
*/
</code></pre>
<a class="header" href="print.html#link-1" id="link-1"><h3><code>link</code></h3></a>
<pre><code class="language-js">/**
  If the `remoteType` is `link`, the URL to use to load the relationship.

  @property
*/
</code></pre>
<a class="header" href="print.html#ids-1" id="ids-1"><h3><code>ids</code></h3></a>
<pre><code class="language-js">/**
  If the `remoteType` is `id`, an ID that is used to formulate
  the query to the server (together with `type`).

  @property
*/
</code></pre>
<a class="header" href="print.html#type-2" id="type-2"><h3><code>type</code></h3></a>
<pre><code>/**
  The model type represented by this relationship.

  @property
*/
</code></pre>
<a class="header" href="print.html#parent-1" id="parent-1"><h3><code>parent</code></h3></a>
<pre><code class="language-js">/**
  A reference to the record that has this `belongsTo` on it.

  @property
*/
</code></pre>
<a class="header" href="print.html#inverse-1" id="inverse-1"><h3><code>inverse</code></h3></a>
<pre><code class="language-js">/**
  If there is an inverse relationship, this property is a reference
  to it.

  @property
*/
</code></pre>
<a class="header" href="print.html#drawbacks-17" id="drawbacks-17"><h1>Drawbacks</h1></a>
<p>The main drawback to this proposal is that it adds significant surface area to Ember Data, which could easily be perceived as significant additional complexity. However, we believe that the unification of the various entities in Ember Data, as well as exposing internal tools that were previously only available to the store, will actually reduce the complexity of many common patterns.</p>
<a class="header" href="print.html#alternatives-17" id="alternatives-17"><h1>Alternatives</h1></a>
<p>The main alternative is to address each use case with a new API:</p>
<ul>
<li><code>store.peek(record, id)</code>, <code>record.peek(relationship)</code> to retrieve the current value of the relationship only if it was loaded</li>
<li>extend <code>store.push</code> and <code>store.pushPayload</code> to take promises</li>
<li>APIs like <code>record.inverseFor(relationship)</code>, <code>record.typeFor(relationship)</code>, etc.</li>
<li>APIs like <code>record.idsFor(relationship)</code>, <code>record.metadataFor(relationship)</code>, and <code>store.metadataFor(type, id)</code></li>
</ul>
<p>We believe that the cumulative overhead of all of these APIs is far more than the overhead of the reference APIs.</p>
<a class="header" href="print.html#unresolved-questions-16" id="unresolved-questions-16"><h1>Unresolved questions</h1></a>
<p>Is there a need to represent &quot;prefetch metadata&quot; separately? This is metadata that the app knows about before fetch, and which it would want to persist through an <code>unload()</code> operation (along with identity information like type, id and link).</p>
<ul>
<li>Start Date: 2015-05-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/58</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/11393</li>
</ul>
<a class="header" href="print.html#summary-18" id="summary-18"><h1>Summary</h1></a>
<p>This RFC outlines a new strategy for the registration of helpers in Ember 1.13.
In previous versions of Ember, helper lookup was a two-phase process of:</p>
<ul>
<li>Look in a whitelist of registered helpers. If in the whitelist, resolve that
path in the container.</li>
<li>If the path has a dash, try to resolve it in the container</li>
<li>If the container does not have a factory for this path, treat the path as a
bound value.</li>
</ul>
<p>This logic runs for every <code>{{somePath}}</code> in an Ember application.</p>
<p>This proposal attempts to simplify and unify that logic in a a single pass
against a whitelist, thus removing the special behavior of dashed paths.
Additionally, it attempts to design a solution that removes the current
<code>registerHelper</code> ceremony for undashed helpers.</p>
<a class="header" href="print.html#motivation-19" id="motivation-19"><h1>Motivation</h1></a>
<p>In <a href="https://github.com/emberjs/rfcs/pull/53">RFC #53</a> a new API for helpers is
outlined. This RFC presumes helpers will continue to have the naming
requirement of including a dash character.</p>
<p>The dash requirement for helpers exists for two reasons:</p>
<ul>
<li>For every <code>{{path}}</code> in an Ember application, it must be decided if that path
is a bound value, component, or helper. Component and helper lookup (the
discovery of a class or template) is lazy in Ember, thus for every <code>{{path}}</code>
a lookup for that string in the container is required. Container lookups
(the first time) are fairly slow, and performing this lookup for every
path may significantly impact initial render time. Thus, helpers are either
added to a whitelist (with <code>registerHelper</code>) or require a way to differentiate
themselves from the majority of data-binding cases (the dash).</li>
<li>In Ember 1.x, components were treated as helpers for certain code paths. This
made the dash requirement for components a natural extension to helpers.</li>
</ul>
<p>The Glimmer engine has removed some of these concerns and limitations.</p>
<p>Addon authors and app authors have both felt a need for non-dashed helper
names, for example <code>{{t 'some-string-to-translate'}}</code>. New developers to Ember
often find the dash requirement arbitrary and the <code>registerHelper</code> work around
difficult to understand and use.</p>
<p>For the new helper API to provide feature parity with APIs available to addon
authors in 1.12, a path to dashless helpers must be present in 1.13.</p>
<p>Given that a solution exists that addresses the performance concern, dropping
the dash requirement would resolve a significant amount of developer pain and
confusion.</p>
<a class="header" href="print.html#detailed-design-18" id="detailed-design-18"><h1>Detailed design</h1></a>
<p>At application boot, all known helper items (according to the resolver) are
iterated and added to a <code>helper-listing</code> service. This service is merely a
Set object with the names of all helpers.</p>
<p>When handling a <code>{{path}}</code>, the <code>helper-listing</code> service is consulted for the
presence of that <code>path</code>. If it is present, the path is looked up
on the container as a helper and the helper is used. Dashed paths are treated
no differently than any other path (for helpers).</p>
<a class="header" href="print.html#boot-time-discovery" id="boot-time-discovery"><h3>Boot time discovery</h3></a>
<p>To discover what paths may be helpers in Ember-CLI, the module names are
iterated. For example:</p>
<pre><code>not helper: app/components/foo-bar/component
not helper: app/controllers/foo-bar
not helper: app/foo-bar/route
helper &quot;t&quot;: app/t/helper
helper &quot;t&quot;: app/helpers/t
helper &quot;foo-bar&quot;: app/helpers/foo-bar
helper &quot;foo/bar&quot;: app/helpers/foo/bar
</code></pre>
<p>In a globals-mode application, The app namespace is iterated:</p>
<pre><code>not helper: App.FooBarComponent
not helper: App.FooBarController
not helper: App.FooBarRoute
helper &quot;t&quot;: App.THelper
helper &quot;foo-bar&quot;: App.FooBarHelper &lt;- should dasherize
</code></pre>
<p>In both cases <strong>the resolver is responsible for providing a list of modules
by type</strong>. The proposed API is <code>eachOfType</code>, here with Ember-CLI as an example:</p>
<pre><code class="language-js">// Given helperListing as a Set:
resolver.eachOfType(‘helper’, function(parsedName, item) {
  helperListing.add(parsedName.fullName);
})
</code></pre>
<p>In Ember-CLI, the <code>app/</code> tree of an addon is merged with the app tree of an
application. This means for a helper like <code>t</code> to be discovered, nothing besides
adding it to <code>app/helpers/t.js</code> must be done.</p>
<p>In 1.13, this will impact existing apps by discovering all helpers regardless
of if <code>registerHelper</code> has been called. This is a small behavior change that
should match intent, and will not impact sanely written apps.</p>
<p>Note that only the path of the helper is added to the listing. During discovery,
the helper is not looked up from the container, instead lookup still occurs
at render time.</p>
<p>The helper listing is intended to be a private service in Ember, and will be
registered at <code>services:-helper-listing</code>. If the discovery semantics described
here are not sufficient for some edge-cases, wrapping this service in a
public API on application instances may be required.</p>
<a class="header" href="print.html#render-time-lookup-and-use" id="render-time-lookup-and-use"><h3>Render-time lookup and use</h3></a>
<p>Let us consider how a path is rendered. For example:</p>
<pre><code class="language-hbs">{{date}}
</code></pre>
<ul>
<li>The <code>service:-helper-listing</code> service is fetched</li>
<li>The path <code>date</code> is checked for on the listing: <code>helperListing.has(path)</code></li>
<li>If the path is not in the listing, <code>date</code> is treated like a bound value</li>
<li>If the path is in the listing, the helper is looked up from Ember's
container as <code>helper:date</code></li>
<li>depending on the instance returned from the factory (a helper, shorthand
helper, or legacy <code>Ember.Handlebars</code> or <code>Ember.HTMLBars._registerHelper</code>
helper) the proper invocation for that helper is executed</li>
</ul>
<p>Every rendered path will hit the <code>helper-listing</code> service, but the check
against a well-implemented Set should be inexpensive.</p>
<a class="header" href="print.html#drawbacks-18" id="drawbacks-18"><h1>Drawbacks</h1></a>
<p>Removing the dash requirement will likely result in a larger number of naming
conflicts between addons and apps than has existed before now. In general,
encouraging verbose helper names may mitigate this concern. Long term, there
have been several discussions to date about how to implement namespaces in
Ember templates and for Ember engines.</p>
<p>That the helper listing is eagerly discovered at application boot time may
impact the design of Ember engines and lazy-loading parts of an app. The
discovery cache may need to be flushed and re-generated, however this limitation
already exists for the container lookup itself (which caches failures).</p>
<p>That the helper listing is not based on the container means helpers registered,
but not added to the listing because of non-standard naming, may need to
manually register against the private helper listing API.</p>
<a class="header" href="print.html#alternatives-18" id="alternatives-18"><h1>Alternatives</h1></a>
<p>Instead of a new across-the-board solution, Ember could continue to use a
<code>registerHelper</code> pattern very similar to what exists today. This would
perpetuate the existing pain, but would perhaps be more similar to what devs
already know.</p>
<a class="header" href="print.html#unresolved-questions-17" id="unresolved-questions-17"><h1>Unresolved questions</h1></a>
<p>The exact timing of helper discovery in Ember-CLI and globals mode has not been
decided.</p>
<ul>
<li>Start Date: 2015-06-03</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/61</li>
<li>Ember Issue: This RFC is implemented over many Ember Data PRs</li>
</ul>
<a class="header" href="print.html#summary-19" id="summary-19"><h1>Summary</h1></a>
<p>This RFC proposes new methods on the adapter to signal to the Ember Data store when it should re-request a record that is already cached in the store. It also proposes a new adapter options object that can be used by to provide instructions to the adapter from the place where the store's find method is called.</p>
<a class="header" href="print.html#motivation-20" id="motivation-20"><h1>Motivation</h1></a>
<a class="header" href="print.html#use-cases" id="use-cases"><h2>Use Cases</h2></a>
<p>When it comes to fetching records, there are several different behaviors
that users may expect. The behavior that users expect is influenced by
unique quirks in their data model, pre-existing expectations based on
traditional development models, and implementation details of their
adapter.</p>
<p>Fundamentally, users may expect or want one of the following sets of
behavior when fetching a model for the <code>model()</code> hook:</p>
<ul>
<li>Fetching data from the server the first time a record is requested,
but using only cached data subsequent times the route is entered.
(This is the current behavior of <code>find()</code>.)</li>
<li>Fetching new data every time the route is entered. The route will
&quot;block&quot; (show a loading spinner) until fresh data is received.</li>
<li>Using local data if available, but otherwise not triggering any
fetches if the data is not available. This is useful if records will
be pushed into the store ahead of time, e.g. by a socket, and
non-existence in the store means non-existence on the server.</li>
<li>Immediately returning a model with local data if available, rendering
the route's template immediately, and updating the record in the
background. If the record changes after conferring with the server,
the template is re-rendered.</li>
</ul>
<a class="header" href="print.html#discussion" id="discussion"><h2>Discussion</h2></a>
<a class="header" href="print.html#fetch-only-on-initial-render" id="fetch-only-on-initial-render"><h3>Fetch Only On Initial Render</h3></a>
<p>In this model, the record data is fetched from the server the first time
a record with a given ID is requested. Subsequent requests (e.g. leaving
and re-entering the same route) use locally cached data. This is the
strategy used by the current <code>find()</code> method.</p>
<p>The advantage of this model is that it keeps conferring with the server
to a minimum. Once data is loaded, the client can render new routes with
the model data that it has cached, without a network roundtrip.</p>
<p>Additionally, in some data models, records are immutable. For example, on
Twitter, tweets never change. In an email app, emails cannot change once
they are sent. Asking the server for the most up-to-date version of an
immutable record is a waste of resources.</p>
<p>The downsides of this model are two-fold.</p>
<p>First, this model is surprising to new developers. When navigating
between pages, they expect the most up-to-date representation to be
fetched and displayed every time.</p>
<p>Second, even for developers who understand what is happening, it is very
easy for long-lived applications to accumulate stale information,
particularly if the model they are displaying updates frequently.
Developers must somehow disambiguate between the first time a model is
looked up, and allowing it to proceed, and detecting when a cached model
is being used and updating it manually.</p>
<a class="header" href="print.html#new-fetch-every-render" id="new-fetch-every-render"><h3>New Fetch Every Render</h3></a>
<p>The advantages of this model are that it most closely matches the mental
model for developers coming from server-rendered and jQuery backgrounds.
In that model, every time a new page is loaded, the most up-to-date
information is guaranteed to be displayed. Because each page navigation
triggers a fetch from the database, the only way for information to
become stale is for the user to stop navigating.</p>
<p>The downside of this model is that it eliminates many of the advantages
of client-side routing. In traditional client apps, data is stored
locally, and navigations use that local data. In this model, every page
transition is blocked awaiting a network response from the server. It's
a slight improvement in that the data should be much smaller than a full
HTML page, but it is often latency and not bandwidth that causes
slowdowns.</p>
<a class="header" href="print.html#never-fetch" id="never-fetch"><h3>Never Fetch</h3></a>
<p>While an edge case, many Ember Data users have requested the ability to
fetch a record out of the store only if it exists locally.</p>
<p>One use case is for stores that are optimistically populated via pushed
data from a socket. In that case, if the record doesn't exist in the
store, it means that it doesn't exist on the server.</p>
<p>For obvious reasons, this is an uncommon case for the majority of apps.
While we should support it, it should not be part of the happy path for
new developers.</p>
<a class="header" href="print.html#immediate-render-background-refresh" id="immediate-render-background-refresh"><h3>Immediate Render, Background Refresh</h3></a>
<p>In this model, the first time a record is requested, it blocks the
render and shows a loading spinner. On subsequent requests, the locally
cached data is displayed and the render happens immediately without
making the user wait.</p>
<p>However, in the background, the store also kicks off a request to the
adapter to update the record. When the new data comes in, the record is
updated, and if there have been changes to the record since the initial
render, the template is re-rendered with the new information.</p>
<p>This is the model that I believe strikes the best tradeoff among the
options available.</p>
<p>First, it preserves the speed of client-side navigation. Once data for a
record is cached, transitioning to any route that relies on it is nearly
instantaneous and has no network bottleneck.</p>
<p>Second, because it triggers a background update, even users who expect a
new fetch every time will not be surprised as, ideally after a few
milliseconds, the new data will arrive and be persisted into the DOM.</p>
<p>Third, in most applications, models are not changing frequently.  Most
of the time, the cached version in the Ember Data store will be
identical to the latest server revision. In those cases, there is no
point in making users stare at a loading spinner</p>
<p>Of course, there are several downsides to this model that we should keep
in mind. For immutable records, fetching a new version in the background
is wasteful of bandwidth and server capacity and we should allow
developers to opt out of this behavior.</p>
<p>A second related case is apps using a socket to subscribe to record
changes once a record is fetched. In those cases, fetching up-to-date
information on subsequent requests for the model is wasteful because
they have guaranteed that they will keep the model up-to-date via change
events from the server. In this case, we need a way for adapter authors
to signal that subsequent update requests for a record are a no-op.</p>
<p>Third, it may be an unpleasant user experience for new information to
pop in suddenly after the initial render, particularly for records that
frequently change in dramatic ways. In those instances, we should make
sure we give developers the tools to build UIs that can indicate to the
user that the information is being updated, perhaps by greying it out or
displaying a loading spinner.</p>
<a class="header" href="print.html#detailed-design-19" id="detailed-design-19"><h1>Detailed design</h1></a>
<a class="header" href="print.html#proposal" id="proposal"><h2>Proposal</h2></a>
<a class="header" href="print.html#new-adapter-methods" id="new-adapter-methods"><h3>New Adapter Methods.</h3></a>
<p><code>shouldRefetchRecord</code> is a new method on the adapter that will be called by the store to make initial decision whether to refetch the record form the adapter or return the cached record from the store. This could method could be used to implement caching logic (e.g. only refetch this record after the time specified in its cache expires token) or for improved offline support (e.g. always refetch unless there is no internet connection then use cached record).</p>
<p>This record would only be called if the record was already found in the store and is in the loaded state.</p>
<p>This method is only checked by <code>store.findById</code> and <code>store.findAll</code>. Methods with <code>fetch</code> in their name always refetch the record(s) from the adapter.</p>
<pre><code class="language-js">{
  /**
   `shouldRefetchRecord` returns true if the adapter determines the record is
   stale and should be refetch. It should return false if the record
   is not stale or some other condition indicates that a fetch should
   not happen at this time (e.g. loss of internet connection). 

   This method is synchronous.

   @method shouldRefetchRecord
   @param {DS.Store} store
   @param {DS.Model} record
   @param {Object} adapterOptions
   @return {Boolean}
   */
  shouldRefetchRecord: function(store, record, adapterOptions),
}
</code></pre>
<p>The method <code>shouldBackgroundUpdate</code> would be used by the store to make the decision to re-fetch the record after it has already been returned to the user. This would allow realtime adapter to opt out of the background fetch if the adapter is already subscribing to changes on the record.</p>
<pre><code class="language-js">{
  /**
   `shouldBackgroundUpdate` returns true if the store should re fetch a
   record in the store after returning it to the user to ensure the
   record has the most up to date data.
   
   This method is synchronous.

   @method shouldBackgroundUpdate
   @param {DS.Store} store
   @param {DS.Model} record
   @param {Object} adapterOptions
   @return {Boolean}
  */
  shouldBackgroundUpdate: function(store, record, adapterOptions),
}
</code></pre>
<p>In the next major version of Ember Data the recommend way of finding a record
will be:</p>
<pre><code class="language-js">this.store.findById('person', 1);
</code></pre>
<p>This will return a promise that:</p>
<ol>
<li>Waits to resolve until the data is fetched from the server, on the
initial request.</li>
<li>Resolves immediately with the locally cached request for subsequent
requests, but triggers a request to the server for the updated
version and updates the record in-place if there are changes.</li>
</ol>
<p>In terms of the above methods <code>shouldRefetchRecord</code> will always return <code>false</code> and <code>shouldBackgroundUpdate</code> will always return <code>true</code> in the default <code>RESTAdapter</code>.</p>
<p>The fundamental guarantee of <code>findById()/findAll()</code> when using the default <code>RESTAdapter</code> is:</p>
<blockquote>
<p>Give me the information you have available locally, then give me the
most up-to-date information as soon as possible.</p>
</blockquote>
<p>Currently, the <code>find()</code> method takes an optional third parameters that
is passed to the adapter. In this API, that data structure is moved to
a field in the new options hash:</p>
<pre><code class="language-js">this.store.findById('person', 1, {
  preload: { comment_id: 1 }
});
</code></pre>
<a class="header" href="print.html#isupdating-flag" id="isupdating-flag"><h3><code>isUpdating</code> Flag</h3></a>
<p>To assist developers in building UIs that communicate the state of
models to their users, we should provide a helper that allows developers
to show UI elements when a model is in the process of being updated via
<code>fetch()</code>.</p>
<p>I propose adding an <code>isUpdating</code> flag to models, which can be used to
conditionally show a spinner:</p>
<pre><code class="language-handlebars">&lt;h1&gt;{{post.title}}&lt;/h1&gt;
{{#if isUpdating post}}
  &lt;small&gt;Updating...&lt;/small&gt;
{{/if}}

&lt;p&gt;{{post.body}}&lt;/p&gt;
</code></pre>
<p>(Currently, only <code>RecordArray</code>s have an <code>isUpdating</code> flag.)</p>
<p>Models have an <code>isReloading</code> flag. This will be deprecated in favor of the new <code>isUpdating</code> flag.</p>
<a class="header" href="print.html#drawbacks-19" id="drawbacks-19"><h1>Drawbacks</h1></a>
<p>Why should we <em>not</em> do this?</p>
<p>After the record has been updated in the background Ember's Data binding will cause any views to automatically update with the latest changes. This can result an a surprising &quot;popping&quot; effect which is especially pronounced when the background fetch resolves quickly (The user sees an initial render with the stale data then a quick re-render with the fresh data).</p>
<a class="header" href="print.html#alternatives-19" id="alternatives-19"><h1>Alternatives</h1></a>
<p>What other designs have been considered? What is the impact of not doing this?</p>
<p>One alternate option could be for Ember Data to track an expires token on a model. This would allow Ember
Data to behave like a caching proxy when fetching. If the record is expired, fetch should block.
If the record is not expired it would return a resolve the record right away however still issue a
second request.</p>
<p>When used with backends that do not return an expires token. Ember Data would assume that the
record is stale (this could be configured on the adapter).</p>
<a class="header" href="print.html#unresolved-questions-18" id="unresolved-questions-18"><h1>Unresolved questions</h1></a>
<ul>
<li>Start Date: 2015-06-12</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/64</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-20" id="summary-20"><h1>Summary</h1></a>
<p>The goal of this RFC is to allow for better component composition and the
usage of components for domain specific languages.</p>
<p>Ember components can be invoked three ways:</p>
<ul>
<li><code>{{a-component</code></li>
<li><code>{{component someBoundComponentName</code></li>
<li><code>&lt;a-component</code> (coming soon!)</li>
</ul>
<p>In all these cases, attrs passed to the component must be set at the place of
invocation. Only the <code>{{component someBoundComponentName</code> syntax allows for the name
of the component invoked to be decided elsewhere.</p>
<p>All component names are resolved to components through one global resolution
path.</p>
<p>To improve composition, four changes are proposed:</p>
<ul>
<li>The <code>(component</code> helper will be introduced to close over component attrs in
a yielding context.</li>
<li>The <code>{{component</code> helper will accept an argument of the object created by
<code>(component</code> for invocation (as it invokes strings today).</li>
<li>Property lookups with a value containing a dot will be considered for
rendering as components. <code>{{form.input}}</code> would be considered, for instance.
Helper invocations with a dot will also be treated like a component if the
key has a value of a component, for instance <code>{{form.input value=baz}}</code>.</li>
<li>A <code>(hash</code> helper will be introduced.</li>
</ul>
<a class="header" href="print.html#motivation-21" id="motivation-21"><h1>Motivation</h1></a>
<p>When building a complex UI from several components, it can be difficult to
share data without breaking encapsulation. For example this template:</p>
<pre><code class="language-hbs">{{#great-toolbar role=user.role}}
  {{great-button role=user.role}}
{{/great-toolbar}}
</code></pre>
<p>Causes the user to pass the <code>role</code> data twice for what are obviously related
components. A component can yield itself down:</p>
<pre><code class="language-hbs">{{! app/components/great-toolbar/template.hbs }}
{{yield this}}
</code></pre>
<pre><code class="language-hbs">{{#great-toolbar role=user.role as |toolbar|}}
  {{great-button toolbar=toolbar}}
{{/great-toolbar}}
</code></pre>
<p>And <code>great-button</code> can have knowledge about properties on <code>great-toolbar</code>, but
this break the isolation of components. Additionally the calling syntax is not
much better, <code>toolbar</code> must still be passed to each downstream component.</p>
<p>Often <code>nearestOfType</code> is used as a workaround for these limitations. This API
is poorly performing, and still results in the downstream child accessing the
parent component properties directly.</p>
<p>Consequently there is a demand by several addons for improvement. Our goal
is a syntax similar to DSLs in Ruby:</p>
<pre><code class="language-hbs">{{#great-toolbar role=user.role as |toolbar|}}
  {{toolbar.button}}
  {{toolbar.button orWith=additionalProperties}}
{{/great-toolbar}}
</code></pre>
<p>As laid out in this proposal, the <code>great-toolbar</code> implementation would look
like:</p>
<pre><code class="language-hbs">{{! app/components/great-toolbar/template.hbs }}
{{yield (hash
  button=(component 'great-button' role=user.role)
)}}
</code></pre>
<a class="header" href="print.html#detailed-design-20" id="detailed-design-20"><h1>Detailed design</h1></a>
<a class="header" href="print.html#the-component-helper-and-component-helper" id="the-component-helper-and-component-helper"><h3>The <code>(component</code> helper and <code>{{component</code> helper</h3></a>
<p>Much like <code>(action</code> creates a closure, it is proposed that the <code>(component</code>
helper create something similar. For example with actions:</p>
<pre><code class="language-hbs">{{#with (action &quot;save&quot; model) as |save|}}
  &lt;button {{action save}}&gt;Save&lt;/button&gt;
{{/with}}
</code></pre>
<p>The returned value of the <code>(action</code> nested helper (a function) closes over the
action being called (<code>actions.save</code> on the context and the <code>model</code> property).
The <code>{{action</code> helper can accept this resulting value and invoke the action
when the user clicks.</p>
<p>The <code>(component</code> helper will close over a component name. The
<code>{{component</code> helper will be modified to accept this resulting value and invoke
the component:</p>
<pre><code class="language-hbs">{{#with (component &quot;user-profile&quot;) as |uiPane|}}
  {{component uiPane}}
{{/with}}
</code></pre>
<p>Additionally, a bound value may be passed to the <code>(component</code> helper. For
example <code>(component someComponentName)</code>.</p>
<p>Attrs for the final component can also be closed over. Used with yield, this
allows for the creation of components that have attrs from other scopes. For
example:</p>
<pre><code class="language-hbs">{{! app/components/user-profile.hbs }}
{{yield (component &quot;user-profile&quot; user=user.name age=user.age)}}
</code></pre>
<pre><code class="language-hbs">{{#user-profile user=model as |profile|}}
  {{component profile}}
{{/user-profile}}
</code></pre>
<p>Of course attrs can also be passed at invocation. They smash any conflicting
attrs that were closed over. For example <code>{{component profile age=lyingUser.age}}</code></p>
<p>Passing the resulting value from <code>(component</code> into JavaScript is permitted,
however that object has no public properties or methods. Its only use would
be to set it on state and reference it in template somewhere.</p>
<a class="header" href="print.html#hash-helper" id="hash-helper"><h3>Hash helper</h3></a>
<p>Unlike values, components are likely to have specific names that are semantically
relevent. When yielded to a new scope, allowing the user to change the name
of the component's variable would quickly lead to confusing addon documentation.
For example:</p>
<pre><code class="language-hbs">{{#with (component &quot;user-profile&quot;) as |dropDatabaseUI|}}
  {{component dropDatabaseUI}}
{{/with}}
</code></pre>
<p>The simplest way to enforce specific names is to make building hashes
of components (or anything) easy. For example:</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{component userComponents.profile}}
{{/with}}
</code></pre>
<p>The <code>(hash</code> helper is a generic builder of objects, given hash arguments. It
would also be useful in the same manner for actions:</p>
<pre><code class="language-hbs">{{#with (hash save=(action &quot;save&quot; model)) as |userActions|}}
  &lt;button {{action userActions.save}}&gt;Save&lt;/button&gt;
{{/with}}
</code></pre>
<a class="header" href="print.html#component-helper-shorthand" id="component-helper-shorthand"><h3>Component helper shorthand</h3></a>
<p>To complete building a viable DSL, <code>.</code> invocation for <code>{{</code> components will be
introduced. For example this <code>{{component</code> invocation:</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{component userComponents.profile}}
{{/with}}
</code></pre>
<p>Could be converted to drop the explicit <code>component</code> helper call.</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{userComponents.profile}}
{{/with}}
</code></pre>
<p>A component can be invoked like this only when it was created by the
<code>(component</code> nested helper form. For example unlike with the <code>{{component</code>
helper, a string is not acceptable.</p>
<p>To be a valid invocation, one of two criteria must be met:</p>
<ul>
<li>The component can be called as a path. For example <code>{{form.input}}</code> or <code>{{this.input}}</code></li>
<li>The component can be called as a helper. For example <code>{{form.input value=baz}}</code> or <code>{{this.input value=baz}}</code></li>
</ul>
<p>And of course a <code>.</code> must be present in the path.</p>
<a class="header" href="print.html#drawbacks-20" id="drawbacks-20"><h1>Drawbacks</h1></a>
<p>This proposal encourages aggressive use of the <code>(</code> nested helper syntax.
Encouraging this has been slightly controversial.</p>
<p>No solution for angle components is presented here. The syntax for <code>.</code>
notation in angle components is coupled to a decision on the syntax for
bound, dynamic angle component invocation (a <code>{{component</code> helper for angle
components basically).</p>
<p><code>(component 'some-component'</code> may be too verbose. It may make sense to simply
allow <code>(some-component</code>.</p>
<p>Other proposals have leaned more heavy on extending factories in JavaScript
then passing an object created in that space. Some arguments against this:</p>
<ul>
<li>Getting the container correct is tricky. Who sets it when?</li>
<li>Properties on the classes would not be naturally bound, as they are in this proposal.</li>
<li>As soon as you start setting properties, you likely want a <code>mut</code> helper,
<code>action</code> helper, etc, in JavaScript space.</li>
<li>Keeping the component lookup in the template layer allows us to take advantage
of changes to lookup semantics later, such as local lookup in the pods
proposal.</li>
</ul>
<a class="header" href="print.html#alternatives-20" id="alternatives-20"><h1>Alternatives</h1></a>
<p>All pain, no gain. Addons really want this.</p>
<a class="header" href="print.html#unresolved-questions-19" id="unresolved-questions-19"><h1>Unresolved questions</h1></a>
<p>There has been discussion of if a similar mechanism should be available for
helpers.</p>
<ul>
<li>Start Date: 2015-06-30</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/65</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-21" id="summary-21"><h1>Summary</h1></a>
<p>Deprecations and warnings in Ember.js should have configurable runtime handlers.
This allows default behavior (logging, raise when <code>RAISE_ON_DEPRECATION</code> is true)
to be overridden by an enviornment (Ember's tests), addon, or other tool
(like the Ember Inspector).</p>
<p>Ember-Data and the Ember Inspector have both requested a public
API for changing how deprecation and warning messages are handled. The requirements
for these and other requests are complex enough that deferring the message
behavior into a runtime hook is the suggested path.</p>
<a class="header" href="print.html#motivation-22" id="motivation-22"><h1>Motivation</h1></a>
<p><code>Ember.deprecate</code> and <code>Ember.warn</code> usually log messages. With <code>ENV.RAISE_ON_DEPRECATION</code>
all deprecations will throw an exception. In some scenarios, this
is less than ideal:</p>
<ul>
<li>Ember itself needs a way to silence some deprecations before their usage
is completely removed from tests. For example, many view APIs in Ember 1.13.</li>
<li>The Ember inspector desires to raise on specific deprecations, or silence
specific deprecations.</li>
<li>Ember-Data also desires to silence some deprecations in tests</li>
</ul>
<p>In <a href="https://github.com/emberjs/ember.js/pull/11419">PR #1141</a>
a private log level API has been introduced, which allows finer grained control
if specific deprecations should be logged, throwing an error or be silenced
completely. For example:</p>
<pre><code class="language-js">Ember.Debug._addDeprecationLevel('my-feature', Ember.Debug._deprecationLevels.LOG);
// ...
Ember.deprecate(&quot;x is deprecated, use Y instead&quot;, false, { id: 'my-feature' });
</code></pre>
<p>Initially a public version of this API was discussed, but it quickly became
clear that a runtime hook provided more flexibility without incurring the
cost of a complex log-level API.</p>
<p>Note that &quot;runtime&quot; refers to Ember itself. A custom handler could be injected
into Ember-CLI's template compilation code. &quot;runtime&quot; in this context still
refers to handling deprecations raised during compilation.</p>
<a class="header" href="print.html#detailed-design-21" id="detailed-design-21"><h1>Detailed design</h1></a>
<p>A handler for deprecations can be registered. This handler will be called
with relevent information about a deprecation, including guarantees about
the presence of these items:</p>
<ul>
<li>The deprecation message</li>
<li>The version number where this deprecation (and feature) will be removed</li>
<li>The &quot;id&quot; of this deprecation, a stable identifier independent of the message</li>
</ul>
<p>Additionally, an application instance may be passed with the options. An example
handler would look like:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/deprecations&quot;;

registerHandler(function deprecationHandler(message, options) {
  // * message is the deprecation message
  // * options.until is the version this deprecation will be removed at
  // * options.id is the canonical id for this deprecation
  if (options.until === &quot;2.4.0&quot;) {
    throw new Error(message);
  } else {
    console.log(message);
  }
});
</code></pre>
<p>Warnings are similar, but will not recieve an <code>until</code> value:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/warnings&quot;;

registerHandler(function warningHandler(message, options) {
  // * message is the warning message
  // * options.id is the canonical id for this warning
  if (options.id !== 'view.rerender-on-set') {
    console.log(message);
  }
});
</code></pre>
<a class="header" href="print.html#chained-handlers" id="chained-handlers"><h5>chained handlers</h5></a>
<p>Since several handlers may be registered, a method of deferring to a previously
registered handler must be allowed. A third option is passed to handlers, the
function <code>next</code> which represents the previously registered handler.</p>
<p>For example:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/deprecations&quot;;

registerHandler(function firstDeprecationHandler(message, options, next) {
  console.warn(message);
});

registerHandler(function secondDeprecationHandler(message, options, next) {
  if (options.until === &quot;2.4.0&quot;) {
    throw new Error(message);
  }
  next(...arguments);
});
</code></pre>
<p>The first registed handler will receive Ember's default behavior as <code>next</code>.</p>
<a class="header" href="print.html#new-assertions-for-deprecate-and-warn" id="new-assertions-for-deprecate-and-warn"><h5>new assertions for deprecate and warn</h5></a>
<p>Ember's APIs for deprecation and warning do not currently require any information
beyond a message. It is proposed that deprecations be <strong>required</strong> to pass
the following information:</p>
<ul>
<li>Message</li>
<li>Test</li>
<li>Canonical id (with a format of <code>package-name.some-id</code>)</li>
<li>Release when this deprecation will be stripped</li>
</ul>
<p>For example:</p>
<pre><code>import Ember from &quot;ember&quot;;

Ember.deprecate(&quot;Some message&quot;, false, {
  id: 'ember-routing.query-params',
  until: '3.0.0'
});
</code></pre>
<p>If this information is not present and assertion will be made.</p>
<p>Warnings likewise will be required to pass a canonical id:</p>
<pre><code>import Ember from &quot;ember&quot;;

Ember.warn(&quot;Some warning&quot;, {id: 'ember-debug.something'});
</code></pre>
<a class="header" href="print.html#default-handlers" id="default-handlers"><h5>default handlers</h5></a>
<p>The default handler for deprecation should be quite simple, and mirrors current
behavior:</p>
<pre><code class="language-js">function defaultDeprecationHandler(message, options) {
  if (Ember.ENV.RAISE_ON_DEPRECATION) {
   throw new Error(format(message, options));
  } else {
   console.log(format(message, options));
  }
}
</code></pre>
<p>The default handler for warnings would be simple <code>console.log</code>.</p>
<a class="header" href="print.html#drawbacks-21" id="drawbacks-21"><h1>Drawbacks</h1></a>
<p>By not providing a robust log-level API, we are punting complexity to the
consumer of this API. For a low-level tooling API such as this one, it seems
and appropriate tradeoff.</p>
<a class="header" href="print.html#alternatives-21" id="alternatives-21"><h1>Alternatives</h1></a>
<p>Each app can stub out <code>deprecate</code> and <code>warn</code>.</p>
<a class="header" href="print.html#unresolved-questions-20" id="unresolved-questions-20"><h1>Unresolved questions</h1></a>
<p><code>RAISE_ON_DEPRECATION</code> could be considered deprecated with this new API.</p>
<ul>
<li>Start Date: 2016-11-21</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/80">#80</a></li>
</ul>
<a class="header" href="print.html#summary-22" id="summary-22"><h1>Summary</h1></a>
<p>This RFC attempts to expose a public API in <code>ember-cli</code> to allow other platforms/infrastructure to serve the base page (index.html) and other assets from the <code>tmp</code> directory in their own custom way. This is only for development as this will only be used with <code>ember serve</code>. Currently <code>ember serve</code> serves files from the tmp directory (which is built as part of the build process) using the <code>broccoli-middleware</code>. This middleware in addition to serving the files also sets the correct headers for the assets it is serving. This RFC aims to split the work of setting the header and serving the files into two different addons such that any other infrastructure can easily create a middleware to serve assets using its own logic.</p>
<a class="header" href="print.html#motivation-23" id="motivation-23"><h1>Motivation</h1></a>
<p>FastBoot and other infrastructure (for example the infrastructure at LinkedIn to serve the base page) does not require the index.html to be served from the disk directly. FastBoot requires to serve the index.html after it has appended the serialized template for the current request. It therefore requires to do some runtime replacements in the index.html before it can be served to the client. At LinkedIn, we stream the index.html in chunks for performance reasons and require to do some string replacements in index.html on per request basis.</p>
<p>During development, this requires us to create our own  express middleware via <code>serverMiddleware</code> which should run before the <code>serve-files</code> middleware. It also requires us to almost copy paste the headers that are set by <code>broccoli-middleware</code>. In addition to the above, the ability to be able to serve from <code>tmp</code> directory allows FastBoot and other infrastructure to correctly serve the assets from the directory pointing to the current build. Currently (with using their own middleware) FastBoot serves assets from the <code>dist</code> directory which is not the correct behavior.</p>
<p>In order to mitigate the need to diverge into another middleware which behaves almost same as <code>broccoli-middleware</code>, this RFC proposes to split the work of setting the headers and serving the files via <code>broccoli-middleware</code> and expose a public API that will allow an addon to define how it wants to serve the assets. It will be a low level public API that will be invoked by certain addons.</p>
<a class="header" href="print.html#detailed-design-22" id="detailed-design-22"><h1>Detailed design</h1></a>
<p>Currently the <a href="https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L18"><code>serve-files</code></a> addon defines how it will serve the incoming asset requests. It invokes the <code>broccoli-middleware</code> which is responsible for three sets of things:</p>
<ol>
<li>
<p>Setting the response headers</p>
</li>
<li>
<p>serving the files and ending the response</p>
</li>
<li>
<p>Shows an error template if it is a build error</p>
</li>
</ol>
<a class="header" href="print.html#public-api" id="public-api"><h2>Public API</h2></a>
<p>This RFC proposes expose two new in-repo addons in <code>ember-cli</code> which will now split the above work and remove the <code>serve-files</code> addon:</p>
<ol>
<li>
<p><code>ember-cli:broccoli:watcher</code>: This addon will contain the middleware which will be responsible for making sure the build is done and will set the response headers that <code>broccoli-middleware</code> is doing today. After setting the response headers, it will call the next middleware in the chain. In addition, if the build results in an error, it will show the error template and not terminate the response.</p>
</li>
<li>
<p><code>ember-cli:broccoli:serve-files</code>: This addon will always run <em>after</em> <code>ember-cli:broccoli:watcher</code> addon. It will contain a middleware that will be responsible for serving the files from the filesystem and ending the response.</p>
</li>
</ol>
<p>For any infrastructure that needs to serve the assets in its own way will be create an addon that will be injected between the above two addons. It will use the <code>serverMiddleware</code> public hook to provide its own middleware. Specifically the custom addon should run <em>before</em> <code>ember-cli:broccoli:serve-files</code> so that it can either override any response headers or can serve the files using its own logic and end the response. This will ensure that when the build is successful <code>ember-cli:broccoli:watcher</code> can call the correct next middleware in the chain.</p>
<a class="header" href="print.html#implementation-details" id="implementation-details"><h2>Implementation Details</h2></a>
<p>In order for the above API to be exposed, we need to drop the <code>serve-files</code> addon in <code>ember-cli</code>, refactor <code>broccoli-middleware</code> and create the two new addons.</p>
<a class="header" href="print.html#refactor-broccoli-middleware-to-expose-additional-middlewares" id="refactor-broccoli-middleware-to-expose-additional-middlewares"><h3>Refactor <code>broccoli-middleware</code> to expose additional middlewares</h3></a>
<p><em>Note</em>: This refactor section is only for making the reader understand how the integration is meant to work in <code>ember-cli</code>. This is not going to be <code>ember-cli</code> public API.</p>
<p><code>broccoli-middleware</code> is currently responsible for setting the response headers and serving the files. It is a middleware that does these two tasks. It doesn't expose a proper middleware API to do the two tasks differently. We would like to refactor <code>broccoli-middleware</code> such that it exposes two additional middlewares:</p>
<ul>
<li><code>forWatcher(watcher)</code>:</li>
</ul>
<pre><code class="language-javascript">  /**
   * Function responsible for setting the response headers or creating the build error template
   *
   * @param {Object} watcher ember-cli watcher
   * @return {Function} middleware function
   */
   forWatcher: function(watcher) {
     var outputPath = watcher.builder.outputPath;
     ...
     return function middleware(request, response, next) {
       watcher.then(function() {
         // mostly all of this https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L96
         request.headers['x-broccoli'] = {
           outputPath: outputPath
         };
         next();
       }, function(buildError) {
         // mostly this: https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L121
       })
     }

   }
</code></pre>
<ul>
<li><code>serveFiles()</code>:</li>
</ul>
<pre><code class="language-javascript"> /**
  * This function will be responsible for serving the files from the filesystem
  *
  * @param {HTTP.Request} request
  * @param {HTTP.Response} response
  * @param {Function} next
  */
  serveFiles: function() {
    return function(req, resp, next) {
      // get the output path from from the request headers
      // most of `broccoli-middleware` https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L115
    }
  }
</code></pre>
<a class="header" href="print.html#create-ember-clibroccoliwatcher-addon" id="create-ember-clibroccoliwatcher-addon"><h3>Create <code>ember-cli:broccoli:watcher</code> addon</h3></a>
<p>The current <code>serve-files</code> addon invokes the <code>broccoli-middleware</code> and delegates the task to this middleware to serve the files and set the headers. We would like to change that and instead this new in-repo addon <code>ember-cli:broccoli:watcher</code> should only call <code>setResponseHeaders</code> function from <code>broccoli-middleware</code>. The <code>serverMiddleware</code> function of this <a href="https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L18">addon</a> will now look as follows:</p>
<pre><code class="language-javascript">  ServeFilesAddon.prototype.serverMiddleware = function(options) {
    var app = options.app;
    var watcher = options.options.watcher;
    var broccoliMiddleware = require('broccoli-middleware');

    app.use(function(req, resp, next) {
      // copy over this: https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L33
      if (options.options.middleware) {
        // call the middleware that is provided for testemMiddleware
      } else {
        var watcherMiddleware = broccoliMiddleware.forWatcher(watcher);

        watcherMiddleware(req, resp, function(err) {
          if (err) {
            // log error
          }
          next(err);
        });
      }
    });
  }
</code></pre>
<p>As seen above <code>ember-cli:broccoli:watcher</code> will only be responsible for setting the headers and calling the the next middleware which will serve the files.</p>
<a class="header" href="print.html#create-ember-clibroccoliserve-files-addon" id="create-ember-clibroccoliserve-files-addon"><h3>Create <code>ember-cli:broccoli:serve-files</code> addon</h3></a>
<p>We will create a new in-repo addon called as <code>ember-cli:broccoli:serve-files</code> which will be responsible for serving the the files. This addon will run <em>after</em> <code>ember-cli:broccoli:watcher</code> addon.</p>
<p>This function will be responsible for serving the incoming asset request from the filesystem. It will use the <code>serverMiddleware</code> API to serve the files using <code>broccoli-middleware</code>.</p>
<pre><code class="language-javascript">  BroccoliServeFilesAddon.prototype.serverMiddleware = function(options) {
    var broccoliMiddleware = require('broccoli-middleware');
    var outputPath = options.watcher.builder.outputPath;
    var autoIndex = false;

    var options = { outputPath, autoIndex };
    app.use(function(req, resp, next) {
      var serveFileMiddlware = broccoliMiddleware.serveFiles();
      serveFileMiddlware(req, resp, function(err) {
        next(err);
      })
    });
  }
</code></pre>
<p>In order for FastBoot to be able to serve the assets using its own logic, it will specific that it run <em>before</em> <code>ember-cli:broccoli:serve-files</code> addon so that it can serve the assets. In this way, FastBoot will be able to inject itself into the correct order and be able to serve assets from the <code>tmp</code> directory.</p>
<a class="header" href="print.html#drop-serve-files-addon-in-ember-cli" id="drop-serve-files-addon-in-ember-cli"><h3>Drop <code>serve-files</code> addon in ember-cli</h3></a>
<p>Since the work that <code>serve-files</code> does today is now split into two new in-repo addons, <code>serve-files</code> addon doesn't need to be present any longer. It is not exposing any public API or functionality that users may be using today and therefore can be dropped.</p>
<a class="header" href="print.html#how-we-teach-this-1" id="how-we-teach-this-1"><h1>How We Teach This</h1></a>
<p>We will need to update the <code>ember-cli</code> website with this new in-repo addon and specify the above usecase with an example.</p>
<a class="header" href="print.html#drawbacks-22" id="drawbacks-22"><h1>Drawbacks</h1></a>
<p>The only drawback is addon authors wanting to serve assets using their own logic, will need to know the correct order of middleware execution. Moreover, if someone has forked <code>ember-cli</code> to hack <code>serve-files</code> addon logic, it will be a breaking change for them.</p>
<a class="header" href="print.html#alternatives-22" id="alternatives-22"><h1>Alternatives</h1></a>
<p>N/A</p>
<a class="header" href="print.html#unresolved-questions-21" id="unresolved-questions-21"><h1>Unresolved questions</h1></a>
<ul>
<li>[ ] Should this addons be better named?</li>
</ul>
<ul>
<li>Start Date: 2016-12-04</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/86">#86</a></li>
</ul>
<a class="header" href="print.html#summary-23" id="summary-23"><h1>Summary</h1></a>
<p>Replace PhantomJS with Firefox as the default browser for continuous integration testing.</p>
<a class="header" href="print.html#motivation-24" id="motivation-24"><h1>Motivation</h1></a>
<p>We want to provide the best possible out-of-the-box continuous integration testing experience for Ember apps. Today that means shipping with configurations for testem and TravisCI. Those configurations use PhantomJS.</p>
<p>But PhantomJS is a weird environment. Users must often fix Phantom-specific browser bugs, which is wasted effort since real users never run your app in Phantom. And &quot;how to debug in Phantom&quot; is an entire extra skill people are forced to learn.</p>
<p>A user-targeted, standards-compliant, modern browser makes a better default choice. Firefox is a good candidate because it's 100% open source, well-supported by Testem on all major operating system, and built-in to TravisCI. Debugging in Firefox has a dramatically nicer learner curve than PhantomJS.</p>
<a class="header" href="print.html#detailed-design-23" id="detailed-design-23"><h1>Detailed design</h1></a>
<p>This is a proposed change to the blueprints for new apps and addons. Existing apps and addons would only be affected when they re-run <code>ember init</code> as part of an upgrade and choose to take the updated configuration.</p>
<a class="header" href="print.html#changes-in-testemjs" id="changes-in-testemjs"><h2>Changes in testem.js</h2></a>
<p>Replace <code>PhantomJS</code> with <code>Firefox</code>.</p>
<a class="header" href="print.html#changes-in-travisyml" id="changes-in-travisyml"><h2>Changes in travis.yml</h2></a>
<p>Add the following new section to start up a virtual display:</p>
<pre><code>before_script:
  - export DISPLAY=:99; sh -e /etc/init.d/xvfb start; sleep 3
</code></pre>
<a class="header" href="print.html#how-we-teach-this-2" id="how-we-teach-this-2"><h1>How We Teach This</h1></a>
<p>In the guides, replace instructions for installing PhantomJS with instructions for installing Firefox. Since Firefox is a consumer-facing browser with widely-understood installers and behavior, this is one less intimidating thing for newbies to learn.</p>
<a class="header" href="print.html#drawbacks-23" id="drawbacks-23"><h1>Drawbacks</h1></a>
<p>PhantomJS has two primary benefits over other browsers: being headless and being scriptable.</p>
<a class="header" href="print.html#headlessness" id="headlessness"><h2>Headlessness</h2></a>
<p>Firefox is not headless, so it needs to render to a display. That is why the Travis configuration needs xvfb.</p>
<a class="header" href="print.html#scriptability" id="scriptability"><h2>Scriptability</h2></a>
<p>PhantomJS is scriptable, but we don't rely on that functionality anyway. We want cross-browser test suites, so Phantom's scriptability is not particularly useful.</p>
<a class="header" href="print.html#alternatives-23" id="alternatives-23"><h1>Alternatives</h1></a>
<p>The default alternative is to do nothing and keep PhantomJS.</p>
<p>Another alternative would be to pick Chrome, since it is a very popular browser. However, Chrome is not 100% open source, which complicates distribution. It's not built into Travis, and the popular methods of installing it there require users to opt into non-container-based images, which are heavier and slower to boot.</p>
<p>Chromium is the fully-open-source parts of Chrome, but like PhantomJS it is an odd duck that's not really well-packaged for end users. It's also not installed by default in Travis.</p>
<ul>
<li>Start Date: 2016-12-11</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/90">#90</a></li>
</ul>
<a class="header" href="print.html#summary-24" id="summary-24"><h1>Summary</h1></a>
<p>In Ember CLI today, all addons at each level are built through the standard <code>treeFor</code> / <code>treeFor*</code> hooks. These hooks are responsible for preprocessing the JavaScript included by the tree returned from that specific hook (e.g., <code>treeForAddon</code> preprocesses the JS for the addon tree). This RFC proposes a mechanism that would allow these returned trees to be cached by default (when no build time customization is done) and expose proper hooks for addon authors to control the degree to which we dedupe these trees.</p>
<a class="header" href="print.html#motivation-25" id="motivation-25"><h1>Motivation</h1></a>
<p>Today, given the dependency graph:</p>
<pre><code>ember-basic-dropdown:
  ember-wormhole@0.4.1

ember-modal-dialog:
  ember-wormhole@0.4.1

ember-paper:
  ember-wormhole@0.4.1
</code></pre>
<p>We would actually build <code>ember-wormhole</code>'s <code>addon</code> tree 3 different times, even though <a href="https://github.com/yapplabs/ember-wormhole/blob/0.4.1/index.js">as you can see</a> there is absolutely no build time customization being done. After all of these <code>ember-wormhole</code> tree instances are built, we merge them such that the last tree wins (thus making all of the work to preprocess these trees completely moot). If you extrapolate this out to larger applications or ones using multiple engines (lazy or not) it is fairly common to see these sorts of dependencies shared upwards of 4 to 5 times. This can lead to significant build performance degradation.</p>
<a class="header" href="print.html#detailed-design-24" id="detailed-design-24"><h1>Detailed design</h1></a>
<ul>
<li>Add a <code>Addon.prototype.cacheKeyForTree</code> method to <a href="https://github.com/ember-cli/ember-cli/commits/master/lib/models/addon.js">lib/models/addon.js</a> that is invoked prior to calling <code>treeFor</code> for the same tree name. The <code>Addon.prototype.cacheKeyForTree</code> method is expected to return a cache key allowing multiple builds of the same tree to simply return the original tree (preventing duplicate work). If <code>Addon.prototype.cacheKeyForTree</code> returns <code>null</code> / <code>undefined</code> the tree in question will opt out of this caching system.</li>
<li>ember-cli's custom <a href="https://github.com/ember-cli/ember-cli/blob/4ec7b5951e8a9dd292029faf20d1858abf7bdfa0/lib/broccoli/merge-trees.js"><code>mergeTrees</code> implementation</a> (which is already aware of other tree reduction techniques) will be updated so that calling <code>mergeTrees([treeA, treeA]);</code> simply returns <code>treeA</code>, and <code>mergeTrees([treeA, treeB, treeA])</code> removes the duplicated <code>treeA</code> in the input nodes.</li>
</ul>
<p>The proposed declaration for <code>Addon.prototype.cacheKeyForTree</code> in Typescript syntax is:</p>
<pre><code class="language-ts">function cacheKeyForTree(treeType: string): string;
</code></pre>
<p>The default implementation for <code>Addon.prototype.cacheKeyForTree</code> will:</p>
<ul>
<li>
<p>Utilize a shared NPM package (e.g. <code>calculate-cache-key-for-tree</code>) that will generate a cache key that incorporates at least the following pieces of information:</p>
<ul>
<li><code>this.name</code> - The addon's name (generally from <code>package.json</code>).</li>
<li><code>this.pkg</code> - This builds a checksum accounting for the addon's <code>package.json</code>.</li>
<li><code>treeType</code> - The specific tree in question (e.g. <code>addon</code>, <code>vendor</code>, <code>addonTestSupport</code>, <code>templates</code>, etc).</li>
</ul>
</li>
<li>
<p>Resort to disabling all addon tree caching in the following scenarios</p>
<ul>
<li>The addon implements a custom <code>treeFor</code></li>
<li>The addon implements a custom <code>treeFor*</code> method (where <code>*</code> represents the tree type)</li>
</ul>
</li>
</ul>
<p>Addons that implement custom <code>treeFor</code> or <code>treeFor*</code> methods can still opt-in to caching in scenarios that they can confirm are safe. To do this, they would implement a custom <code>cacheKeyForTree</code> method and return a cache key as appropriate for their caching needs.</p>
<a class="header" href="print.html#how-we-teach-this-3" id="how-we-teach-this-3"><h1>How We Teach This</h1></a>
<p>This is something that we do not expect 99% of ember-cli users to have to learn and understand, however it is still important for it to be possible to determine what is going on and how to work within the system when building addons.</p>
<p>The following should help us teach this to the correct audience (roughly &quot;addon power users&quot;):</p>
<ul>
<li>Document the shared NPM package (referred to above as <code>calculate-cache-key-for-tree</code>). This will help authors of addons that need to implement <code>treeFor*</code> hooks understand how they can properly implement <code>Addon.prototype.cacheKeyForTree</code>.</li>
<li>Write API docs for the newly added <code>Addon.prototype.cacheKeyForTree</code> method.</li>
</ul>
<a class="header" href="print.html#drawbacks-24" id="drawbacks-24"><h1>Drawbacks</h1></a>
<ul>
<li>Cache invalidation is difficult to get right, and it is possible to accidentally troll our users. This can be mitigated by thorough review of the implementation and this RFC.</li>
</ul>
<a class="header" href="print.html#alternatives-24" id="alternatives-24"><h1>Alternatives</h1></a>
<a class="header" href="print.html#unresolved-questions-22" id="unresolved-questions-22"><h1>Unresolved questions</h1></a>
<ul>
<li>Confirm if including the same tree multiple times will only trigger a single build of that tree (this should be a Broccoli feature). We have confirmed that code exists in broccoli-builder (<a href="https://github.com/ember-cli/broccoli-builder/blob/0-18-x/lib/builder.js#L89-L97">see here</a>), but still need to actually confirm <code>.build</code> / <code>.read</code> / <code>.rebuild</code> are not called twice within the same build.</li>
</ul>
<ul>
<li>Start Date: 2016-12-14</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/91">#91</a></li>
</ul>
<a class="header" href="print.html#summary-25" id="summary-25"><h1>Summary</h1></a>
<p>Add an instrumentation hook that is available to addons.  This enables users to
write addons that do things like summarize and report build performance
information.</p>
<ul>
<li>see https://github.com/ember-cli/ember-cli/issues/6349 for additional context.</li>
<li>see https://github.com/ember-cli/ember-cli/pull/6606 for an experimental
implementation.</li>
</ul>
<a class="header" href="print.html#motivation-26" id="motivation-26"><h1>Motivation</h1></a>
<p>Build performance is important to users.  We want to enable users to:</p>
<ol>
<li>Easily discover which portions of their build are costly;</li>
<li>Be able to summarize and report build information in an addon;</li>
<li>Be able to write addons that analyze build performance instrumentation so
that they can more easily help diagnose build performance issues in projects
to which they do not have direct access.  This is of particular interest to
@ember-cli/core &amp;c.</li>
</ol>
<p>In order to provide these hooks to enable iteration and experimentation prior to
making firm commitments to format, this rfc propose to initially expose them as
experiments (see the experiments section below).</p>
<a class="header" href="print.html#detailed-design-25" id="detailed-design-25"><h1>Detailed design</h1></a>
<a class="header" href="print.html#experiments" id="experiments"><h2>Experiments</h2></a>
<p>Experiments live in <code>lib/experiments/index.js</code>.  Unlike feature flags, there is
no need to strip them from production.  Experiments allow us to provide power
user features that are not fully stable without their resorting to private API
usage.</p>
<p>Experiments are available only in canary builds.  This is achieved by only
including <code>lib/experiements/index.js</code> in canary, and making it the entry point
for all experiments.</p>
<a class="header" href="print.html#instrumentation-hook" id="instrumentation-hook"><h2>Instrumentation Hook</h2></a>
<p>We have already a build instrumentation hook as an
experiment in https://github.com/ember-cli/ember-cli/pull/6546</p>
<p>A more encompassing instrumentation hook is implemented in
https://github.com/ember-cli/ember-cli/pull/6606</p>
<p>The goal of this RFC is:</p>
<ol>
<li>To make the concept of experiments supported and explicit</li>
<li>To promote this particular experiment to public API</li>
</ol>
<a class="header" href="print.html#enabling-instrumentation" id="enabling-instrumentation"><h3>Enabling Instrumentation</h3></a>
<p>Instrumentation is enabled if either the environment variable <code>BROCCOLI_VIZ</code> is
set to <code>1</code> or if <code>EMBER_CLI_INSTRUMENTATION</code> is set to <code>1</code>.</p>
<p>If <code>BROCCOLI_VIZ=1</code> then in addition to instrumentation hooks being invoked, a
serialized form of the instrumentation information is written to disk, that is
appropriate for consumption by <a href="https://github.com/ember-cli/broccoli-viz">broccoli-viz</a> which is the current behaviour.</p>
<a class="header" href="print.html#instrumentation" id="instrumentation"><h3>Instrumentation</h3></a>
<a class="header" href="print.html#hook" id="hook"><h4>Hook</h4></a>
<p>An addon that implements <code>instrumentation</code> will have this hook invoked when
instrumentation is enabled.</p>
<pre><code class="language-js">module.exports = {
  name: 'my-great-addon',

  instrumentation(name, payload) {
    // format of instrumentation payload outlined below
  }
};
</code></pre>
<a class="header" href="print.html#name" id="name"><h5>name</h5></a>
<p>The <code>name</code> argument indicates what phase the instrumentation payload describes.
In beta and released versions this will always be a string.</p>
<p>On canary it could be a symbol from <code>lib/experiments</code> if we add more phases (eg
more fine-grained phases) for instrumentation information.</p>
<p>The initial set of phases this RFC advocates are:</p>
<ul>
<li><code>init</code></li>
<li><code>command</code></li>
<li><code>build</code></li>
<li><code>shutdown</code></li>
</ul>
<a class="header" href="print.html#payload" id="payload"><h5>payload</h5></a>
<p><code>payload</code> is an object with two properties, <code>summary</code> and <code>graph</code>.</p>
<a class="header" href="print.html#payloadsummary" id="payloadsummary"><h5>payload.summary</h5></a>
<p>The exact format of <code>payload.summary</code> depends on the specific phase for which
the instrumentation hook was called.  In each case, the keys listed are the
minimum keys that are guaranteed to be present, but there is no guarantee that
additional information might not also be present.</p>
<a class="header" href="print.html#init" id="init"><h6>init</h6></a>
<p><code>init</code> covers the period up to, but not including, command execution.  This
means it's mostly dealing with <code>require</code> time.</p>
<p>For <code>init</code>, the summary object has the following shape.</p>
<pre><code class="language-js">{
  totalTime,
  platform: {
    name,
  },
}
</code></pre>
<ul>
<li><code>summary.totalTime</code> The total time spent during <code>init</code></li>
<li><code>summary.platform.name</code> The value of <code>process.platform</code></li>
</ul>
<a class="header" href="print.html#build" id="build"><h6>build</h6></a>
<p><code>build</code> covers the time spent in an individual build or rebuild.</p>
<p>For <code>build</code>, the summary object has the following shape.</p>
<pre><code class="language-js">{
  build: {
    type,
    count,
    outputChangedFiles

    // additional fields for rebuilds
    primaryFile,
    primaryFileCount,
    changedFiles
  },
  platform: {
    name,
  },
  output,
  totalTime,
  buildSteps,
}
</code></pre>
<ul>
<li><code>summary.build.type</code> one of <code>'initial'</code> or <code>'rebuild'</code></li>
<li><code>summary.build.count</code> the number of the build (0 for initial build, &gt; 0 for
rebuilds).</li>
<li><code>summary.build.outputChangedFiles</code> an array of paths to output files that
changed during this build.  These paths are relative to the <code>dist</code> directory.</li>
<li><code>summary.build.primaryFile</code> only present for rebuilds.  Indicates the first
file the watcher noticed had changed.</li>
<li><code>summary.build.changedFileCount</code> only present for rebuilds.  The number of
files the watcher had noticed changed before the build started.</li>
<li><code>summary.build.changedFiles</code> only present for rebuilds. The first 10 files
the watcher had noticed changed before the build started.</li>
<li><code>summary.platform.name</code> The value of <code>process.platform</code></li>
<li><code>summary.output</code> The temp directory containing the results of the build.</li>
<li><code>summary.totalTime</code> The total time (in nanoseconds) of the build.</li>
<li><code>summary.buildSteps</code> The number of broccoli nodes built in this tree</li>
</ul>
<a class="header" href="print.html#command" id="command"><h6>command</h6></a>
<p><code>command</code> covers the time spent during a command.  When the command includes a
build, there will be overlap between <code>command</code> and <code>build</code>.  When the command is
<code>serve</code>, this overlap will include only the last build, to avoid memory leaks.</p>
<p>For <code>command</code>, the summary object has the following shape.</p>
<pre><code class="language-js">{
  totalTime,
  platform: {
    name,
  },
  name,
  args
}
</code></pre>
<ul>
<li><code>summary.totalTime</code> The total time spent during <code>init</code></li>
<li><code>summary.platform.name</code> The value of <code>process.platform</code></li>
<li><code>summary.name</code> The name of the command that was run</li>
<li><code>summary.args</code> The args of the command that was run</li>
</ul>
<a class="header" href="print.html#shutdown" id="shutdown"><h6>shutdown</h6></a>
<p><code>shutdown</code> covers the period from the command completing to process exit, ie
cleanup time.</p>
<p>For <code>shutdown</code>, the summary object has the following shape.</p>
<pre><code class="language-js">{
  totalTime,
  platform: {
    name,
  },
}
</code></pre>
<ul>
<li><code>summary.totalTime</code> The total time spent during <code>init</code></li>
<li><code>summary.platform.name</code> The value of <code>process.platform</code></li>
</ul>
<a class="header" href="print.html#payloadgraph" id="payloadgraph"><h5>payload.graph</h5></a>
<p><code>graph</code> is an object that represents the instrumentation information we have
gathered for the build.  It is a DAG, whose flow is inverted from the broccoli
graph. It has a single source node (currently <code>TreeMerger (all trees)</code>).
<code>payload.graph</code> is this single source node.</p>
<p>Each node in the graph provides an API for iterating its subgraph as well as
iterating its own stats. The specific nodes in the graph will change over time as
the instrumentation within ember-cli changes.  There is no particular guarantee
about what the nodes will be, although we will continue to ensure that its
<code>toJSON</code> format is consumable by
<a href="https://github.com/ember-cli/broccoli-viz">broccoli-viz</a></p>
<p>The API that each node supports is:</p>
<ul>
<li><code>label</code></li>
<li><code>toJSON</code></li>
<li><code>adjacentIterator</code></li>
<li><code>dfsIterator</code></li>
<li><code>bfsIterator</code></li>
</ul>
<a class="header" href="print.html#label" id="label"><h6>label</h6></a>
<p>A POJO property that describes the node.  It will always include a <code>name</code>
property and for broccoli nodes will include a <code>broccoliNode</code> property.</p>
<p>Example:</p>
<pre><code class="language-js">node.label === {
  name: 'TreeMerger (allTrees)',
  broccoliNode: true,
}
</code></pre>
<a class="header" href="print.html#tojson" id="tojson"><h6>toJSON()</h6></a>
<p>Returns a POJO that represents the serialized subgraph rooted at this node (the
entire tree if called on the root node).</p>
<p>There is no particular guarantee about the format, except that whatever it is
will be supported by <a href="https://github.com/ember-cli/broccoli-viz">broccoli-viz</a>.</p>
<p>Example:</p>
<pre><code class="language-js">// for a graph
//  TreeMerger
//    |- Babel_1
//    |- Babel_2
//    |--|- Funnel
console.log(JSON.stringify(node.toJSON(), null, 2));
// might print
//
{
  nodes: [{
    id: 1,
    children: [2,3],
    stats: {
      time: {
        self: 5000000,
      },
      fs: {
        lstat: {
          count: 2,
          time: 2000000
        }
      },
      own: {
      }
    }
  }, {
    // ...
  }]
}
</code></pre>
<a class="header" href="print.html#adjacentiterator" id="adjacentiterator"><h6>adjacentIterator</h6></a>
<p>Returns an iterator that yields each adjacent outbound node.  There is no
guarantee about the order in which they are yielded.</p>
<pre><code class="language-js">// for a tree
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
node.label.name === &quot;TreeMerger&quot;;
for (n of node.adjacentIterator()) {
  console.log(n.label.name);
}
// prints
//
// Babel_1
// Babel_2


for (n of node.preOrderIterator(x =&gt; x.label.name === 'Babel_2')) {
  console.log(n.label.name);
}
// prints
//
//  TreeMerger
//  |- Babel_1
</code></pre>
<a class="header" href="print.html#dfsiteratoruntil" id="dfsiteratoruntil"><h6>dfsIterator(until)</h6></a>
<p>Returns an iterator that yields every node in the subgraph sourced at this node.
Nodes are yielded in depth-first order.  If the optional parameter <code>until</code> is
passed, nodes for which <code>until</code> returns <code>true</code> will not be yielded, nor will
nodes in their subgraph, unless those nodes are reachable by some other path.</p>
<p>Example:</p>
<pre><code class="language-js">// for a graph
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
for (n of node.dfsIterator()) {
  console.log(n.label.name);
}
// prints
//
// TreeMerger
// Babel_1
// Funnel
// Babel_2
</code></pre>
<a class="header" href="print.html#bfsiterator" id="bfsiterator"><h6>bfsIterator()</h6></a>
<p>Returns an iterator that yields every node in the subgraph sourced at this node.
Nodes are yielded in breadth-first order.  If the optional parameter <code>until</code> is
passed, nodes for which <code>until</code> returns <code>true</code> will not be yielded, nor will
nodes in their subgraph, unless those nodes are reachable by some other path.</p>
<p>Example:</p>
<pre><code class="language-js">// for a tree
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
for (n of node.bfsIterator()) {
  console.log(n.label.name);
}
// prints
//
// TreeMerger
// Babel_1
// Babel_2
// Funnel
</code></pre>
<a class="header" href="print.html#statsiterator" id="statsiterator"><h6>statsIterator()</h6></a>
<p>Returns an iterator that yields <code>[name, value]</code> pairs of stat names and values.</p>
<p>Example:</p>
<pre><code class="language-js">  //  for a typical broccoli node
  for ([statName, statValue] of node.statsIterator()) {
    console.log(statName, statValue);
  }
  // prints
  //
  // &quot;time.self&quot; 64232794
  // &quot;fs.statSync.count&quot; 40
  // &quot;fs.statSync.time&quot; 401232123
  // ...
</code></pre>
<a class="header" href="print.html#how-we-teach-this-4" id="how-we-teach-this-4"><h1>How We Teach This</h1></a>
<p>This has no effect on day-to-day usage of ember-CLI.  It is a tool to help users
monitor and analyze their build performance, so documentation and teaching
belong primarily in <code>PERF_GUIDE.md</code>.  Having said that, we should also add a
section to <code>https://ember-cli.com/extending/</code> and the API docs to make using
this feature easier for addon authors and CLI power users.</p>
<a class="header" href="print.html#drawbacks-25" id="drawbacks-25"><h1>Drawbacks</h1></a>
<ul>
<li>No drawbacks come to mind, besides the ever present issue of maintenance</li>
</ul>
<a class="header" href="print.html#alternatives-25" id="alternatives-25"><h1>Alternatives</h1></a>
<p>One alternative is the status quo: with <code>BROCCOLI_VIZ=1</code> users can output a file
with a similar format that they can post-process offline.  Although this works
for manual analysis, it is considerably more cumbersome for any automated system
(such as ongoing monitoring of build performance).  It also does not include
instrumentation outside of the build, most notably startup.</p>
<a class="header" href="print.html#unresolved-questions-23" id="unresolved-questions-23"><h1>Unresolved questions</h1></a>
<ul>
<li><a href="https://github.com/heimdalljs/heimdalljs-tree">heimdalljs-tree</a> supports
<code>Symbol.Iterator</code>; should we commit to this as part of our API?</li>
</ul>
<ul>
<li>Start Date: 2015-09-11</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/91</li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/pull/12224">#12224</a> / <a href="https://github.com/emberjs/ember.js/pull/12990">#12990</a> / <a href="https://github.com/emberjs/ember.js/pull/13688">#13688</a></li>
</ul>
<a class="header" href="print.html#summary-26" id="summary-26"><h1>Summary</h1></a>
<p>Introduce <code>Ember.WeakMap</code> (<code>@ember/weakmap</code>), an ES6 enspired WeakMap. A
WeakMap provides a mechanism for storing and retriving private state. The
WeakMap itself does not retain a reference to the state, allowing the state to
be reclaimed when the key is reclaimed.</p>
<p>A traditional WeakMap (and the one that will be part of the language) allows
for weakness from key -&gt; map, and also from map -&gt; key. This allows either the
Map, or the key being reclaimed to also release the state.</p>
<p>Unforunately, this bi-directional weakness is problemative to polyfil. Luckily,
uni-directional weakness, in either direction, &quot;just works&quot;. A polyfil must
just choose a direction.</p>
<p><em>Note: Just like ES2015 WeakMap, only non null Objects can be used as keys</em>
<em>Note: <code>Ember.WeakMap</code> can be used interchangibly with the ES2015 WeakMap. This
will allow us to eventually cut over entirely to the Native WeakMap.</em></p>
<a class="header" href="print.html#motivation-27" id="motivation-27"><h1>Motivation</h1></a>
<p>It is a common pattern to want to store private state about a specific object.
When one stores this private state off-object, it can be tricky to understand
when to release the state. When one stores this state on-object, it will be
released when the object is released. Unfortunately, storing the state
on-object without poluting the object itself is non-obvious.</p>
<p>As it turns out, Ember's Meta already solves this problem for
listeners/caches/chains/descriptors etc. Unfortunately today, there is no
public API for apps or addons to utilize this. <code>Ember.WeakMap</code> aims to be
exactly that API.</p>
<p>Some examples:</p>
<ul>
<li>https://github.com/offirgolan/ember-cp-validations/blob/master/addon/utils/cycle-breaker.js</li>
<li>https://github.com/stefanpenner/ember-state-services/ (will soon utilize the user-land polyfil of this) to prevent common leaks.</li>
</ul>
<a class="header" href="print.html#detailed-design-26" id="detailed-design-26"><h1>Detailed design</h1></a>
<a class="header" href="print.html#public-api-1" id="public-api-1"><h2>Public API</h2></a>
<pre><code class="language-js">import WeakMap from '@ember/weak-map'

var private = new WeakMap();
var object = {};
var otherObject = {};

private.set(object, {
  id: 1,
  name: 'My File',
  progress: 0
}) === private;

private.get(object) === {
  id: 1,
  name: 'My File',
  progress: 0
});


private.has(object) === true;
private.has(otherObject) === false;

private.delete(object) === private;
private.has(object) === false;
</code></pre>
<a class="header" href="print.html#implementation-details-1" id="implementation-details-1"><h2>Implementation Details</h2></a>
<p>The backing store for <code>Ember.WeakMap</code> will reside in a lazy <code>ownMap</code> named
<code>weak</code> on the key objects <code>__meta__</code> object.</p>
<p>Each <code>WeakMap</code> has its own internal GUID, which will be the name of its slot,
in the key objects meta weak bucket. This will allow one object to belong in
multiple weakMaps without chance of collision.</p>
<p>Concrete Implementation: https://github.com/emberjs/ember.js/pull/12224
Polyfill: https://www.npmjs.com/package/ember-weakmap</p>
<a class="header" href="print.html#drawbacks-26" id="drawbacks-26"><h1>Drawbacks</h1></a>
<ul>
<li>implementing bi-direction Weakness in userland is problematic.</li>
<li>Using WeakMap will insert a non-enumerable <code>meta</code> onto the key Object.</li>
</ul>
<a class="header" href="print.html#alternatives-26" id="alternatives-26"><h1>Alternatives</h1></a>
<ul>
<li>Weakness could be implemented in the other direction, but this has questionable utility.</li>
</ul>
<a class="header" href="print.html#unresolved-questions-24" id="unresolved-questions-24"><h1>Unresolved questions</h1></a>
<p>N/A</p>
<ul>
<li>Start Date: 2016-12-17</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/92">#92</a></li>
</ul>
<a class="header" href="print.html#summary-27" id="summary-27"><h1>Summary</h1></a>
<p>Give blueprint generators the ability to clean up old files.</p>
<a class="header" href="print.html#motivation-28" id="motivation-28"><h1>Motivation</h1></a>
<p>We want to eliminate the noise of having old files laying after updating
ember-cli using <code>ember init</code>.</p>
<a class="header" href="print.html#detailed-design-27" id="detailed-design-27"><h1>Detailed design</h1></a>
<p>We'd like an API for blueprints to delete files instead of only
create. It would be essentially syntactic sugar for removing the file yourself
in an <code>afterInstall</code> hook. It would be a returned array on the blueprint's <code>index.js</code>.</p>
<pre><code class="language-js">// ember-cli/bluprints/blah/index.js
module.exports = {
  // ...

  get oldFilesToRemove() {
    return [
      'brocfile.js',
      'LICENSE.MD',
      'testem.json'
    ];
  }
};
</code></pre>
<a class="header" href="print.html#how-we-teach-this-5" id="how-we-teach-this-5"><h1>How We Teach This</h1></a>
<p>The guides could use this addition in the blueprints section, but I envision it
being used by mostly power users.</p>
<p>A changelog entry should be sufficient to teach this.</p>
<a class="header" href="print.html#drawbacks-27" id="drawbacks-27"><h1>Drawbacks</h1></a>
<p>The only reason to not do this is to hold out for a large blueprint reworking.
We would be locked into this API.</p>
<a class="header" href="print.html#alternatives-27" id="alternatives-27"><h1>Alternatives</h1></a>
<p>The key name can be bikeshed. I chose <code>oldFilesToRemove</code> to be verbose and
explicit, but it can be changed.</p>
<ul>
<li>Start Date: 2017-01-03</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/95">#95</a></li>
</ul>
<a class="header" href="print.html#summary-28" id="summary-28"><h1>Summary</h1></a>
<p>This RFC proposes the introduction of a official convention to specify the target browsers
and node versions of an application.</p>
<a class="header" href="print.html#motivation-29" id="motivation-29"><h1>Motivation</h1></a>
<p>Javascript and the platforms it runs on are moving targets. NodeJS and browsers release new
versions every few weeks. Browsers auto update and each update brings new language features
and APIs.</p>
<p>Developers need an easy way to express intention that abstracts them from the ever-changing
landscape of versions and feature matrices, so this RFC proposes the introduction of a unique
place and syntax to let developers express their intended targets that all addons can use,
instead of having each addon define it in a different way.</p>
<p>This configuration should be easily available to addons, but this RFC doesn't impose
any mandatory behavior on those addons. All addons that want to customize their behavior
depending on the target browsers will have a single source of truth to get that
information but it's up to them how to use it.</p>
<p>The advantage of having a single source of truth for the targets compared to configure this
on a per-addon basis like we do today is mostly for better ergonomics and across-the-board
consistency.</p>
<p>Examples of addons that would benefit from this conventions are <code>babel-preset-env</code>, <code>autoprefixer</code>,
<code>stylelint</code> and <code>eslint</code> (vía <code>eslint-plugin-compat</code>) and more. Even Ember itself could,
once converted into an addon, take advantage of that to avoid polyfilling or even taking
advantage of some DOM API (<code>node.classList</code>?) deep in Glimmer's internals, helping the goal
of Svelte Builds.</p>
<a class="header" href="print.html#detailed-design-28" id="detailed-design-28"><h1>Detailed design</h1></a>
<p>What seems to be the most popular tool and the state of the art on building suport matrices
for browser targets is the <a href="https://github.com/ai/browserslist">browserlist</a> npm package.</p>
<p>That package is the one behind <code>babel-preset-env</code>, <code>autoprefixer</code> and others, and uses the data from
<a href="http://caniuse.com/">Can I Use</a> for knowing the JS, CSS and other APIs available on every browser.</p>
<p>The syntax of this package is natural but also pretty flexible, allowing complex
queries like <code>Firefox &gt;= 20</code>, <code>&gt;2.5% in CA</code> (browsers with a market share over 2.5% in Canada)
and logical combinations of the previous.</p>
<p>The way this library work is by calculating the minimum common denominator support on a per-feature basis.</p>
<p>Per example, if the support matrix for an app is <code>['IE11', 'Firefox latest']</code> and we have a linter
that warns us when we use an unsupported browser API, it would warn us if we try to use
pointer events (supported in IE11 but not in Firefox), would warn us also when using <code>fetch</code> (supported
in firefox but not in IE) and would not warn us when using <code>MutationObserver</code> because it is supported by both.</p>
<p>This library is very powerful and popular, making relatively easy to integrate with a good amount of
tools that already use it with low effort.</p>
<p>This configuration must be made available to addons but it's up to the addon authors to take advantage
of it.</p>
<a class="header" href="print.html#browser-support" id="browser-support"><h3>Browser support</h3></a>
<p>The configution of target browsers must be placed in a file that allows javascript execution and exports an object
with the configuration. The reason to prefer a javascript file over a JSON one is to allow users to
dinamically generate different config depending on things like the environment they are building the app in or
any other environment variable.</p>
<p>One possible location for this configuration is the <code>.ember-cli</code> file.
A new dedicated named <code>/config/targets.js</code> also seems a good option, similar way how addons use <code>config/ember-try.js</code>
to configure the test version matrix.</p>
<p>Ember CLI will require this file when building the app and make the configuration available to addons
in a <code>this.project.targets</code> property.</p>
<p>This <code>targets</code> object contains a getter named <code>browsers</code> that returns the provided configuration or the default
one if the user didn't provide any.</p>
<p>Example usage:</p>
<pre><code class="language-js">module.exports = {
  name: 'ember-data',

  included(app) {
    this._super.included.apply(this, arguments);

    console.log(this.project.targets.browsers); // ['&gt;2%', 'last 3 iOS versions', 'not ie &lt;= 8']
  }
};
</code></pre>
<p>This <code>targets</code> object can, and probably will, be expanded in the future with new properties
for different kind of targets, like cordoba apps or fastboot, but that will be
done in a different RFC.</p>
<a class="header" href="print.html#how-we-teach-this-6" id="how-we-teach-this-6"><h1>How We Teach This</h1></a>
<p>This is a new concept in Ember CLI, so guides will have to be updated to explain this
concept. The good part is that this new concept can help enforcing with tools a task were
traditionally enforced only with peer reviews.</p>
<p>To ease the transition Ember CLI can also, in the absence of a specific value provided by the user,
default to a predefined matrix of browsers that matches the browsers officially supported by the framework.</p>
<p>As of today, the supported browser list for Ember.js, according to the platforms we test in saucelabs, is:</p>
<p><code>['IE9', 'Chrome current', 'Safari current', 'Firefox current']</code></p>
<p>There is no mention to IOS/Android, so this must be validated still.</p>
<a class="header" href="print.html#drawbacks-28" id="drawbacks-28"><h1>Drawbacks</h1></a>
<p>While this RFC standardizes a concept that will open the door to better and more comprehensive tooling,
it makes us choose one syntax (the one used by <a href="https://github.com/ai/browserslist">browserlist</a>) over
any other perhaps superior choice that may exist or appear in the future.</p>
<a class="header" href="print.html#alternatives-28" id="alternatives-28"><h1>Alternatives</h1></a>
<p>Let every addon that wants to deal with targets to have a <code>targets</code>-like option in its configuration
instead of standardizing a single configuration option, which effectively leaves things as they are
right now.</p>
<p>Example:</p>
<pre><code>var app = new EmberApp(defaults, {
  'ember-cli-autoprefixer': {
    browsers: ...
  },
  'ember-cli-babel': {
    targets: ...
  },
  'ember-cli-eslint': {
    engines: ...
  },
  ...
});
</code></pre>
<a class="header" href="print.html#unresolved-questions-25" id="unresolved-questions-25"><h1>Unresolved questions</h1></a>
<p>The proposed syntax for node only supports a single version of node. Is it reasonable to
make this property an array of versions? P.e. <code>[&quot;4.4&quot;, &quot;6&quot;, &quot;7&quot;]</code></p>
<ul>
<li>Start Date: 2015-09-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/95</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/14805</li>
</ul>
<a class="header" href="print.html#summary-29" id="summary-29"><h1>Summary</h1></a>
<p>This RFC proposes:</p>
<ul>
<li>
<p>creating a public <code>router</code> service that is a superset of today's <code>Ember.Router</code>.</p>
</li>
<li>
<p>codifying and expanding the supported public API for the <code>transition</code> object that is currently passed to <code>Route</code> hooks.</p>
</li>
<li>
<p>introducing the <code>get-route-info</code> template helper</p>
</li>
<li>
<p>introducing the <code>#with-route-info</code> template keyword</p>
</li>
<li>
<p>introducing the <code>readsRouteInfo</code> static property on <code>Component</code> and <code>Helper</code>.</p>
</li>
</ul>
<p>These topics are closely related because they share a unified <code>RouteInfo</code> type, which will be described in detail.</p>
<a class="header" href="print.html#motivation-30" id="motivation-30"><h1>Motivation</h1></a>
<p>Given the modern Ember concepts of Components and Services, it is clear that routing capability should be exposed as a Service. I hope this is uncontroversial, given that we already implement it as a service internally, and given that usage of these nominally-private APIs is already becoming widespread.</p>
<p>The immediate benefit of having a <code>RouterService</code> is that you can inject it into components, giving them a friendly way to initiate transitions and ask questions about the current global router state.</p>
<p>A second benefit is that we have the opportunity to add new capabilities to the <code>RouterService</code> to replace several common patterns in the wild that dive into private internals in order to get things done. There are several places where we leak internals from router.js, and we can plug those leaks.</p>
<p>A <code>RouterService</code> is great for asking global questions, but some questions are not global and today we incur complexity by treating them as if they are. For example:</p>
<ul>
<li>
<p><code>{{link-to}}</code> can use implicit models from its context, but that breaks when you're trying to animate to or from a state where those models are not present.</p>
</li>
<li>
<p><code>{{link-to}}</code> has a lot of complexity and performance cost that deals with changing its active state, and the precise timing of when that should happen.</p>
</li>
<li>
<p>there is no way to ask the router what it would do to handle a given URL without actually visiting that URL.</p>
</li>
</ul>
<p>All of the above can be addressed by embracing what is already internally true: &quot;the current route&quot; is not a single global, it's a dynamically-scoped variable that can have different values in different parts of the application simultaneously.</p>
<a class="header" href="print.html#detailed-design-29" id="detailed-design-29"><h1>Detailed design</h1></a>
<a class="header" href="print.html#routerservice" id="routerservice"><h2>RouterService</h2></a>
<p>By way of a simple example, the router service behaves like this:</p>
<pre><code class="language-js">import Component from 'ember-component';
import service from 'ember-service/inject';

export default Component.extend({
  router: service(),
  actions: {
    goToMars() {
      this.get('router').transitionTo('planet.mars');
    }
  }
});
</code></pre>
<p>Like any Service, it can also be injected into Helpers, Routes, etc.</p>
<a class="header" href="print.html#relationship-between-emberrouter-and-routerservice" id="relationship-between-emberrouter-and-routerservice"><h3>Relationship between EmberRouter and RouterService</h3></a>
<p>Q: &quot;Why are you calling this thing 'router' when we already have a router? Shouldn't the new thing be called 'routing' or something else?&quot;.</p>
<p>A: We shouldn't have two things. From the user's perspective, there is just &quot;the router&quot;, and it happens to be available as a service. While we're free to continue implementing it as multiple classes under the hood, the public API should present as a single, coherent concept.</p>
<p>Terminology:</p>
<ul>
<li><code>EmberRouter</code> is the class that we already have today, defined in <code>ember-routing/system/router</code> and available publicly as <code>Ember.Router</code></li>
<li><code>RouterService</code> is the new class I am proposing.</li>
</ul>
<p><code>EmberRouter</code> has the following public API today:</p>
<ul>
<li><code>map</code></li>
<li><code>location</code></li>
<li><code>rootURL</code></li>
<li><code>willTransition</code></li>
<li><code>didTransition</code></li>
</ul>
<p>That API will be carried over verbatim to <code>RouterService</code>, and the publicly accessible <code>Ember.Router</code> class will <em>become</em> <code>RouterService</code>. In terms of implementation, I expect the existing <code>EmberRouter</code> class will continue to exist mostly unchanged. But public access to it will be moderated through <code>RouterService</code>.</p>
<a class="header" href="print.html#new-methods-initiating-transitions" id="new-methods-initiating-transitions"><h3>New Methods: Initiating Transitions</h3></a>
<pre><code class="language-js">transitionTo(routeName, ...models, queryParams)
replaceWith(routeName, ...models, queryParams)
</code></pre>
<p>These two have the same semantics as the existing methods on <code>Ember.Route</code>:</p>
<a class="header" href="print.html#new-method-checking-for-active-route" id="new-method-checking-for-active-route"><h3>New Method: Checking For Active Route</h3></a>
<ul>
<li><code>isActive(routeName, ...models, queryParams)</code></li>
</ul>
<p>The arguments have the same semantics as <code>transitionTo</code>, the return value is a boolean. This should provide the same logic that determines whether to put an active class on a <code>link-to</code>. Here's an example of how we can implement <code>is-active</code> as a helper, using this method:</p>
<pre><code class="language-js">import Helper from 'ember-helper';
import service from 'ember-service/inject';
import observer from 'ember-metal/observer';

export default Helper.extend({
  router: service(),
  compute([routeName, ...models], hash) {
    let allModels;
    if (hash.models) {
      allModels = models.concat(hash.models);
    } else {
      allModels = models;
    }
    return this.get('router').isActive(routeName, ...allModels, hash.queryParams);
  },
  didTransition: observer('router.currentRoute', function() {
    this.recompute();
  })
});
</code></pre>
<pre><code class="language-hbs">{{!- Example usage -}}
&lt;li class={{if (is-active &quot;person.detail&quot; model) 'chosen'}} &gt;

{{!- Example usage with generic routeName and list of models (avoids splat) -}}
&lt;a class={{if (is-active routeName models=models) 'chosen'}} &gt;

{{!- Note that the complexities of currentWhen can be avoided by composing instead. }}
&lt;a class={{if (or (is-active 'one') (is-active 'two')) 'active'}} href={{url-for 'two'}} &gt;

</code></pre>
<a class="header" href="print.html#new-method-url-generation" id="new-method-url-generation"><h3>New Method: URL generation</h3></a>
<p><code>urlFor(routeName, ...models, queryParams)</code></p>
<p>This takes the same arguments as <code>transitionTo</code>, but instead of initiating the transition it returns the resulting root-relative URL as a string (which will include the application's <code>rootUrl</code>).</p>
<p>A <code>url-for</code> helper can be implemented almost identically to the <code>is-active</code> example above.</p>
<a class="header" href="print.html#new-method-url-recognition" id="new-method-url-recognition"><h3>New Method: URL recognition</h3></a>
<p><code>recognize(url)</code></p>
<p>Takes a string URL and returns a <code>RouteInfo</code> for the leafmost route represented by the URL. Returns <code>null</code> if the URL is not recognized. This method expects to receive the actual URL as seen by the browser <em>including</em> the app's <code>rootURL</code>.</p>
<p>Example: this feature can replace <a href="https://github.com/intercom/ember-href-to/blob/b8cf0699eec6a65570b05e4fc22b27d8cea49c42/app/instance-initializers/browser/ember-href-to.js#L34">this use of private API in ember-href-to</a>.</p>
<a class="header" href="print.html#new-method-recognize-and-load-models" id="new-method-recognize-and-load-models"><h3>New Method: Recognize and load models</h3></a>
<p><code>recognizeAndLoad(url)</code></p>
<p>Takes a string URL and returns a promise that resolves to a <code>RouteInfoWithAttributes</code> for the leafmost route represented by the URL. The promise rejects if the URL is not recognized or an unhandled exception is encountered. This method expects to receive the actual URL as seen by the browser <em>including</em> the app's <code>rootURL</code>.</p>
<a class="header" href="print.html#deprecating-willtransition-and-didtransition" id="deprecating-willtransition-and-didtransition"><h3>Deprecating willTransition and didTransition</h3></a>
<p>Application-wide transition monitoring events belong on the Router service, not spread throughout the Route classes. That is the reason for the existing <code>willTransition</code> and <code>didTransition</code> hooks/events on the Router. But they are not sufficient to capture all the detail people need. See for example, https://github.com/nickiaconis/rfcs/blob/1bd98ec534441a38f62a48599ffa8a63551b785f/text/0000-transition-hooks-events.md</p>
<p>In addition, they receive handlerInfos in their arguments, which are an undocumented internal implementation detail of router.js that doesn't belong in Ember's public API. Everything you can do with handlerInfos can be done with the RouteInfo type that is proposed in this RFC, with the benefit of sticking to supported public API.</p>
<p>So we should deprecate willTransition and didTransition in favor of the following new events.</p>
<a class="header" href="print.html#new-events-routewillchange--routedidchange" id="new-events-routewillchange--routedidchange"><h3>New Events: routeWillChange &amp; routeDidChange</h3></a>
<p>The <code>routeWillChange</code> event fires whenever a new route is chosen as the desired target of a transition. This includes <code>transitionTo</code>, <code>replaceWith</code>, all redirection for any reason including error handling, and abort. Aborting implies changing the desired target back to where you already were. Once a transition has completed, <code>routeDidChange</code> fires.</p>
<p>Both events receive a single <code>transition</code> argument as described in the &quot;Transition Object&quot; section below, which explains the meaning of <code>from</code> and <code>to</code> in more detail.</p>
<p>Redirection example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>B redirects to C</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> C.</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> C.</li>
</ol>
<p>Abort example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>in response to the previous routeWillChange event, the transition is aborted.</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> A.</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> A.</li>
</ol>
<p>Error example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B.index</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>B throws an exception, and the router discovers a &quot;B-error&quot; template.</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B-error</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> B-error</li>
</ol>
<p>These are events, not extension hooks -- now that we are exposing a Service, it makes more sense to subscribe to its events than extend it.</p>
<a class="header" href="print.html#new-properties" id="new-properties"><h3>New Properties</h3></a>
<p><code>currentRoute</code>: an observable property. It is guaranteed to change whenever a route transition happens (even when that transition only changes parameters and doesn't change the active route). You should consider its value deeply immutable -- we will replace the whole structure whenever it changes. The value of <code>currentRoute</code> is a <code>RouteInfo</code> representing the current leaf route. <code>RouteInfo</code> is described below.</p>
<p><code>currentRouteName</code>:  a convenient alias for <code>currentRoute.name</code>.</p>
<p><code>currentURL</code>: provides the serialized string representing <code>currentRoute</code>.</p>
<a class="header" href="print.html#query-parameter-semantics" id="query-parameter-semantics"><h3>Query Parameter Semantics</h3></a>
<p>Today, <code>queryParams</code> impose unnecessarily high cost because we cannot generate URLs or determine if a link is active without taking into account the default values of query parameters. Determining their default values is expensive, because it involves instantiating the corresponding controller, even in cases where we will never visit its route.</p>
<p>Therefore, the <code>queryParams</code> argument to the new <code>urlFor</code>, <code>transitionTo</code>, <code>replaceWith</code>, and <code>isActive</code> methods defined in this document will behave differently.</p>
<ul>
<li>
<p>default values will not be stripped from generated URLs. For example, <code>urlFor('my-route', { sortBy: 'title' })</code> will always include <code>?sortBy=title</code>, whether or not <code>title</code> is the default value of <code>sortBy</code>.</p>
</li>
<li>
<p>to explicitly unset a query parameter, you can pass the symbol <code>Ember.DEFAULT_VALUE</code> as its value. For example, <code>transitionTo('my-route', { sortBy: Ember.DEFAULT_VALUE })</code> will result in a URL that does not contain any <code>?sortBy=</code>.</p>
</li>
</ul>
<p>(Sticky parameters are still allowed, because they only apply when the destination controller has already been instantiated anyway.)</p>
<a class="header" href="print.html#routeinfo-type" id="routeinfo-type"><h2>RouteInfo Type</h2></a>
<p>A RouteInfo object has the following properties. They are all read-only.</p>
<ul>
<li>name: the dot-separated, fully-qualified name of this route, like <code>&quot;people.index&quot;</code>.</li>
<li>localName: the final part of the <code>name</code>, like <code>&quot;index&quot;</code>.</li>
<li>params: the values of this route's parameters. Same as the argument to <code>Route</code>'s <code>model</code> hook. Contains only the parameters valid for this route, if any (params for parent or child routes are not merged).</li>
<li>paramNames: ordered list of the names of the params required for this route. It will contain the same strings as <code>Object.keys(params)</code>, but here the order is significant. This allows users to correctly pass params into routes programmatically.</li>
<li>queryParams: the values of any queryParams on this route.</li>
<li>parent: another RouteInfo instance, describing this route's parent route, if any.</li>
<li>child: another RouteInfo instance, describing this route's active child route, if any.</li>
</ul>
<p>Notice that the <code>parent</code> and <code>child</code> properties cause <code>RouteInfos</code> to form a linked list. So even though the <code>currentRoute</code> property on <code>RouterService</code> points at the leafmost route, it can be traversed to discover everything about all active routes. As a convenience, <code>RouteInfo</code> also implements <code>Enumerable</code> over all the reachable <code>RouteInfos</code> from topmost to leafmost. This makes it possible to say things like:</p>
<pre><code class="language-js">router.currentRoute.find(info =&gt; info.name === 'people').params
</code></pre>
<a class="header" href="print.html#routeinfowithattributes" id="routeinfowithattributes"><h2>RouteInfoWithAttributes</h2></a>
<p>This type is almost identical to <code>RouteInfo</code>, except it has one additional property named <code>attributes</code>. The attributes contain the data that was loaded for this route, which is typically just <code>{ model }</code>.</p>
<a class="header" href="print.html#transition-object" id="transition-object"><h2>Transition Object</h2></a>
<p>A <code>transition</code> argument is passed to <code>Route#beforeModel</code>, <code>Route#model</code>, <code>Route#afterModel</code>, <code>Route#willTransition</code>, and <code>Router#willTransition</code>. Today <code>transition</code>'s public API is only really <code>abort()</code> and <code>retry()</code>.</p>
<a class="header" href="print.html#new-properties-from-and-to" id="new-properties-from-and-to"><h3>New Properties: <code>from</code> and <code>to</code></h3></a>
<p>I'm proposing we add <code>from</code> and <code>to</code> properties on <code>transition</code> whose values are <code>RouteInfo</code> instances representing the initial and final leafmost routes for this transition. Like all RouteInfos, these are read-only and internally immutable. They are not observable, because a  <code>transition</code> instance is never changed after creation.</p>
<p>On an initial full-page load, the <code>from</code> property will be <code>null</code>. This creates a public API for distinguishing in-app transitions from full-page reloads.</p>
<a class="header" href="print.html#example-testing-whether-route-will-remain-active" id="example-testing-whether-route-will-remain-active"><h3>Example: testing whether route will remain active</h3></a>
<p>Here's an example showing how <code>willTransition</code> can figure out if the current route will remain active after the transition:</p>
<pre><code class="language-js">willTransition(transition) {
  if (!this.transition.to.find(route =&gt; route.name === this.routeName)) {
    alert(&quot;Please save or cancel your changes.&quot;);
    transition.abort();
  }
}
</code></pre>
<a class="header" href="print.html#example-parent-redirecting-to-a-fallback-model" id="example-parent-redirecting-to-a-fallback-model"><h3>Example: parent redirecting to a fallback model</h3></a>
<p>Here's an example of a parent route that can redirect to a fallback model, without losing its child route:</p>
<pre><code class="language-js">this.route('person', { path: '/person/:person_id' }, function() {
  this.route('index');
  this.route('detail');
});

//PersonRoute
const fallbackPersonId = 0;
model({ personId }, transition) {
  return this.get('store').find('person', personId).catch(err =&gt; {
    this.replaceWith(transition.to.name, fallbackPersonId);
  });
}

// If personId 5 is invalid, and the user visits /person/5/detail, they will get
// redirected to /person/0/detail. And /person/5 will get redirected to /person/0.
</code></pre>
<a class="header" href="print.html#actively-discourage-use-of-private-api" id="actively-discourage-use-of-private-api"><h3>Actively discourage use of private API</h3></a>
<p>This RFC provides public API for doing the things people have become accustomed to doing via private API. To eliminate confusion over the correct way, we should hide all the private API away behind symbols, and provide deprecation warnings per our usual release policy around breaking &quot;widely-used private APIs&quot;.</p>
<p>Some of the private APIs we should mark and warn include:</p>
<ul>
<li>transition.state</li>
<li>transition.params</li>
<li><code>lookup('router:main')</code> (should use <code>service:router</code> instead)</li>
</ul>
<a class="header" href="print.html#dynamically-scoped-route-info" id="dynamically-scoped-route-info"><h2>Dynamically-Scoped Route Info</h2></a>
<p>&quot;The current route&quot; is not a global value -- it varies from place to place within an application. Internally, Ember already models route info as a dynamically-scoped variable (currently named <code>outletState</code>). This RFC proposes publicly exposing that value in order to make things like <code>link-to</code> easier to implement directly on public primitives, and in order to enable stable public API for addons usage like <code>{{liquid-outlet}}</code>.</p>
<p>We propose <code>get-route-info</code> for reading the current route info in handlebars:</p>
<pre><code class="language-hbs">{{!- retrieve the value of a dynamically scoped variable }}
{{some-component currentRoute=(get-route-info)}}
</code></pre>
<p>We propose <code>readsRouteInfo</code> for defining a component that reads route info:</p>
<pre><code class="language-js">let MyComponent = Ember.Component.extend({
  didInsertElement() {
    // Accessing routInfo here is intended to be indistinguishable
    // from a normal, explicitly-passed input argument. 
    doSomethingWith(this.get('routeInfo'));
  }
});
MyComponent.reopenClass({
  // This is where we declare that we need access to routeInfo
  readsRouteInfo: true
});
</code></pre>
<p>And <code>readsRouteInfo</code> also works on <code>Helper</code>:</p>
<pre><code class="language-js">let MyHelper = Ember.Helper.extend({
  compute(params, hash) {
    // routeInfo is indistinguishable from a normally-passed hash argument
    return doSomethingWith(hash.routeInfo);
  }
});
MyHelper.reopenClass({
  readsRouteInfo: true
});
</code></pre>
<p>We propose the <code>#with-route-info</code> keyword for setting a new route info:</p>
<pre><code class="language-hbs">{{#with-route-info someValue}}
  {{!-
    within this block AND ALL ITS DESCENDANTS until
    otherwise overridden by another set-route-info statement, 
    `get-route-info` returns someValue.
  -}}
{{/with-route-info}}
</code></pre>
<p>Note that there is no <code>set-route-info</code>. You can only introduce new scopes, not mutate your containing scope. There is also no way to set routeInfo directly from Javascript -- your component must use a <code>with-route-info</code> block within its handlebars template.</p>
<a class="header" href="print.html#routeinfos-type-and-examples" id="routeinfos-type-and-examples"><h3>routeInfo's type, and examples</h3></a>
<p>The value returned from <code>get-route-info</code> and acceptd by <code>with-route-info</code> is always a <code>RouteInfoWithAttributes</code> object. This enables several nice things, which I will illustrate with examples:</p>
<ol>
<li>Here is a simplified <code>is-active</code> helper that will always update at the appropriate time to match exactly what is rendered in the current outlet. It will maintain the correct state even during animations. Instead of injecting the router service, it consumes the <code>routeInfo</code> from its containing environment:</li>
</ol>
<pre><code class="language-js">Ember.Helper.extend({
  compute([routeName], { routeInfo }) {
    return !!routeInfo.find(info =&gt; info.name === routeName);
  }
}).reopenClass({
  readsRouteInfo: true
});
</code></pre>
<p>A more complete version that also matches models and queryParams can be written in the same way.</p>
<ol start="2">
<li>
<p>We can improve <code>link-to</code> so that it always finds implicit model arguments from the local context, rather than trying to locate them on the global router service. This will fix longstanding bugs like https://github.com/ember-animation/liquid-fire/issues/347 and it will make it easier to test components that contain <code>{{link-to}}</code>. This would also open the door to relative link-tos.</p>
</li>
<li>
<p><code>liquid-outlet</code> can be implemented entirely via public API. It would become:</p>
</li>
</ol>
<pre><code class="language-hbs">{{#liquid-bind (get-route-info) as |currentRouteInfo|}}
  {{#with-route-info currentRouteInfo}}
    {{outlet}}
  {{/with-route-info}}
{{/liquid-bind}}
</code></pre>
<ol start="4">
<li>Prerendering of non-current routes becomes possible. You can use <code>recognizeAndLoad</code> to obtain a <code>RouteInfoWithAttributes</code> and then use <code>{{#with-route-info myRouteInfo}} {{outlet}} {{/with-route-info}}</code> to render it.</li>
</ol>
<a class="header" href="print.html#drawbacks-29" id="drawbacks-29"><h1>Drawbacks</h1></a>
<p>This RFC deprecates only two public extension hooks API, so the API-churn burden may appear low. However, we know that use of the private APIs we're deliberately disabling is widespread, so users will experience churn. We can provide our usual deprecation cycle to give them early warning, but it still imposes some cost.</p>
<p>This RFC doesn't attempt to change the existing and fairly rich semantics for initiating transitions. For example, you can pass either models or IDs, and those have subtle semantic differences. I think an ideal rewrite would also change the semantics of the route hooks and transitionTo to simplify that area.</p>
<a class="header" href="print.html#alternatives-29" id="alternatives-29"><h1>Alternatives</h1></a>
<a class="header" href="print.html#less-churn" id="less-churn"><h2>Less Churn</h2></a>
<p>We could adopt some of the existing broadly used APIs as de-facto public. This avoids churn, but imposes a complexity burden on every new learner, who needs to be told &quot;this is a weird API, but it's what we're stuck with&quot;.</p>
<a class="header" href="print.html#semver-lawyering" id="semver-lawyering"><h2>Semver Lawyering</h2></a>
<p>I'm interpreting router.js's public/private documentation as out-of-scope for Ember's semver. The fact that we pass an instance of router.js's Transition as our <code>transition</code> argument is not documented. An alternative interpretation is that we need to continue supporting those methods marked as public in router.js's docs.</p>
<a class="header" href="print.html#optional-helpers" id="optional-helpers"><h2>Optional Helpers</h2></a>
<p>I didn't propose shipping <code>is-active</code> and <code>url-for</code> template helpers -- I merely showed that they're easy to build using the router service. But we should arguably just ship them as part of the framework too.</p>
<a class="header" href="print.html#branching-route-hierarchies" id="branching-route-hierarchies"><h2>Branching Route Hierarchies</h2></a>
<p>I am implicitly assuming we will only ever have linear route hierarchies, where a given route has at most one child. I can imagine eventually wanting a way to support branching route hierarchies, where each branch can transition independently. I'm not trying to account for that future.</p>
<a class="header" href="print.html#routeparentroute" id="routeparentroute"><h2>Route.parentRoute</h2></a>
<p>This RFC makes it possible for a route to determine its parent's name dynamically via public API, and thus access its parent's model/params/controller:</p>
<pre><code class="language-js">beforeModel(transition) {
  const parentInfo = transition.to.find(info =&gt; info.name === this.routeName).parent;
  const parentModel = this.modelFor(parentInfo.name);
}
</code></pre>
<p>However, this pattern feels awkward, and I think it justifies just adding a public <code>parentRouteName()</code> method to <code>Route</code> that would simplify to:</p>
<pre><code class="language-js">beforeModel(transition) {
  const parentModel = this.modelFor(this.parentRouteName());
}
</code></pre>
<p>Possibly we <em>want</em> this to feel awkward because it's a weird thing to do.</p>
<a class="header" href="print.html#naming-of-emberdefault_value-symbol" id="naming-of-emberdefault_value-symbol"><h2>Naming of Ember.DEFAULT_VALUE Symbol</h2></a>
<p>Should we introduce new API via the <code>Ember</code> global and switch to a module export once all the rest of Ember does, or should we just start with a module export right now? If so, what module?</p>
<pre><code>import { DEFAULT_VALUE } from 'ember-routing';
</code></pre>
<ul>
<li>Start Date: 2017-02-02</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/96">#96</a></li>
</ul>
<a class="header" href="print.html#summary-30" id="summary-30"><h1>Summary</h1></a>
<p>Enable Ember CLI users to opt into using yarn for packagement management.</p>
<a class="header" href="print.html#motivation-31" id="motivation-31"><h1>Motivation</h1></a>
<p>Ember CLI currently uses the npm command line tool to install dependencies when you run <code>ember install</code> or <code>ember new</code>/<code>ember addon</code>. However, several problems usually arise from npm's semantics.
Dependency resolution and install times can be significant enough to disrupt workflows, as well as offline support, non-deterministic, non-flat dependency graphs.</p>
<p>Yarn was introduced to the JavaScript community with the intent to provide a better developer experience in these areas:</p>
<ul>
<li>Faster installs</li>
<li>Offline support</li>
<li>Deterministic dependency graphs</li>
<li>Lockfile semantics</li>
</ul>
<p>While Ember CLI users can currently use Yarn to manage their dependencies, Ember CLI will use the npm client internally when running the above mentioned commands. By allowing users to specify that Ember CLI should use Yarn for everything, we're hoping to provide a more consistent experience.</p>
<a class="header" href="print.html#detailed-design-30" id="detailed-design-30"><h1>Detailed design</h1></a>
<p>Enabling Yarn is designed as opt-in to prevent disruptions to the developer's current workflow.
We will address the two moments where this can happen.</p>
<a class="header" href="print.html#ember-install" id="ember-install"><h2><code>ember install</code></h2></a>
<p>There are two mechanisms through which to opt-in.
The first one is the presence of a <code>yarn.lock</code> file in the project root.</p>
<p>The <code>yarn.lock</code> file is generated by Yarn when you run <code>yarn install</code> (or the shorter <code>yarn</code>),
so we assume that its presence means the developer intends to use Yarn to manage their dependencies.</p>
<p>Alternatively you, you can force Ember CLI to use Yarn with the <code>--yarn</code> flag, and symmetrically,
you can force Ember CLI to not use Yarn with the <code>--no-yarn</code> flag.</p>
<p>To recap:</p>
<ul>
<li><code>ember install ember-cli-mirage</code> with <code>yarn.lock</code> present will use Yarn</li>
<li><code>ember install ember-cli-mirage</code> without <code>yarn.lock</code> present will use npm</li>
<li><code>ember install ember-cli-mirage --yarn</code> will use Yarn</li>
<li><code>ember install ember-cli-mirage --no-yarn</code> will use npm</li>
</ul>
<a class="header" href="print.html#ember-init-ember-new-ember-addon" id="ember-init-ember-new-ember-addon"><h2><code>ember init</code>, <code>ember new</code>, <code>ember addon</code></h2></a>
<p>Since this triad of commands is generally ran before a project is set up, there is no <code>yarn.lock</code> file presence to check.
This means we are left with the <code>--yarn</code>/<code>--no-yarn</code> pair of flags, that will also be added to these commands:</p>
<ul>
<li><code>ember new my-app</code> will use npm</li>
<li><code>ember new my-app --yarn</code> will use Yarn</li>
</ul>
<p>The above also applies to <code>ember addon</code> and <code>ember init</code>, noting that <code>ember init</code> doesn't receive any arguments.</p>
<a class="header" href="print.html#how-we-teach-this-7" id="how-we-teach-this-7"><h1>How We Teach This</h1></a>
<p>Both the Ember.js Guides as well as the Ember CLI Guides will be updated to reflect the new flags,
as well as the new semantics of <code>ember install</code> in the presence of <code>yarn.lock</code>.</p>
<p>In addition, the built-in instructions for <code>ember help</code> will be updated to reflect this.</p>
<a class="header" href="print.html#drawbacks-30" id="drawbacks-30"><h1>Drawbacks</h1></a>
<p>To be determined.</p>
<a class="header" href="print.html#alternatives-30" id="alternatives-30"><h1>Alternatives</h1></a>
<p>Do nothing.</p>
<a class="header" href="print.html#unresolved-questions-26" id="unresolved-questions-26"><h1>Unresolved questions</h1></a>
<p>To be determined.</p>
<ul>
<li>Start Date: 2015-10-23</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/101</li>
<li>Ember Issue: https://github.com/emberjs/data/pull/3930</li>
</ul>
<a class="header" href="print.html#summary-31" id="summary-31"><h1>Summary</h1></a>
<p>Add more illustrative detail to the default Ember Data Adapter Errors.</p>
<a class="header" href="print.html#motivation-32" id="motivation-32"><h1>Motivation</h1></a>
<p>With a production Ember project, it's common to have many errors of the form &quot;Adapter Error&quot;,
originating from deep in the Ember Data stack and carrying little context about what the
original error cause was.</p>
<p>The intent is to add the original request URL, the response code, and some payload information
to the default Error message for <code>DS.AdapterError</code>s. From there Errors can be handled or
tracked as normal.</p>
<a class="header" href="print.html#detailed-design-31" id="detailed-design-31"><h1>Detailed design</h1></a>
<p>I've been using something similar to the following Adapter (<code>friendly-error-adapter.js</code>):</p>
<pre><code class="language-js">import ActiveModelAdapter from 'active-model-adapter';

import DS from 'ember-data';

export default ActiveModelAdapter.extend({

  ajax(url, method)  {
    this.lastRequest = {
      url:    url,
      method: method
    };
    return this._super(...arguments);
  },

  handleResponse: function (status, headers, payload) {
    let payloadContentType = headers[&quot;Content-Type&quot;].split(&quot;;&quot;).get(&quot;firstObject&quot;);
    let shortenedPayload;

    if (payloadContentType === &quot;text/html&quot; &amp;&amp; payload.length &gt; 250) {
      shortenedPayload = &quot;[omitted long blob of HTML]&quot;;
    } else {
      shortenedPayload = payload;
    }

    let errorMessage = `Ember Data Error (${this.lastRequest.method} ${this.lastRequest.url} returned a ${status}). \n Payload (${payloadContentType}): \n\n ${shortenedPayload}`;

    if (this.isSuccess(status, headers, payload)) {
      return payload;
    } else if (this.isInvalid(status, headers, payload)) {
      return new DS.InvalidError(payload.errors, errorMessage);
    }

    let errors = this.normalizeErrorResponse(status, headers, payload);

    return new DS.AdapterError(errors, errorMessage);
  }
});
</code></pre>
<p>(Note that the code inside the adapter could be MUCH simpler and cleaner, the above
is a very quick hacked up example! :bomb:)</p>
<p>The intent is to get an error message out of the form:</p>
<ol>
<li>&quot;Ember Data Error&quot;</li>
<li>Request Method &amp; URI</li>
<li>Response Status</li>
<li>Response Content Type</li>
<li>A sane representation of the Response payload</li>
</ol>
<a class="header" href="print.html#drawbacks-31" id="drawbacks-31"><h1>Drawbacks</h1></a>
<p>Adding complexity to an Error handler always runs the risk of generating errors inside
the handler itself, which would not be overly friendly.</p>
<a class="header" href="print.html#alternatives-31" id="alternatives-31"><h1>Alternatives</h1></a>
<p>There's probably quite a few different pieces of information that could be included
in the message.</p>
<p>We could also potentially look at attaching the extra information to other fields on
the <code>AdapterError</code> (and its subclasses). The only drawback there would be that most
error reporters would then not include that information by default.</p>
<a class="header" href="print.html#unresolved-questions-27" id="unresolved-questions-27"><h1>Unresolved questions</h1></a>
<ul>
<li>Exact Error Message Format</li>
</ul>
<ul>
<li>Start Date: 2017-4-23</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/105">#105</a></li>
</ul>
<a class="header" href="print.html#summary-32" id="summary-32"><h1>Summary</h1></a>
<p>It should be possible to specify packages/addons in <code>optionalDependencies</code> of the <code>package.json</code> of an <code>ember-cli project</code>, and ember-cli should scan for packages/addons mentioned in optionalDependencies while processing the build so that such packages/addons could also be included into the consuming application.</p>
<p>The build need not fail asserting &quot;missing dependency&quot; if any of the dependencies specified in optionalDependencies is missing/absent.</p>
<a class="header" href="print.html#motivation-33" id="motivation-33"><h1>Motivation</h1></a>
<p>In general, the current ember-cli build process will scan for the packages specified in the <code>dependencies</code> hash and <code>devDependencies hash</code> from the downloaded packages in the node_modules folder, discovers and then includes them into the consuming application. The build is designed to fail if any of the packages specified in these two dependencies hash is missing in the <code>node_modules</code> folder. But this procedure may not be sufficient for a variety of cases.</p>
<p>So there could be an option for the developer to specify packages in optionalDependencies and ember-cli can lookup optionalDependencies while processing the build. The Build need not fail if there is any package specified in optionalDependencies is missing, since it is only optional and moreover may only be required for developmental purposes. This way the developer can have more control over the choice of packages he wishes to use for development and skip for production by giving appropriate commands like <code>npm install --no-optional</code>, thereby preventing the installation of packages itself rather than blacklisting in <code>ember-cli-build.js</code> which suggests preventing the installed addons sepcifed in the <code>blacklist</code> array from being included into the consuming application.</p>
<a class="header" href="print.html#detailed-design-32" id="detailed-design-32"><h1>Detailed design</h1></a>
<p>We can tweak ember-cli addon/package discovery process to lookup for optionalDependencies as well and if the package is missing, we can make ember-cli proceed the build without terminating.</p>
<a class="header" href="print.html#how-we-teach-this-8" id="how-we-teach-this-8"><h1>How We Teach This</h1></a>
<p>This functionality can simply be documented in ember-cli guides to teach.</p>
<a class="header" href="print.html#alternatives-32" id="alternatives-32"><h1>Alternatives</h1></a>
<p>None.</p>
<ul>
<li>Start Date: 2017-06-18</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/108">#108</a></li>
</ul>
<a class="header" href="print.html#summary-33" id="summary-33"><h1>Summary</h1></a>
<p>This RFC proposes to add a new API to allow addons to register a custom transformation. This transformation can then be used by other addons when calling <code>app.import</code> with <code>using</code> API.</p>
<a class="header" href="print.html#motivation-34" id="motivation-34"><h1>Motivation</h1></a>
<p>Addons or apps may want import browser only compatible libraries using <code>app.import</code> via bower or npm. These libraries should not be running in Node.</p>
<p>When FastBoot was doing two builds (to generate different assets for browser and Node environment), addon or apps often conditionally imported these libraries relying on the value of <code>process.env.EMBER_CLI_FASTBOOT</code>. With the new scheme of the build where only additional Node assets are built, this enviornment is no longer exposed.</p>
<p>In order to expose better semantics to allow apps and addon authors to easily import these libraries without much overhead (see issue <a href="https://github.com/ember-fastboot/ember-cli-fastboot/issues/413">here</a>), we need to have these libraries wrapped with an FastBoot check. This can be achieved by extending the <code>using</code> API of <code>app.import</code>. FastBoot addon would like to register a custom transformation that other FastBoot compatible addons may chose to use in a declarative API.</p>
<a class="header" href="print.html#detailed-design-33" id="detailed-design-33"><h1>Detailed design</h1></a>
<p>Today, Ember CLI supports transforming anonymous AMD modules imported via <code>app.import</code> into named AMD modules:</p>
<pre><code class="language-js">app.import('/path/to/module.js', {
  using: [
    { transformation: 'amd', as: 'some-dep' }
  ]
});
</code></pre>
<p>The <code>amd</code> transform is hardcoded in Ember CLI. However, it is not possible for addon authors to provide any additional transformation that other addons can use when importing third-party modules. Addons like, FastBoot would like to provide custom transformation for other addons to use so that they can wrap their third party libraries in Node environments.</p>
<p>In order to do this, we would like to expose an API that allows addons to register a custom transformation. This API will be an advanced API and will only be used by addons that want to provide custom transformation. Other addons can chose to use that custom transformation using its name.</p>
<p>The API to register a custom transformation in Ember CLI will be defined in <code>index.js</code> of the addon and will be an advanced API:</p>
<pre><code class="language-js">importTransforms() {
  return {
    'fastboot-shim': function(tree, options) {

      return stew.map(tree, function(content, relativePath) {
        return `if (typeof FastBoot === 'undefined) { ${content} }`;
      });
    }
  }
}
</code></pre>
<p><code>importTransforms</code> returns a map of the name of the transform and a callback function that will be run on every module that uses the transform. The callback function takes the <code>tree</code> as broccoli tree contain all the files that want to run this transform and <code>options</code> map (optional) that contains the additional key value pairs that a consumer transformer provides. The later argument would be used by transformations like <code>amd</code> (explained below).</p>
<p>With this, we also should move the hard coded <code>amd</code> transform into an in-repo addon in Ember CLI. This would allow other addons that define their own transformation to also control the order of their transformation (using <code>before</code> or <code>after</code> hooks of addon initialization). The registeration of <code>amd</code> transform would be:</p>
<pre><code class="language-js">importTransforms() {
  return {
    'amd': function(tree, options) {

      return stew.map(tree, function(content, relativePath) {
        const name = options[relativePath].using;
        if (name) {
          return [
            '(function(define){\n',
            content,
            '\n})((function(){ function newDefine(){ var args = Array.prototype.slice.call(arguments); args.unshift(&quot;',
            name,
            '&quot;); return define.apply(null, args); }; newDefine.amd = true; return newDefine; })());',
          ].join('');
        } else {
          return content;
        }
      });
    }
  }
}
</code></pre>
<p>As seen above, <code>options</code> contains the optional AMD module ID that the consumer of <code>amd</code> transform can provide. If registered transforms want to depend on any other user provided values, those can easily be available during the transforms.</p>
<p>When the addons are initialized, we will check if <code>importTransforms</code> is defined and store these callbacks and transform names in an array.</p>
<p>Now, if addon authors would like to use these transforms when importing libraries, they would simply do the following:</p>
<pre><code class="language-js">app.import('/path/to/module.js', {
  using: [
    {  transformation: 'fastboot-shim' },
    { transformation: 'amd', as: 'some-dep' }
  ]
});
</code></pre>
<p>As seen above, an addon author could provide the list of transformations to run and Ember CLI would run them in the order of when the transformations were registered.
Internally, for every transform we will maintain an array of file paths that need to run this transform. When the transformations need to run, we will read the registration order, run the transformation on those files. The output of the transformation will then be merged back and then the next transformation would run. This will ensure that more than one transformation can be correctly applied to a module.</p>
<a class="header" href="print.html#same-name-conflict" id="same-name-conflict"><h2>Same name conflict</h2></a>
<p>Allowing addons to define custom transform could lead to naming conflicts where more than two addons may provide transform functions with the same name but slightly or totally different functionality. Therefore, if more than one addon provides a same name for a transform by default the last addon in the order that registered its transform will win. In addition, we will also warn the users of the name conflicts and which addon's registered transformation is going to run.</p>
<a class="header" href="print.html#how-we-teach-this-9" id="how-we-teach-this-9"><h1>How We Teach This</h1></a>
<p>The registeration of transform is an advanced API of Ember CLI that very few addons would use. We will be updating the guides <a href="https://ember-cli.com/user-guide/#standard-anonymous-amd-asset">here</a>.</p>
<a class="header" href="print.html#drawbacks-32" id="drawbacks-32"><h1>Drawbacks</h1></a>
<p>The drawback of this approach is that the order of running the transformation is controlled by the addon that provides the transform rather than the addon that uses the transform. The reasoning for this is mainly for performance reasons (in order to not create a funnel per asset path) and to make sure the more than one transform can be applied correctly on an asset path.</p>
<a class="header" href="print.html#alternatives-33" id="alternatives-33"><h1>Alternatives</h1></a>
<p>Currently the alternative is for addons to import their bower or npm dependency in <code>vendor</code> via <code>treeForVendor</code> and manually use broccoli plugins to do transformations. The alternative for apps is to create an in-repo addon to do this.</p>
<a class="header" href="print.html#unresolved-questions-28" id="unresolved-questions-28"><h1>Unresolved questions</h1></a>
<p>N/A</p>
<ul>
<li>Start Date: 2017-09-07</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/110">#110</a></li>
</ul>
<a class="header" href="print.html#summary-34" id="summary-34"><h1>Summary</h1></a>
<p>The goal of this RFC is to solidify the next version of the mechanism that
<code>ember-cli</code> uses to build final assets. It will allow for a more flexible build
pipeline for Ember applications. It also unlocks building experimental features
on top. It is a backward compatible change.</p>
<a class="header" href="print.html#motivation-35" id="motivation-35"><h1>Motivation</h1></a>
<p>The <a href="https://github.com/chadhietala/rfcs/blob/packager/active/0002-packager.md">Packager
RFC</a>
submitted by <a href="https://github.com/chadhietala">Chad Hietala</a> is a little over 2
years old. A lot of things have changed since then and it requires a revision.</p>
<p>The current application build process merges and concatenates input broccoli
trees. This behaviour is not well documented and is a tribal knowledge. While
the simplicity of this approach is nice, it doesn't allow for extension. We can
refactor our build process and provide more flexibility when desired.</p>
<p>Most importantly, the approach described below helps us achieve:</p>
<ul>
<li>defining and developing a common language around the subject</li>
<li>removing highly coupled code and streamline technical implementation (Ember
Engines and Fastboot)</li>
<li>unlock a whole different set of plugins we couldn't have before:
<ul>
<li>ability to create custom bundles (i.e per-engine and per-route bundles)</li>
<li>take advantage of <a href="https://http2.github.io/faq/#why-is-http2-multiplexed">HTTP2
multiplexing</a> and
<a href="https://www.mnot.net/blog/2014/01/30/http2_expectations#4-cache-pushing">cache
pushing</a></li>
<li>optimising plugins (JavaScript and CSS tree-shaking)</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#scope" id="scope"><h1>Scope</h1></a>
<ul>
<li>New public API for customising build process and giving more granular control over
the final build output</li>
</ul>
<a class="header" href="print.html#terminology" id="terminology"><h1>Terminology</h1></a>
<ul>
<li><strong>Packaging</strong> - The process of designing, evaluating, and producing final build assets.</li>
</ul>
<a class="header" href="print.html#detailed-design-34" id="detailed-design-34"><h1>Detailed design</h1></a>
<p>The detailed design is separated in various sections so that it is easier for a
reader to understand.</p>
<a class="header" href="print.html#packaging" id="packaging"><h2>Packaging</h2></a>
<p>It gives you granular control over the final build output. It could be used in many
different ways (we are going to go over use cases below). Note, it isn't meant to be
used for &quot;postprocess&quot; transformations; &quot;postprocess&quot; is called after packaging is
finished.</p>
<p>Currently, Ember.js application and all of its depedencies get assembled under one
directory with the following structure:</p>
<pre><code class="language-ruby">bundler:js:input/
├── addon-tree-output/
├── the-app-name-folder/
├── node_modules/
└── vendor/
</code></pre>
<p>where:</p>
<ul>
<li><code>addon-tree-output</code> is a folder that contains dependencies from Ember add-ons.</li>
<li><code>the-app-name-folder</code> is a folder that contains Ember application code.</li>
<li><code>node_modules</code> is a folder that contains node dependencies.</li>
<li><code>tests</code> is a folder that contains test code.</li>
<li><code>vendor</code> is a folder that contains other dependencies.</li>
</ul>
<p>Note, for clarity purposes we should rename <code>addon-tree-output</code> to <code>addon-modules</code> as
both <code>tree</code> and <code>output</code> don't communicate well about the contents of the folder.</p>
<p>During packaging process the final output will be generated (everything that currently
resides under <code>dist/</code> folder when a developer runs <code>ember build</code>).</p>
<a class="header" href="print.html#package-api" id="package-api"><h3><code>package</code> API</h3></a>
<p>A new public <code>package</code> method will be introduced to open up a way to customise packaging process:</p>
<pre><code class="language-javascript">// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, {
    package(inputTree) {
      // customise `inputTree`
      // and return customised `inputTree`
    }
  });

  return app.toTree();
}
</code></pre>
<p><code>package</code> function has the following signature:</p>
<pre><code class="language-typescript">interface EmberApp {
  package(inputTree: BroccoliTree): BroccoliTree;
}
</code></pre>
<p>where <code>inputTree</code> will have the following structure:</p>
<pre><code class="language-ruby">bundler:js:input/
├── addon-modules/
├── the-app-name-folder/
├── node_modules/
├── tests/
└── vendor/
</code></pre>
<p>Note, that <code>package</code> method must return a broccoli tree.</p>
<p>This change should be behind an experiment flag, <code>PACKAGING</code>.
This will allow us to start experimenting right away and not being
tied to a particular release cycle.</p>
<p>Note, that <code>package</code> is optional. If you don't define it, you're
effectively &quot;opting out&quot; of the feature and using the default
behaviour.</p>
<a class="header" href="print.html#defaultpackager-api" id="defaultpackager-api"><h3><code>defaultPackager</code> API</h3></a>
<p>It's important to make it easy for users to still use default Ember CLI
packaging.</p>
<p><code>defaultPackager</code> is a way for the users to access out-of-the-box packaging while
still be able to customise the final build output.</p>
<pre><code class="language-javascript">// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');
const defaultPackager = require('ember-cli-default-packager');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, {
    package(inputTree) {
      // customise `inputTree`

      return defaultPackager(app, inputTree);
    }
  });

  return app.toTree();
}
</code></pre>
<p><code>defaultPackager</code> has the following signature:</p>
<pre><code class="language-typescript">function defaultPackager(app: EmberApp, inputTree: BroccoliTreel): BroccoliTree;
</code></pre>
<p><code>defaultPackager</code> must return a <code>BroccoliTree</code>.</p>
<a class="header" href="print.html#possible-usages" id="possible-usages"><h3>Possible usages</h3></a>
<a class="header" href="print.html#debuganalyse" id="debuganalyse"><h4>Debug/Analyse</h4></a>
<p>One of the applications of <code>package</code> API would be to run different analysis on the
Ember applications. Take
<a href="https://github.com/stefanpenner/broccoli-concat-analyser">broccoli-concat-analyser</a>,
for example. This could be easily incorporated into the build.</p>
<pre><code class="language-javascript">// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');
const defaultPackager = require('ember-cli-default-packager');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, { });

  app.package = function(inputTree) {
    const analysedTree = new BroccoliConcatAnalyser(inputTree);

    return defaultPackager(app, analysedTree);
  }

  return app.toTree();
}
</code></pre>
<a class="header" href="print.html#static-assets-split" id="static-assets-split"><h4>Static Assets Split</h4></a>
<p>One of the techniques for improving site speed is isolating changes throughout
application deployments. Assuming  the application assets are uploaded to CDN,
the reasoning is very simple: if <code>ember.js</code> or <code>jQuery</code> (possibly along with
other third party libraries) don't change with every deployment, why bust CDN
cache for them?</p>
<a class="header" href="print.html#es6-modules" id="es6-modules"><h4>ES6 Modules</h4></a>
<p>ES6 modules are <a href="https://caniuse.com/#feat=es6-module">starting</a> to land in browsers.
This means that you can use <code>&lt;script type=&quot;module&quot; src=&quot;/my/app.js&quot;&gt;&lt;/script&gt;</code>.</p>
<p>This <a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/">article</a> <a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/#is-this-really-worth-the-extra-effort">explains</a> the benefits of using ES6 modules over ES2015 (smaller total file sizes, faster to parse and evaluate).</p>
<p><code>package</code> API will make it possible to package your application for both ES2015 only browsers as well
the ones with ES6 modules support.</p>
<a class="header" href="print.html#topics-for-future-rfcs" id="topics-for-future-rfcs"><h1>Topics for Future RFCs</h1></a>
<p>While working on this RFC, some ideas were brought into focus regarding existing
and new features in Ember CLI. They all likely require separate discussions in
future RFCs, but the discussion points have been included below.</p>
<a class="header" href="print.html#tree-shaking" id="tree-shaking"><h2>Tree-shaking</h2></a>
<p>Firstly, what's <em>tree-shaking</em>? AFAIK, the term
<a href="https://groups.google.com/forum/#!msg/comp.lang.lisp/6zpZsWFFW18/-z_8hHRAIf4J">originated</a>
in Lisp. The gist of the idea is &quot;how about we start using <em>only</em> the code that
we actually need?&quot;</p>
<p>Secondly, how is it different from <a href="https://en.wikipedia.org/wiki/Dead_code_elimination">Dead Code
Elimination</a>? <a href="https://twitter.com/Rich_Harris">Rich
Harris</a>
<a href="https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80">offers</a>
a pretty good explanation in the context of <a href="https://rollupjs.org/">Rollup</a>. The
gist is dead code elimination happens on a final product by removing bits that
are unused. Tree-shaking is quite different - given an object we want to construct, what is the exact set of dependencies we need?.</p>
<p>With this RFC, we lay out the foundation and create a framework by which both
dead code elimination and tree-shaking code be implemented.</p>
<p>However, there are still several things that are missing:</p>
<ul>
<li><strong>Linker</strong> - Responsible for resolving and reducing the graph to a tree
containing only reachable modules.</li>
<li><strong>File System Resolver</strong> - Responsible for connecting a module name with a
file path.</li>
</ul>
<p><code>Linker</code> would be responsible for:</p>
<ul>
<li>building a minimal dependency graph as well as check for redundant edges in
the graph (more on the topic, <a href="https://en.wikipedia.org/wiki/Transitive_reduction#Graph_algorithms_for_transitive_reduction">Transitive reduction of a directed
graph</a>);</li>
<li>producing an application tree with only used modules</li>
</ul>
<p>Dependency graph represents dependencies using module names, there is a need to
be able to convert module name to file path. This is where <code>File System Resolver</code> comes in. Here's couple of examples:</p>
<pre><code class="language-javascript">fileSystemResolver.resolve('lodash') =&gt; `some-path/node_modules/lodash/lodash.js`
fileSystemResolver.resolve('ember-ajax') =&gt; `some-path/addon-modules/ember-ajax/index.js`
fileSystemResolver.resolve('ember-data') =&gt; `some-path/addon-modules/modules/ember-data/index.js`
fileSystemResolver.resolve('ember-data/-private') =&gt; `some-path/addon-modules/modules/-private.js`
</code></pre>
<p>This effort could be broken down into several phases:</p>
<ul>
<li>dead modules elimination inside of the <code>addons/</code> (application would be the
main entry point and unused modules are removed only from <code>addons/</code>)</li>
<li>dead modules elimination inside of the <code>app/</code>
<ul>
<li>removing unused components and helpers (requires analysing templates)</li>
<li>removing unused initializers/services (this likely entails work on
dependency injection layer as we would need access to a resolver resolution
map)</li>
</ul>
</li>
<li>tree-shaking (Rollup-like tree-shaking where we include <em>only</em> the code that is
used)</li>
</ul>
<p><code>Linker</code> would be able to take an <code>exclude</code> list of modules as a parameter.
Although, valuable in some situations, it should be clearly marked as advanced
API. It should be used as a last resort and serve as an &quot;escape hatch&quot;.</p>
<p>It would make sense to implement <code>Linker</code> as a strategy. Developers would be
able to &quot;opt in&quot;/&quot;opt out&quot; of optimising behaviour.</p>
<a class="header" href="print.html#deprecating-appimport-api" id="deprecating-appimport-api"><h2>Deprecating <code>app.import</code> API</h2></a>
<p>Ember applications which choose to use <code>Linker</code> strategy should be able to
remove usages of <code>app.import</code>.</p>
<a class="header" href="print.html#tools" id="tools"><h2>Tools</h2></a>
<p>With growing complexity of Ember applications, it is crucial to provide more
insights into final assets.</p>
<p>Main goals are:</p>
<ul>
<li>report raw/uglified/compressed asset sizes;
<a href="https://github.com/stefanpenner/broccoli-concat-analyser">broccoli-concat-analyser</a></li>
<li>find source code duplication across your javascript assets (enables you to
fine tune code splitting parameters to reduce bundle invalidation rates as
well as improve repeat page load performance)</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-10" id="how-we-teach-this-10"><h1>How We Teach This</h1></a>
<p>This is a backward compatible change to the existing Ember CLI ecosystem. In
order to teach users how to use <code>package</code> API, we need to update the API docs
with a section for this and the best practices of when to use this. A more
general purpose blog post could be beneficial as well.</p>
<a class="header" href="print.html#drawbacks-33" id="drawbacks-33"><h1>Drawbacks</h1></a>
<p>There are several potential drawbacks that are worth noting.</p>
<p><em>Build performance</em>. There is minimal overhead in instantiating strategies and
calling methods on them and I believe this approach shouldn't degrade build
performance.</p>
<p><em>A note on add-ons</em>. Add-ons don't rely on the way Ember CLI does bundling. That
means existing build system continues to work as expected and add-ons won't have
to change their implementation.</p>
<a class="header" href="print.html#alternatives-34" id="alternatives-34"><h1>Alternatives</h1></a>
<p>This RFC allows us to customise packaging when needed.
<a href="https://webpack.js.org">Webpack</a> has become very popular in solving this
similar problem. One could implement a <code>package</code> function that would use Webpack
for packaging. Ultimately, we need something that is aware of how Ember apps are
assembled and how Ember apps utilise dependency injection that takes advantage
of existing tools. The long term plan is to have a dependency graph that is
aware of application structure so can avoid the &quot;wall of configuration&quot; that
other asset packaging systems are susceptible to.</p>
<a class="header" href="print.html#unresolved-questions-29" id="unresolved-questions-29"><h1>Unresolved questions</h1></a>
<ul>
<li>Will it increase build time?</li>
<li>Should we introduce the same API on add-on level?</li>
</ul>
<a class="header" href="print.html#thanks" id="thanks"><h1>Thanks</h1></a>
<p>Many thanks for <a href="https://github.com/stefanpenner/">@stefanpenner</a>,
<a href="https://github.com/rwjblue/">@rwjblue</a> and
<a href="https://github.com/chadhietala/">@chadhietala</a> for helping me to drive this
forward.</p>
<ul>
<li>Start Date: 2018-01-04</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/114">#114</a></li>
</ul>
<a class="header" href="print.html#summary-35" id="summary-35"><h1>Summary</h1></a>
<p>Add https://github.com/rwjblue/ember-cli-template-lint as a default addon for the app and addon blueprints using the recommended rules.</p>
<a class="header" href="print.html#motivation-36" id="motivation-36"><h1>Motivation</h1></a>
<p>Linting and security in templates would help not only individual developers write better apps with better accessibility and security, but would also help teams to be on the same page and stick to a handful of standards.</p>
<a class="header" href="print.html#detailed-design-35" id="detailed-design-35"><h1>Detailed design</h1></a>
<ol>
<li>Move ember-cli-template-lint to the ember-cli org (better for contributing and getting work off one person, @rwjblue)</li>
<li>Add the dependency to the app blueprint here: https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/package.json#L19</li>
<li>Also add it to the addon blueprint, like the eslint addon here: https://github.com/ember-cli/ember-cli/blob/master/blueprints/addon/index.js#L66</li>
</ol>
<a class="header" href="print.html#how-we-teach-this-11" id="how-we-teach-this-11"><h1>How We Teach This</h1></a>
<p>The same way that we teach ESLint being on by default.</p>
<a class="header" href="print.html#drawbacks-34" id="drawbacks-34"><h1>Drawbacks</h1></a>
<ul>
<li>More chatter in the terminal.</li>
<li>An additional dependency.</li>
<li>Recommended rules might not be good for everyone.. but that same issue probably exists with ESLint.</li>
</ul>
<a class="header" href="print.html#alternatives-35" id="alternatives-35"><h1>Alternatives</h1></a>
<p>Do nothing and have people write sub par template code.</p>
<a class="header" href="print.html#unresolved-questions-30" id="unresolved-questions-30"><h1>Unresolved questions</h1></a>
<p>None</p>
<ul>
<li>Start Date: 2018-02-12</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/116">#116</a></li>
</ul>
<a class="header" href="print.html#summary-36" id="summary-36"><h1>Summary</h1></a>
<p>Introduce <a href="https://github.com/simplabs/qunit-dom"><code>qunit-dom</code></a> as a dependency by default in the <code>app</code> and <code>addon</code> blueprints.</p>
<a class="header" href="print.html#motivation-37" id="motivation-37"><h1>Motivation</h1></a>
<blockquote>
<p>Why are we doing this?</p>
</blockquote>
<p>In a modern Ember application making assertions around the state of the DOM is
fundamental to confirming your applications functionality. These assertions are
often quite verbose:</p>
<pre><code class="language-js">assert.equal(this.element.querySelector('.title').textContent.trim(), 'Hello World!');
</code></pre>
<p>Using the <code>find()</code> helper of <code>@ember/test-helpers</code> we can simplify the DOM
element lookup, but the signal-to-noise ratio of the code is still not great:</p>
<pre><code class="language-js">assert.equal(find('.title').textContent.trim(), 'Hello World!');
</code></pre>
<p>With <code>qunit-dom</code> we can write much more readable assertions for DOM elements:</p>
<pre><code class="language-js">assert.dom('.title').hasText('Hello World!');
</code></pre>
<blockquote>
<p>What use cases does it support?</p>
</blockquote>
<p>It supports the most common assertions on DOM elements, like:</p>
<ul>
<li>what text does the element have?</li>
<li>what value does the <code>&lt;input&gt;</code> element have?</li>
<li>is a certain CSS class applied to the element</li>
</ul>
<p>The full API is documented at <a href="https://github.com/simplabs/qunit-dom/blob/master/API.md">https://github.com/simplabs/qunit-dom/blob/master/API.md</a>.</p>
<blockquote>
<p>What is the expected outcome?</p>
</blockquote>
<p>Using <code>qunit-dom</code> will lead to more simple and readable test code.</p>
<a class="header" href="print.html#detailed-design-36" id="detailed-design-36"><h1>Detailed design</h1></a>
<p>The necessary changes to <code>ember-cli</code> are relatively small since we only need
to add the dependency to the <code>app</code> blueprint, and the <code>addon</code> blueprint will
inherit it automatically.</p>
<p>This has the advantage (over including it as an implicit dependency), that
apps and addons that don't want to use it for some reason can opt-out by
removing the dependency from their <code>package.json</code> file.</p>
<p>A WIP pull request has been created already at <a href="https://github.com/ember-cli/ember-cli/pull/7605">https://github.com/ember-cli/ember-cli/pull/7605</a>.</p>
<a class="header" href="print.html#how-we-teach-this-12" id="how-we-teach-this-12"><h1>How We Teach This</h1></a>
<blockquote>
<p>Would the acceptance of this proposal mean the Ember guides must be
re-organized or altered? Does it change how Ember is taught to new users
at any level?</p>
</blockquote>
<p>Once we decide that this is the right way to go, we should update the official
Ember.js testing guides to use <code>qunit-dom</code> assertions by default. This has the
nice side effect of making the testing code in the guides easier to read too.</p>
<p>At the same time (same minor release) we should update the relevant blueprints
in the <code>ember-source</code> package to use <code>qunit-dom</code> by default. This should be a
relatively small change as only the <code>component</code> and <code>helper</code> tests use
DOM assertions.</p>
<blockquote>
<p>How should this feature be introduced and taught to existing Ember
users?</p>
</blockquote>
<p>We should also explicitly mention this change in the release blog post and
recommend that people use this from now on. For those users that want to
migrate their existing tests to <code>qunit-dom</code> a basic codemod exists at
<a href="https://github.com/simplabs/qunit-dom-codemod">https://github.com/simplabs/qunit-dom-codemod</a>.</p>
<a class="header" href="print.html#drawbacks-35" id="drawbacks-35"><h1>Drawbacks</h1></a>
<blockquote>
<p>Why should we <em>not</em> do this? Please consider the impact on teaching Ember,
on the integration of this feature with other existing and planned features,
on the impact of the API churn on existing apps, etc.</p>
<p>There are tradeoffs to choosing any path, please attempt to identify them here.</p>
</blockquote>
<ul>
<li>
<p><code>qunit-dom</code> is &quot;owned&quot; by a third-party consulting company (simplabs) and
the Ember CLI team is not directly in control.</p>
</li>
<li>
<p><code>qunit-dom</code> has not reached v1.0.0 yet so there might be small breaking
changes in the future.</p>
</li>
<li>
<p><code>qunit-dom</code> is another abstraction layer on top of the raw QUnit assertions
which adds to the existing learning curve.</p>
</li>
<li>
<p>Adding <code>qunit-dom</code> to the default blueprint could make it look even more like
<code>ember-mocha</code> is only a second-class citizen. Since we add it to the default
<code>package.json</code> file it is easy to opt-out though and can be replaced with
<code>chai-jquery</code> or <code>chai-dom</code> for a roughly similar API.</p>
</li>
</ul>
<a class="header" href="print.html#alternatives-36" id="alternatives-36"><h1>Alternatives</h1></a>
<blockquote>
<p>What other designs have been considered?</p>
</blockquote>
<ul>
<li>Using the <code>find()</code> helper functions can be considered an alternative, but
as mentioned above they still result in more verbose code than using
<code>qunit-dom</code>. Another advantage is that <code>qunit-dom</code> generates a useful
assertion description by default, while <code>assert.equal()</code> will just show
something like &quot;A does not match B&quot;.</li>
</ul>
<blockquote>
<p>What is the impact of not doing this?</p>
</blockquote>
<p>We will keep using hard-to-read assertions by default and leave it up to our
users to discover <code>qunit-dom</code> by themselves.</p>
<a class="header" href="print.html#unresolved-questions-31" id="unresolved-questions-31"><h1>Unresolved questions</h1></a>
<ul>
<li>Should the <code>ember-source</code> blueprints detect <code>qunit-dom</code> usage and fallback
to raw QUnit assertions if the dependency can't be found?</li>
</ul>
<ul>
<li>Start Date: 2018-07-30</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/120">#120</a></li>
</ul>
<a class="header" href="print.html#ember-cli-docs" id="ember-cli-docs"><h1>Ember CLI Docs</h1></a>
<a class="header" href="print.html#summary-37" id="summary-37"><h2>Summary</h2></a>
<p>This RFC proposes converting the existing <a href="https://ember-cli.com/">Ember CLI website</a> into an
Ember app, restructuring the table of contents, replacing a significant
portion of the learning material, and inviting community members to participate in writing new content.</p>
<a class="header" href="print.html#motivation-38" id="motivation-38"><h2>Motivation</h2></a>
<p>The purpose of these changes are to empower new contributors, create a consistent
narrative structure, correct outdated information, and lead new readers through an easier learning progression.</p>
<p>Ember's public sites are being migrated from Ruby apps to Ember apps
in order to improve maintainability and empower new contributors. The CLI docs
are currently a Jekyll app. Similar migrations have been very successful.</p>
<p>The rewrite and/or reorganization of content is driven by an audit of the existing
content's relevance and balance. While trying to plan a refactor in place, it became clear that a greenfield approach is more time efficient and will lead to a
better learning experience. A significant portion of the content from the current guides site can be ported over once a new structure is in place.</p>
<a class="header" href="print.html#detailed-design-37" id="detailed-design-37"><h2>Detailed design</h2></a>
<p>This app will have a new table of contents. The architecture will follow the
same patterns successfully used in other apps that have been converted from
Middleman apps to Ember.</p>
<a class="header" href="print.html#writing-process" id="writing-process"><h3>Writing process</h3></a>
<p>Writing new content and porting over existing information is a job that will require the help of many contributors! After this RFC is accepted, a call for contributors will be made.</p>
<p>Here are some strategies to help contributor work to be successful:</p>
<ul>
<li>A quest issue will outline sections that need work so that people can volunteer</li>
<li>Collaboration will be encouraged so that no one person blocks writing on a particular topic</li>
<li>Contributing can take multiple forms. For example, developers with some CLI expertise who don't have time/interest for formal writing can share some brief notes or suggestions to help out the writers. Writers don't need to be experts. In some cases, it's better when someone isn't very familiar with the content because they can help identify gaps.</li>
<li>Each unwritten section will have comments in the markdown indicating which topics to cover. In cases where content has been ported over, comments will indicate which sections to fact-check, clarify, or revise.</li>
<li>A strike team channel will be created on a chat</li>
<li>A writing styleguide will be provided for contributors</li>
<li>Following a verson one release, writing work will be organized via normal GitHub issues.</li>
</ul>
<p>Since maintaining consistent voice and structure across a blank slate is a challenge, beta content for the core learning experience has already been drafted, including Basic Use guides and a tutorial for creating an addon from start to finish.</p>
<p>The beta version of the CLI Guides content can be found at <a href="https://github.com/ember-learn/cli-guides-source">ember-learn/cli-guides-source</a>. The Markdown files there are rendered by <a href="https://github.com/ember-learn/cli-guides-source">ember-learn/cli-guides-app</a>. The app is currently deployed to a temporary endpoint for testing and UX validation. The link is available on the repositories.</p>
<a class="header" href="print.html#user-personas" id="user-personas"><h3>User Personas</h3></a>
<p>The content layout should follow the progression of an Ember developer's
learning experience. There are four main user personas for the
CLI documentation:</p>
<ol>
<li>A new or &quot;typical&quot; Ember CLI user - someone whose primary work is
running common commands like <code>ember serve</code> and who has a &quot;zero
config&quot; type of experience with Ember</li>
<li>Power users - developers who make their own configurations to the
build pipeline</li>
<li>Beginner addon authors - those who are looking to build simple
shared UI components, methods, or wrappers for existing npm libraries</li>
<li>Advanced addon authors - those who dig into internals to make their
addon work, or who are planning for broad extensibility</li>
</ol>
<a class="header" href="print.html#table-of-contents" id="table-of-contents"><h3>Table of Contents</h3></a>
<p>Applying these User Personas to the CLI content, the following topics layout emerges. &quot;Beginner&quot; topics will include links to later &quot;Advanced&quot;
topics, similar to how the Guides link to the API docs.</p>
<ul>
<li>Introduction
<ul>
<li>how to install ember cli</li>
<li>a very simple, short definition of what it is (the official way to create, build, and test an Ember app)</li>
<li>Why is the CLI needed</li>
<li>Guidance on learning path</li>
<li>How to contribute</li>
</ul>
</li>
<li>Basic use (explain options of each)
<ul>
<li>CLI Commands: Explain how to use the <code>help</code> command and common commands like <code>ember new</code>, <code>ember server</code>, <code>ember generate</code>, etc. Each is explained briefly, together with an example usage and a link to the Main Ember Guides with more information about how to use those files.</li>
<li>How to find and use addons</li>
<li>How to use npm packages</li>
<li>Installation and Upgrading the CLI (including a note about upgrading your app, with a link to more resources)</li>
<li>feature flags &amp; configurations</li>
</ul>
</li>
<li>Advanced use
<ul>
<li>shims</li>
<li>broccoli</li>
<li>custom blueprints</li>
<li>CSS compilation</li>
<li>Using another testing library</li>
<li>more on dependencies</li>
<li>more configurations</li>
</ul>
</li>
<li>Writing Addons
<ul>
<li>Overview</li>
<li>Tutorial: Creating a standalone addon and an in-repo addon,</li>
<li>Using the dummy app</li>
<li>Including assets</li>
<li>Configuration</li>
<li>Nested addons</li>
<li>Testing your addon</li>
<li>Sharing your addon (deploying)</li>
</ul>
</li>
<li>API Documentation
<ul>
<li>brief description of the target audience and a link</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#versioning" id="versioning"><h3>Versioning</h3></a>
<p>Only one version of the documentation will be deployed and maintained.
The documentation app itself will have clear releases
as major changes are made, so that users working on
older apps can still go back in time if they need to.</p>
<p>The url will contain <code>/release/</code> so that if versioning is needed in the future,
the option is available.</p>
<a class="header" href="print.html#transition-and-legacy-links" id="transition-and-legacy-links"><h3>Transition and legacy links</h3></a>
<p>While the project is in development, it will be worked on as a separate site, and the main site, <a href="https://ember-cli.com">https://ember-cli.com</a> will remain in place.</p>
<p>Legacy links should be maintained because deprecating the links would cause SEO problems. Consensus seems to be that the best option is to create individualized redirects from pages within <a href="https://ember-cli.com">https://ember-cli.com</a> to the new site.</p>
<p>Upon reaching feature parity, <a href="https://ember-cli.com">https://ember-cli.com</a> will redirect to the new site. Ultimately, content will be hosted at <a href="https://cli.emberjs.com/">https://cli.emberjs.com/</a>. This improves the SEO of our emberjs domain.</p>
<a class="header" href="print.html#application-architecture" id="application-architecture"><h3>Application architecture</h3></a>
<p>The application architecture will follow similar patterns as other Middleman
apps that have been successfully turned into Ember apps. Some examples of past conversions are:</p>
<ul>
<li><a href="https://github.com/ember-learn/deprecation-app">Deprecations</a></li>
<li><a href="https://github.com/ember-learn/guides-app">The Guides</a></li>
<li><a href="https://github.com/ember-learn/ember-api-docs">The API docs</a></li>
</ul>
<p><a href="https://github.com/mansona?tab=overview&amp;from=2018-06-01&amp;to=2018-06-30">Chris Manson</a> has a project in development that automates the creation of documentation apps, integrating the lessons learned from these past conversions. Early results are looking great!</p>
<p>The resulting app will make use of typography and UI assets from
<a href="https://github.com/ember-learn/ember-styleguide">ember-styleguide</a></p>
<p>Although only one version will be deployed/maintained for the forseeable future, the URL structure will allow for future growth, i.e. <code>https://cli.emberjs.com/release/some-topic</code></p>
<a class="header" href="print.html#maintaining-content" id="maintaining-content"><h3>Maintaining content</h3></a>
<p>With module unification and tree shaking refactors underway, there may be some big changes to Ember's
file structure. There are a few ways to mitigate this, while still maintaining only one version of these guides:</p>
<ol>
<li>Whenever possible, the CLI guides should link to the Ember Guides. The details of file layout and syntax are best handled in a resource that is versioned.</li>
<li>The CLI guides can also frequently give a nod to past configurations/features. A url checker will make sure that these &quot;legacy&quot; resource links still exist. The pace of major version releases is slow enough that this should be sustainable.</li>
<li>As mentioned earlier, the urls for the cli guides will include <code>/release/</code> in case future versioning is needed</li>
</ol>
<p>Members of both the Learning Core Team and Ember CLI Core team will have merge access.</p>
<a class="header" href="print.html#how-we-teach-this-13" id="how-we-teach-this-13"><h2>How we teach this</h2></a>
<p>Overall, bringing the CLI docs content up to speed and making it
more maintainable should result in better integration of the
CLI documentation into the Guides. The current content is out
of date, and so it is not frequently linked.</p>
<p>The impact to new users will be a better experience. Existing
Ember users may have an adjustment period to learn the new layout,
but the current layout is confusing, so we believe there will be
net improvement from day one. The addition of search tools will help
with the transition.</p>
<p>Links in the Guides will need to be updated to point
to the new documentation app. There are 41 links to the
current ember-cli website, but only a handful are unique.</p>
<p>The Ember CLI website is not referenced in the API docs.</p>
<a class="header" href="print.html#drawbacks-36" id="drawbacks-36"><h2>Drawbacks</h2></a>
<p>Some potential drawbacks include:</p>
<ul>
<li>Old bookmarks will still point to old content, and it is significant engineering effort to maintain those legacy links</li>
<li>Users may be used to finding content in a particular place</li>
<li>Some existing content will be deemphasized or removed</li>
<li>It's another app to keep in step with the main website</li>
</ul>
<a class="header" href="print.html#alternatives-37" id="alternatives-37"><h2>Alternatives</h2></a>
<p>An alternative is to refactor the content in place. This will be more
time consuming, and will not achieve a consistent narrative voice or cumulative learning experience.</p>
<ul>
<li>Start Date: 2016-02-11</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/120">emberjs/rfcs#120</a></li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/13016</li>
</ul>
<a class="header" href="print.html#summary-38" id="summary-38"><h1>Summary</h1></a>
<p>This RFC proposes replacing the existing <a href="http://emberjs.com/api/classes/Ember.Route.html#method_serialize"><code>Route#serialize</code></a> method with an equivalent method on the options hash passed into <a href="http://emberjs.com/api/classes/Ember.Router.html#method_map"><code>this.route</code> within <code>Router#map</code></a>. The primary goal here is to enable asynchronous Engines by decoupling information about how to link to a route from the actual route object.</p>
<a class="header" href="print.html#motivation-39" id="motivation-39"><h1>Motivation</h1></a>
<p>As we move towards an increasingly asynchronous world with Engines, we need to separate knowledge about how to <em><strong>link</strong> to a route</em> and how to <em><strong>enter</strong> a route</em>. Linking to a route should be able to happen <em>before</em> a route object is instantiated, which is the behavior needed to asynchronously load Engines. However, in our current reality, these concerns are coupled and a route object must be instantiated before being able to link to <em>or</em> enter a route.</p>
<p>By separating these concerns, we can preemptively load the information on how to link to a route without also requiring all the knowledge of how to enter that route. This would be beneficial in both the asynchronous and synchronous worlds by allowing us to defer work.</p>
<p>Since the <code>serialize</code> method is the only method currently used by the <code>Route</code> class to define how to link to a route, the proposal is to extract this method into the space which currently contains the other linking information (e.g., the Router's map).</p>
<p><em><strong>Note:</strong> this separation of concerns will also need to be implemented in router.js for the preemptive loading proposed here to actually work, but we can prepare for that future world by creating a separation of concerns within application code now.</em></p>
<a class="header" href="print.html#detailed-design-38" id="detailed-design-38"><h1>Detailed Design</h1></a>
<p>Since the current API is a simple function, the new hash option will also be a simple function that mirrors the signature of the original. Here's an example:</p>
<pre><code class="language-js">// app/router.js
function serializePostRoute(model, params) {
  // serialize the model into the dynamic paths
}

export default Router.map(function() {
  this.route('post', { path: '/post/:id', serialize: serializePostRoute });
});
</code></pre>
<p>Preserving the current function signature means that refactoring existing code should be simple in most cases. Here's the example currently given in the Ember docs (updated to reflect Ember-CLI):</p>
<pre><code class="language-js">// app/routes/post.js
import Ember from 'ember';
export default Ember.Route.extend({
  model(params) {
    // the server returns `{ id: 12 }`
    return Ember.$.getJSON('/posts/' + params.post_id);
  },

  serialize(model) {
    // this will make the URL `/posts/12`
    return { post_id: model.id };
  }
});

// app/router.js
export default Router.map(function() {
  this.route('post', {
    path: '/post/:id'
  });
});
</code></pre>
<p>Here is that same code refactored for the proposal:</p>
<pre><code class="language-js">// app/routes/post.js
import Ember from 'ember';
export default Ember.Route.extend({
  model(params) {
    // the server returns `{ id: 12 }`
    return Ember.$.getJSON('/posts/' + params.post_id);
  }
});

// app/router.js
function serializePostRoute(model) {
  // this will make the URL `/posts/12`
  return { post_id: model.id };
}

export default Router.map(function() {
  this.route('post', { path: '/post/:id', serialize: serializePostRoute });
});
</code></pre>
<a class="header" href="print.html#migration-plan" id="migration-plan"><h1>Migration Plan</h1></a>
<p>Even though the refactoring needed here is easy, we still need a clear (though simple) migration plan.</p>
<p>The first step will be to introduce the new option into the Router's callback <code>route</code> function. Once that is done, we can deprecate <code>Route#serialize</code> over the remainder of the 2.x series to give developers the time to update their code base. We can then remove support in 3.x.</p>
<p>As noted in the &quot;Motivation&quot; section, there is still work to be done in router.js in order to support this separation of concerns. Due to this, the initial implementation of this new option will essentially be a polyfill that proxies to the corresponding <code>Route#serialize</code> property internally. This will set us up for an internal migration at a later point to actually separate the two; this, however, should not affect developers as it will be internal.</p>
<a class="header" href="print.html#pedagogy-how-we-teach-this" id="pedagogy-how-we-teach-this"><h1>Pedagogy (How We Teach This)</h1></a>
<p>Once the new option is introduced, the Ember guides will need to be updated to reflect this. Those changes should be relatively straightforward as shown in the example above. This will help introduce the feature to new users and those users that haven't used <code>Route#serialize</code> before. Since inline serializers in the router map can be distracting to understanding the general layout of a codebase, we should teach them as defined outside the map itself (as in the code example in this RFC).</p>
<p>For existing users, we can introduce this feature through deprecation warnings (as mentioned above). The deprecations should briefly introduce the new option and point to an appropriate deprecation guide that explains how to migrate.</p>
<a class="header" href="print.html#drawbacks-37" id="drawbacks-37"><h1>Drawbacks</h1></a>
<ul>
<li>Adds another option to the Router map. Though this is largely mitigated due to the fact that this feature is not in wide use currently.</li>
<li>Can be sort of ugly to format.</li>
</ul>
<a class="header" href="print.html#alternatives-38" id="alternatives-38"><h1>Alternatives</h1></a>
<ul>
<li>Introduce a standalone module to represent the <code>Route#serialize</code>. This was the first proposal of this RFC and there is much opposition to introducing yet another construct for Ember-CLI and developers to manage. The approach proposed above avoids this major drawback.</li>
<li>Introduce a holistic construct to represent route linking information. Instead of introducing a new option as a function, we could introduce a class that would represent all the information needed to link to a route. Since there is not currently much other information needed, this seems overkill and would suffer similar opposition as the first alternative.</li>
<li>Don't do this and continue loading and instantiating all route information upfront. This prevents us from improving performance by keeping concerns coupled with prevents introducing async engines. It also requires all Route classes be instantiaed upfront.</li>
</ul>
<a class="header" href="print.html#unresolved-questions-32" id="unresolved-questions-32"><h1>Unresolved Questions</h1></a>
<ul>
<li>Do we wish to apply a similar approach for default query params? And if so, do we wish to incorporate that approach into this new construct?</li>
</ul>
<ul>
<li>Start Date: 2018-08-13</li>
<li>Relevant Team(s): Ember CLI</li>
<li>RFC PR: <a href="https://github.com/ember-cli/rfcs/pull/121">#121</a></li>
</ul>
<a class="header" href="print.html#summary-39" id="summary-39"><h1>Summary</h1></a>
<p>Remove https://github.com/ember-cli/ember-cli-eslint from projects generated by
<code>ember-cli</code>.</p>
<p><a href="https://github.com/ember-cli/ember-cli-eslint">ember-cli-eslint</a> is an addon
designed to show lint errors during test runs. Tooling around <code>eslint</code> has
improved enough where this feature may no longer be necessary.</p>
<p>To be clear, the proposal is <em>not</em> to remove linting in tests. It is to follow
the rest of JavaScript community and follow the standard tooling process.</p>
<p>There are multiple ways to run <code>eslint</code>:</p>
<ol>
<li>Integration with editors</li>
<li>Utilize precommit hooks with <code>eslint</code></li>
<li>Support a standard way to run <code>eslint</code> (such as <code>yarn lint:js</code>)</li>
</ol>
<p>We can also discuss configuring <code>testem</code> to automatically run <code>eslint</code> as part
of <code>yarn test</code></p>
<a class="header" href="print.html#motivation-40" id="motivation-40"><h1>Motivation</h1></a>
<ol>
<li>Improve our build speed</li>
<li>Simplicity. <code>eslint</code> is common among JS stack, and integrations with editors
/ precommit-hooks are ubiquitous. Removing this layer of abstraction will
simplify how <code>eslint</code> is used throughout <code>ember-cli</code>. Most editors have
plugins available for <code>eslint</code>, and as long as the <code>.eslint.rc</code> is not
removed, we should still see the benefits of <code>eslint</code> in our Ember projects.</li>
<li>Hacks required to support features such as <a href="https://github.com/ember-cli/broccoli-lint-eslint/pull/122#discussion-diff-153937455R28">PR #122
broccoli-lint-eslint</a></li>
</ol>
<a class="header" href="print.html#detailed-design-39" id="detailed-design-39"><h1>Detailed design</h1></a>
<ol>
<li>Change blueprint to pull in <code>eslint</code> as opposed to <code>ember-cli-eslint</code> under
<code>devDependencies</code>.</li>
<li>Provide documentation on <code>eslint</code> and editor integration as well as precommit hooks</li>
</ol>
<p>Redefine <code>npm test</code> or <code>yarn test</code> (depending on whether the <code>--yarn</code> option was
used to create project) to</p>
<pre><code>ember test &amp;&amp; npm run lint:js &amp;&amp; npm run lint:hbs
</code></pre>
<p>and</p>
<pre><code>ember test &amp;&amp; yarn lint:js &amp;&amp; yarn lint:hbs
</code></pre>
<a class="header" href="print.html#how-we-teach-this-14" id="how-we-teach-this-14"><h1>How We Teach This</h1></a>
<p>Providing documentation regarding how to run linting should suffice as well as
documentation to editor integration.</p>
<p>Deleting abstractions and going towards a explicit path, <code>eslint</code> within the
<code>ember-cli</code> ecosystem becomes <em>easier</em> to teach.</p>
<a class="header" href="print.html#drawbacks-38" id="drawbacks-38"><h1>Drawbacks</h1></a>
<ol>
<li>No console warnings during builds</li>
<li>lint failures are no longer included in browser tests</li>
</ol>
<a class="header" href="print.html#alternatives-39" id="alternatives-39"><h1>Alternatives</h1></a>
<ol>
<li>Leave <code>ember-cli-eslint</code> alone</li>
</ol>
<a class="header" href="print.html#unresolved-questions-33" id="unresolved-questions-33"><h1>Unresolved questions</h1></a>
<p>N/A</p>
<ul>
<li>Start Date: 2016-04-16</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/136</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/13553</li>
</ul>
<a class="header" href="print.html#summary-40" id="summary-40"><h1>Summary</h1></a>
<p><a href="http://emberjs.com/api/classes/Ember.Array.html#method_contains"><code>contains</code></a> is
implemented on <code>Ember.Array</code>, but [contains was renamed to includes in 2014]
(https://github.com/tc39/Array.prototype.includes/commit/4b6b9534582cb7991daea3980c26a34af0e76c6c)</p>
<ul>
<li>this proposal is for <code>contains</code> to be deprecated in favour of an <code>includes</code>
method on <code>Ember.Array</code></li>
</ul>
<a class="header" href="print.html#motivation-41" id="motivation-41"><h1>Motivation</h1></a>
<p>Motivation is to stay in line with web standards</p>
<a class="header" href="print.html#detailed-design-40" id="detailed-design-40"><h1>Detailed design</h1></a>
<p>First, implement <code>includes</code> polyfill in compliance with <code>includes</code> spec. Polyfill
sample from MDN is:</p>
<pre><code class="language-js">if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {
    'use strict';
    var O = Object(this);
    var len = parseInt(O.length) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1]) || 0;
    var k;
    if (n &gt;= 0) {
      k = n;
    } else {
      k = len + n;
      if (k &lt; 0) {k = 0;}
    }
    var currentElement;
    while (k &lt; len) {
      currentElement = O[k];
      if (searchElement === currentElement ||
         (searchElement !== searchElement &amp;&amp; currentElement !== currentElement)) { // NaN !== NaN
        return true;
      }
      k++;
    }
    return false;
  };
}
</code></pre>
<p>Then, alias <code>contains</code> to <code>includes</code> with deprecation warning, deprecate in line with standard
deprecation process. I don't believe that adding the additional parameter will
have any affect on existing usage of <code>contains</code>.</p>
<a class="header" href="print.html#how-we-teach-this-15" id="how-we-teach-this-15"><h1>How We Teach This</h1></a>
<ul>
<li>Update any references in docs and guides to <code>includes</code></li>
<li>Write a deprecation guide, mentioning any edge cases where the new <code>includes</code> behaves differently to <code>contains</code>, and giving migration examples</li>
<li>Indicate in api docs that this is a polyfill</li>
</ul>
<a class="header" href="print.html#drawbacks-39" id="drawbacks-39"><h1>Drawbacks</h1></a>
<ul>
<li>May break existing apps</li>
<li><a href="https://github.com/emberjs/ember.js/issues/5670#issuecomment-64084814">Was considered before but was too early</a></li>
</ul>
<a class="header" href="print.html#alternatives-40" id="alternatives-40"><h1>Alternatives</h1></a>
<p>Keep current methods</p>
<a class="header" href="print.html#unresolved-questions-34" id="unresolved-questions-34"><h1>Unresolved questions</h1></a>
<p>None</p>
<ul>
<li>Start Date: 2016-04-18</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/139">#139</a></li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/pull/13666">emberjs/ember.js#13666</a></li>
</ul>
<a class="header" href="print.html#summary-41" id="summary-41"><h1>Summary</h1></a>
<p>Introduce <code>Ember.String.isHtmlSafe()</code> to provide a reliable way to determine if an object is an &quot;html safe string&quot;, i.e. was it created with <code>Ember.String.htmlSafe()</code>.</p>
<a class="header" href="print.html#motivation-42" id="motivation-42"><h1>Motivation</h1></a>
<p>Using <code>new Ember.Handlebars.SafeString()</code> is slated for deprecation. Many people are currently using the following snippet as
a mechanism of type checking: <code>value instanceof Ember.Handlebars.SafeString</code>. Providing <code>isHtmlSafe</code> offers a
cleaner method of detection. Beyond that, the aforementioned test is a bit leaky. It requires the developer to understand
<code>htmlSafe</code> returns a <code>Ember.Handlerbars.SafeString</code> instance and thus limits Ember's ability to change
<code>htmlSafe</code> without further breaking it's API.</p>
<p>Based on our app at Batterii and some research on Github, I see two valid use cases for introducing this API.</p>
<p>First, and most commonly, is to make it possible to test addon helpers that are expected to return a safe string. I believe this test on ember-i18n says it all: <a href="https://github.com/jamesarosen/ember-i18n/blob/master/tests/unit/utils/i18n/default-compiler-test.js#L56-L59">&quot;returns HTML-safe string&quot;</a>.</p>
<p>The second use case is to do type checking. In our app, we have an <code>isString</code> utility that is effectively:</p>
<pre><code class="language-javascript">import Ember from 'ember';

export default function(value) {
  return typeof value === 'string' || value instanceof Ember.Handlebars.SafeString;
}
</code></pre>
<p>Newer versions of ember-i18n, doing <code>this.get('i18n').t('someTranslatedValue')</code> will return a safe string. Thus our <code>isString</code> utility has to consider that.</p>
<a class="header" href="print.html#detailed-design-41" id="detailed-design-41"><h1>Detailed design</h1></a>
<p><code>isHtmlSafe</code> will be added to the <code>Ember.String</code> module. The implementation will basically be:</p>
<pre><code class="language-javascript">function isHtmlSafe(str) {
  return str &amp;&amp; typeof str.toHTML === 'function';
}
</code></pre>
<p>It will be used as follows:</p>
<pre><code class="language-javascript">if (Ember.String.isHtmlSafe(str)) {
  str = str.toString();
}
</code></pre>
<a class="header" href="print.html#transition-path" id="transition-path"><h1>Transition Path</h1></a>
<p>As part of landing <code>isHtmlSafe</code> we will simultaneously re-deprecate <code>Ember.Handlebars.SafeString</code>. This deprecation will
take care to ensure that <code>str instanceof Ember.Handlebars.SafeString</code> still passes so that we can continue to
maintain backwards compatibility.</p>
<p>Additionally, a polyfill will be implemented to help provide forward compatibility for addon maintainers and others
looking to get a head while still on older versions of Ember. Similar to <a href="https://github.com/rwjblue/ember-getowner-polyfill">ember-getowner-polyfill</a>.</p>
<a class="header" href="print.html#how-we-teach-this-16" id="how-we-teach-this-16"><h1>How We Teach This</h1></a>
<p>I think we'll continue to refer to these strings as &quot;html safe strings&quot;. This RFC does not
introduce any new concepts, rather it builds on an existing concept.</p>
<p>I don't believe this feature will require guide discussion. I think API Docs will suffice.</p>
<p>The concept of type checking is a pretty common programming idiom. It should be relatively self
explanatory.</p>
<a class="header" href="print.html#drawbacks-40" id="drawbacks-40"><h1>Drawbacks</h1></a>
<p>The only drawback I see is that it expands the surface of the API and it takes a step
towards prompting &quot;html safe string&quot; as a thing.</p>
<a class="header" href="print.html#alternatives-41" id="alternatives-41"><h1>Alternatives</h1></a>
<p>An alternative would be to expose <code>Ember.Handlerbars.SafeString</code> publicly once again. Users
could revert back to using <code>instanceof</code> as their type checking mechanism.</p>
<a class="header" href="print.html#unresolved-questions-35" id="unresolved-questions-35"><h1>Unresolved questions</h1></a>
<p>There are no unresolved questions at this time.</p>
<ul>
<li>Start Date: 2016-05-09</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/143</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/14882</li>
</ul>
<blockquote>
<p>Note: This RFC replaces the closely related RFC for <a href="https://github.com/emberjs/rfcs/pull/124">Module
Normalization</a>. As discussed in the
<a href="print.html#alternatives">Alternatives</a> section below, many concepts are shared between
the two proposals, but there is also a fundamental difference.</p>
</blockquote>
<a class="header" href="print.html#summary-42" id="summary-42"><h1>Summary</h1></a>
<p>Create a unified pattern for organizing and naming modules in Ember projects
that is deterministic, extensible, and ergonomic.</p>
<a class="header" href="print.html#motivation-43" id="motivation-43"><h1>Motivation</h1></a>
<p>Ember CLI's conventions for project layouts and file naming are central to every
Ember developer's experience. It's crucial to get both the technical and
ergonomic details right.</p>
<p>The existing conventions used by Ember CLI have evolved gradually and
organically over the years. Ember CLI and its predecessor Ember App Kit were
early adopters of ES modules and have always leveraged strong conventions to
deduce an understanding of modules based on their locations. Ember CLI's
resolver encodes those conventions to enable run-time module resolutions.</p>
<p>The current system works fairly well, but has some complexities and
inconsistencies that both steepen its learning curve and limit its technical
potential.</p>
<p>Drawbacks include:</p>
<ul>
<li>
<p>Confusion over which of two orthogonal approaches to use for organizing
modules:</p>
<ul>
<li>
<p>classic - modules are organized at the top-level by &quot;type&quot;
(<code>components</code>, <code>templates</code>, etc.) and then by namespace and name.</p>
</li>
<li>
<p>pods - modules are organized by namespace, then name, then type.</p>
</li>
</ul>
</li>
<li>
<p>Addons define modules to be merged into an application through a special <code>app</code>
directory. These public modules are typically private modules that are
imported and re-exported, which introduces an extra module per export and an
extra level of abstraction to learn.</p>
</li>
<li>
<p>Because addons' modules are mixed into an application, there's the possibility
of naming collisions between two addons or an addon and its consuming
application.</p>
</li>
<li>
<p>Modules don't have a clear sense of &quot;locality&quot;, which prevents the ability to
declare modules that are available only in a &quot;local&quot; namespace (this as-yet
unsupported feature has been called &quot;local lookup&quot;).</p>
</li>
<li>
<p>Resolution rules that are declared only in JavaScript are difficult to
analyze and optimize.</p>
</li>
<li>
<p>Module resolution is inefficient due to the number of potential places to
lookup a particular module by name.</p>
</li>
</ul>
<p>Recognizing these drawbacks, the Core Team compiled a set of
<a href="https://github.com/emberjs/core-notes/blob/master/ember.js/2016-01/january-22.md#summary-of-pods-design-constraints">design constraints</a>
for a rethink of Ember's approach to modules:</p>
<ol>
<li>Reasonable branching factor. Users should see a reasonable number of items at any given level in their hierarchy. Flattening out too much results in an unreasonably large number of items.</li>
<li>No slashes in component names. The existing system allows this, but we don't want to support invocation of nested components in Glimmer Components.</li>
<li>Addons need to participate in the naming scheme, most likely with namespace prefix and double-colon separator.</li>
<li>Subtrees should be relocatable. If you move a directory to a new place in the tree, its internal structure should all still work.</li>
<li>There should be no cognitive overhead when adding a new thing. The right way should be obvious and not impose unnecessary decisions.</li>
<li>We need clean separation between the namespace of the user's own components, helpers, routes, etc and the framework's own type names (&quot;component&quot;, &quot;helper&quot;, etc) so that we can disambiguate them and add future ones.</li>
<li>Ideally we will have a place to put tests and styles alongside corresponding components.</li>
<li>Local relative lookup for components and helpers needs to work.</li>
<li>Avoid the &quot;titlebar problem&quot;, in which many files are all named &quot;component.js&quot; and you can't tell them apart in your editor.</li>
<li>The resolver should be configured via declarative rules, not imperative
JavaScript. In addition to enforcing consistency, this allows addons to
augment the system with their own types in a predictable way.</li>
<li>Module structures must be statically analyzable at build time to enable
efficiency optimizations.</li>
<li>Module classifications must be extensible and allow for customizations by
apps, engines, and addons.</li>
</ol>
<blockquote>
<p>Note: Constraints &gt; 9 were added based on discussions subsequent to the
initial meeting.</p>
</blockquote>
<p>This proposal attempts to address these constraints with a single consistent
approach to modules that will make Ember easier to use and learn <em>and</em> improve
the efficiency of Ember's resolver at run-time.</p>
<a class="header" href="print.html#detailed-design-42" id="detailed-design-42"><h1>Detailed Design</h1></a>
<p>This proposal introduces a new top-level directory, <code>src</code>, and establishes
conventions for organizing modules within it. Also proposed is a refactor of the
Ember resolver to enable efficient and flexible resolutions based upon the new
module conventions.</p>
<p>The <code>src</code> directory will be used to contain the core ES modules within an Ember
CLI project, whether that project contains an application, addon, or engine. To
maintain backward compatibility, the <code>src</code> directory will be allowed to
co-exist alongside existing <code>app</code> and/or <code>addon</code> directories, although these
directories should eventually be deprecated.</p>
<a class="header" href="print.html#examples-1" id="examples-1"><h2>Examples</h2></a>
<p>Let's start by taking a look at some examples of Ember projects organized
according to the proposed conventions.</p>
<a class="header" href="print.html#example-application" id="example-application"><h3>Example Application</h3></a>
<p>A simple blogging application could be structured as follows:</p>
<pre><code>src
├── data
│   ├── models
│   │   ├── comment
│   │   │   ├── adapter.js
│   │   │   ├── model.js
│   │   │   └── serializer.js
│   │   ├── post
│   │   │   ├── adapter.js
│   │   │   ├── model.js
│   │   │   └── serializer.js
│   │   └── author.js
│   └── transforms
│       └── date.js
├── init
│   ├── initializers
│   │   └── i18n.js
│   └── instance-initializers
│       └── auth.js
├── services
│   └── auth.js
├── ui
│   ├── components
│   │   ├── date-picker
│   │   │   ├── component.js
│   │   │   └── template.hbs
│   │   └── list-paginator
│   │       ├── paginator-control
│   │       │   ├── component.js
│   │       │   └── template.hbs
│   │       ├── component.js
│   │       └── template.js
│   ├── partials
│   │   └── footer.hbs
│   ├── routes
│   │   ├── application
│   │   │   └── template.hbs
│   │   ├── index
│   │   │   ├── controller.js
│   │   │   ├── route.js
│   │   │   └── template.hbs
│   │   └── posts
│   │       ├── -components
│   │       │   ├── -utils
│   │       │   │   └── strings.js
│   │       │   ├── capitalize.js
│   │       │   └── titleize.js
│   │       ├── post
│   │       │   ├── -components
│   │       │   │   └── post-viewer
│   │       │   │       ├── component.js
│   │       │   │       └── template.hbs
│   │       │   ├── edit
│   │       │   │   ├── -components
│   │       │   │   │   ├── post-editor
│   │       │   │   │   │   ├── post-editor-button
│   │       │   │   │   │   │   ├── component.js
│   │       │   │   │   │   │   └── template.hbs
│   │       │   │   │   │   ├── calculate-post-title.js
│   │       │   │   │   │   ├── component.js
│   │       │   │   │   │   └── template.hbs
│   │       │   │   │   ├── route.js
│   │       │   │   │   └── template.hbs
│   │       │   │   ├── route.js
│   │       │   │   └── template.hbs
│   │       │   ├── route.js
│   │       │   └── template.hbs
│   │       ├── route.js
│   │       └── template.hbs
│   ├── styles
│   │   └── app.scss
│   └── index.html
├── utils
│   └── md5.js
├── main.js
└── router.js
</code></pre>
<a class="header" href="print.html#example-engine" id="example-engine"><h3>Example Engine</h3></a>
<p>An engine could provide the same blogging functionality with almost entirely the
same module structure as the example blog application. Only the following
notable changes would be needed:</p>
<ul>
<li>An engine should declare its routes in <code>src/routes.js</code> instead of <code>src/router.js</code></li>
<li>An engine would require a <code>dummy</code> app within <code>tests</code></li>
<li>An engine should export an <code>Engine</code> instead of an <code>Application</code> from <code>src/main.js</code></li>
</ul>
<a class="header" href="print.html#example-addon" id="example-addon"><h3>Example Addon</h3></a>
<p>Here's how the
<a href="https://github.com/cibernox/ember-power-select">ember-power-select</a> addon could
be restructured:</p>
<pre><code>src
├── styles
│   └── ember-power-select.scss
├── ui
│   └── components
│       ├── main
│       │   ├── before-options
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── options
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── trigger
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── component.js
│       │   └── template.hbs
│       ├── multiple
│       │   ├── trigger
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── component.js
│       │   └── template.hbs
│       └── is-selected.js
└── main.js
</code></pre>
<a class="header" href="print.html#migration-tool" id="migration-tool"><h3>Migration Tool</h3></a>
<p>As a proof of concept for the module layout described in this RFC, Robert
Jackson has created a <a href="https://github.com/rwjblue/ember-module-migrator">migration
tool</a> and used it to migrate
the following repos:</p>
<ul>
<li><a href="https://github.com/rwjblue/--ghost-modules-sample/tree/grouped-collections/src">Ghost admin client</a></li>
<li><a href="https://github.com/rwjblue/--travis-modules-sample/tree/modules/src">Travis client</a></li>
<li><a href="https://github.com/rwjblue/--new-app-blueprint/tree/modules/src"><code>ember new my-app</code></a></li>
</ul>
<p>You can also use Robert's migration tool on your own projects to gain a feel for
how this RFC will affect your work.</p>
<a class="header" href="print.html#es-modules" id="es-modules"><h2>ES Modules</h2></a>
<p>It's important to understand how ES module paths are mapped from the file
system so that you can import modules from elsewhere in your project and its
associated dependencies.</p>
<p>ES module paths will be formed from a project's package name followed by a
direct mapping of file paths from the project root. The file's final extension
(e.g. <code>js</code> or <code>hbs</code>) will be excluded because all ES modules will of course be
compiled into JavaScript from their original format.</p>
<p>For example, the file <code>src/ui/components/date-picker.js</code> in the
<code>my-calendar</code> app will be exported with the module path
<code>my-calendar/src/ui/components/date-picker</code>.</p>
<p>An application and its associated addons and engines will all be merged into the
same ES module space, as is done today. Any module can import from any other
module within this space, although cross-package imports should be done with
care.</p>
<a class="header" href="print.html#module-naming-and-organization" id="module-naming-and-organization"><h2>Module Naming and Organization</h2></a>
<p>This section describes the conventions proposed for naming and organizing a
project's modules within <code>src</code>. These conventions will allow Ember CLI's
resolver to determine the purpose of each module at run-time. They will also
enable static analysis of modules to lint against errors and to prepare a
normalized map for efficient resolutions.</p>
<p>Every resolvable module must have both a <code>name</code> and a <code>type</code>. The <code>type</code>
typically corresponds to the base class of the module's default export (e.g.
<code>route</code>, <code>template</code>, etc.).</p>
<p>Modules can be grouped together with other modules of related types in
&quot;collections&quot;. Collections are directories with type-aware resolution rules
which allow related modules to share a namespace. For example, the <code>models</code>
collection contains models, adapters, and serializers.</p>
<p>Collections that are related to each other can be further organized in &quot;group&quot;
directories. For example, the <code>ui</code> group contains the <code>components</code>, <code>partials</code>,
and <code>routes</code> collections.</p>
<p>Ember CLI will have a build step that normalizes modules to a common form and
builds a mapping between that form and the ES module path described above.
While building this normalized map, the build must error and provide useful
messages if any module naming errors are detected. Unregistered collections and
types should not be allowed. Also, the same normalized module path must not be
repeated through alternative naming forms.</p>
<a class="header" href="print.html#module-type" id="module-type"><h3>Module Type</h3></a>
<p>The type of a module can be determined through the following file naming and
module export rules:</p>
<ol>
<li><code>src/${type}</code> - typed modules named <code>main</code> (explained further below), in
which default exports match the type specified by the file name.</li>
<li><code>src/${collection}/${namespace}/${name}/${type}</code> - expanded collection
modules, in which default exports match the type specified by the file name.</li>
<li><code>src/${collection}/${namespace}/${name}</code> - in which type can be inferred
based on the module's exports. Default exports must match the default
type for the collection. If there is no default export, named exports will
be scanned for a matching type allowed in the collection.</li>
</ol>
<p>Note that template precompilers will need to use default vs. named exports
appropriately in order to satisfy the expectations of Rules 2 and 3.</p>
<p>Here are a few example applications of the module type determination rules:</p>
<pre><code>// Rule 1

src/router (with `export default Ember.Router.extend()`)
=&gt; name: 'main',
   type: 'router'

// Rule 2

src/ui/routes/posts/post/route.js (with `export default Ember.Route.extend()`)
=&gt; collection: 'ui/routes',
   namespace: 'posts',
   name: 'post',
   type: 'route'

src/ui/routes/posts/post/template (with `export default Ember.HTMLBars.template(COMPILED)`)
=&gt; collection: 'ui/routes',
   namespace: 'posts',
   name: 'post',
   type: 'template'

// Rule 3

src/data/models/author (with `export default DS.Model.extend()`)
=&gt; collection: 'data/models',
   name: 'author',
   type: 'model' (the default type for the models collection)

src/ui/components/titleize (with `export let helper = Ember.Helper.helper(function() { })`)
=&gt; collection: 'ui/components',
   name: 'titleize',
   type: 'helper'

src/ui/components/show-title (with `export let template = Ember.HTMLBars.template(COMPILED)`)
=&gt; collection: 'ui/components',
   name: 'show-title',
   type: 'template'
</code></pre>
<a class="header" href="print.html#main-modules" id="main-modules"><h3>Main Modules</h3></a>
<p>Every project must have a &quot;main&quot; module, named <code>src/main.js</code>, that
serves as an entry point into the project.</p>
<p>The main module must export an <code>Application</code>, <code>Engine</code>, or (new) <code>Addon</code> class.
This class must define a <code>modulePrefix</code>, which must match the node package name
for the project.</p>
<p>The main module also declares other properties that help the Ember resolver
understand relationships between projects. For instance, the main module can
declare which modules in an addon are available to a consuming app's resolver.</p>
<p>The main module of an addon can also declare a <code>rootName</code>, which is used by the
resolver to lookup main modules. Initially, the <code>rootName</code> will be a read-only
property that equals the <code>modulePrefix</code> with any <code>ember-</code> and  <code>ember-cli-</code>
prefixes stripped (e.g. <code>ember-power-select</code> becomes <code>power-select</code>). It's
possible that we may allow overrides / aliases in the future.</p>
<p>Modules that appear alongside <code>main.js</code> in <code>src</code> are also considered <code>main</code>
modules for their respective <code>type</code>. For instance, <code>src/router.js</code> is registered
with a <code>name</code> of <code>main</code> and a <code>type</code> of <code>router</code>.</p>
<a class="header" href="print.html#module-collections" id="module-collections"><h3>Module Collections</h3></a>
<p>Top-level namespaces within <code>src</code> serve to group modules into
type-aware &quot;collections&quot;.</p>
<p>The following rules apply to module collections and types:</p>
<ol>
<li>Each collection can contain one or more types. The types allowed
in a particular collection MUST be explicitly declared.</li>
<li>Each type MAY exist in any number of collections.</li>
<li>Each type MUST have only one &quot;definitive collection&quot;, which is the
collection the resolver will use for resolutions if a module can't be found
in the local (i.e. originating) collection.</li>
<li>Each collection MAY have a single &quot;default type&quot;. If a module does not
indicate its type through its file name, then its default export should
align with the default type for its collection.</li>
<li>Each collection can allow &quot;private collections&quot; to be defined at a namespace.
Private collections are localized additions to a top-level collection,
available only from the namespace at which they're defined.</li>
<li>Top-level collections may be grouped for organization purposes. No
resolvable modules must be placed in a group directory.</li>
<li>A collection can appear only once in a project (i.e. it can not be
contained in multiple group directories, or in a group as well as at the
top-level).</li>
</ol>
<p>The following collections and allowed types (rules 1 &amp; 2) are proposed:</p>
<ul>
<li><code>components</code> - COMPONENT, HELPER, template</li>
<li><code>initializers</code> - INITIALIZER</li>
<li><code>instance-initializers</code> - INSTANCE-INITIALIZER</li>
<li><code>models</code> - MODEL, ADAPTER, SERIALIZER</li>
<li><code>partials</code> - PARTIAL</li>
<li><code>routes</code> - ROUTE, CONTROLLER, template</li>
<li><code>services</code> - SERVICE</li>
<li><code>transforms</code> - TRANSFORM</li>
<li><code>utils</code> - UTIL</li>
</ul>
<blockquote>
<p>Note: ALL CAPS indicates which collections are definitive (rule 3) for a type.</p>
</blockquote>
<p>The following default types are proposed for collections (rule 4):</p>
<ul>
<li><code>components</code> - component</li>
<li><code>initializer</code> - initializer</li>
<li><code>instance-initializers</code> - instance-initializer</li>
<li><code>models</code> - model</li>
<li><code>partials</code> - partial</li>
<li><code>routes</code> - route</li>
<li><code>services</code> - service</li>
<li><code>transforms</code> - transform</li>
<li><code>utils</code> - util</li>
</ul>
<p>The following private collections are allowed within collections (rule 5):</p>
<ul>
<li><code>components</code> - utils</li>
<li><code>models</code> - utils</li>
<li><code>initializers</code> - utils</li>
<li><code>instance-initializers</code> - utils</li>
<li><code>routes</code> - components, utils</li>
<li><code>services</code> - utils</li>
<li><code>transforms</code> - utils</li>
</ul>
<p>The following groups are proposed for collections (rule 6):</p>
<ul>
<li><code>data</code> - models, transforms</li>
<li><code>init</code> - initializers, instance-initializers</li>
<li><code>ui</code> - components, partials, routes</li>
</ul>
<p>The collection and type system is designed to be extensible, so that addons can
contribute their own collections and types. The <code>data</code> collection and its
corresponding types should be defined in ember-data. Liquid-fire might want to
define an <code>animations</code> collection and a <code>transition</code> type, and expand <code>routes</code>
to allow <code>animations</code> as a private collection.</p>
<p>The specific format of collection and type declarations for addons is TBD.</p>
<a class="header" href="print.html#components-collection" id="components-collection"><h4>&quot;Components&quot; Collection</h4></a>
<p>This proposal broadens the scope of the term &quot;component&quot; to include all
template-invocable parts of Ember. This includes today's components and helpers,
and the future implementation of &quot;glimmer components&quot; (with angle brackets) and
element modifiers.</p>
<p>Grouping template-invocable elements together in a single collection recognizes
that they already coexist in the same namespace. After all, only one helper OR
component can be invoked as <code>{{foo-bar}}</code>. Using a common collection will not
only simplify file management and searching, it will also provide implicit
linting against creating a helper and class-based component of the same name.</p>
<a class="header" href="print.html#private-collections" id="private-collections"><h4>Private Collections</h4></a>
<p>You may wish to make a component available in a particular template without
polluting the top-level <code>components</code> collection with a more local concern.
Private collections allow you to augment a top-level collection's contents for
use at a particular namespace.</p>
<p>Private collections are declared as a directory sharing the name of the
top-level collection, prefixed with a <code>-</code>. So the top-level <code>routes</code>
collection could be augmented via a private <code>-components</code> collection.</p>
<p>Say that you want to define a <code>post-viewer</code> component to be available only from
within <code>src/ui/routes/posts/post/template.hbs</code>. You could achieve this by
creating your component module in
<code>src/ui/routes/posts/post/-components/post-viewer.js</code>.</p>
<a class="header" href="print.html#non-resolved-files" id="non-resolved-files"><h4>Non-resolved Files</h4></a>
<p>The rules above apply to modules that are resolved, namely <code>*.js</code> and <code>*.hbs</code>
files. Other files that are used for documenting code, such as <code>*.md</code> and
<code>*.html</code> files, can be freely co-located in any directories.</p>
<p>Conventions will still be used for non-resolved files that have significance
within an Ember project, including:</p>
<ul>
<li><code>src/ui/styles</code> - A project's stylesheets.</li>
<li><code>src/ui/index.html</code> - A project's html container.</li>
</ul>
<a class="header" href="print.html#packages" id="packages"><h3>Packages</h3></a>
<p>In-repo addons (including engines) will be placed in a new top-level <code>packages</code>
directory (a sibling of <code>src</code>). We can begin to use the term &quot;packages&quot; instead
of the rather clumsy &quot;in-repo addons&quot;. This differentiation will emphasize that
packages are internal and addons are external to a project. Packages should be
seen as a lightweight way to add new namespacing within a project without the
overhead of a full addon.</p>
<p>The <code>packages</code> directory will provide a separate space away from other library
modules that might be kept in <code>lib</code>, the current directory used for in-repo
addons. Introducing a new top-level directory will allow a clear migration path
for in-repo addons, in the same way that there's a clear migration path from
<code>app</code> to <code>src</code>.</p>
<p>Inside <code>packages</code>, packages should be grouped by name. Each package can have
its own <code>index.js</code>, <code>package.json</code>, and <code>src</code> directory.</p>
<a class="header" href="print.html#ember-resolver-refactor" id="ember-resolver-refactor"><h2>Ember Resolver Refactor</h2></a>
<p>The Ember resolver must be refactored significantly to be made aware of the
new <code>src</code> and <code>packages</code> directories and associated conventions.</p>
<a class="header" href="print.html#module-normalization" id="module-normalization"><h3>Module Normalization</h3></a>
<p>As discussed above, Ember CLI will perform a normalization process for all the
modules in a project and its associated projects. The normalization step will
involve the construction of a map from each module's normalized form to its
corresponding ES module path. If any conflicts are detected, the process should
error and notify the developer.</p>
<p>The Ember resolver will only look up modules in their normalized form, utilizing
the pre-built normalization map to resolve the actual module path.</p>
<a class="header" href="print.html#addon-modules" id="addon-modules"><h3>Addon modules</h3></a>
<p>A resolver will only implicitly consider an addon's top-level modules named
<code>main</code> (e.g. a <code>main</code> component) to be public and available for resolution. More
explicit control over an addon's public modules can be declared in the addon's
<code>main</code> module (details TBD). An addon's public modules will all be resolvable at
the <code>rootName</code> of the addon (see above).</p>
<p>Public components and helpers can be invoked in templates using the <code>rootName</code>
as a namespace. For modules named <code>main</code>, the bare root name will suffice.</p>
<p>Let's say that the <code>ember-power-select</code> addon has a <code>rootName</code> of <code>power-select</code>
and a top-level <code>main</code> component declared in <code>src/ui/components/main.js</code>. An
app could invoke this component in a template as <code>{{power-select::main}}</code> or
more simply as <code>{{power-select}}</code>.</p>
<p>Addons should use the same namespacing that will be used by consuming apps when
invoking their own components and helpers from templates. For instance, if the
<code>ember-power-select</code> addon has a <code>date-picker</code> component that invokes multiple
<code>main</code> components, it should also invoke them in a template as
<code>{{power-select::main}}</code> or more simply as <code>{{power-select}}</code>.</p>
<a class="header" href="print.html#module-resolutions" id="module-resolutions"><h3>Module Resolutions</h3></a>
<p>Module resolution rules must account for the following:</p>
<ul>
<li>The requested module's <code>type</code>, <code>name</code>, and (potentially) <code>namespace</code>.</li>
<li>(Optional) A &quot;source&quot; <code>rootName</code>, collection, and namespace from which the
lookup originates.</li>
<li>(Optional) An &quot;associated type&quot; for lookups that should start in a collection
that is not definitive for the requested <code>type</code>.</li>
</ul>
<p>Module resolutions occur in the following order:</p>
<ol>
<li>Local - If a source module is specified and the requested type is allowed in
the source module's collection, look in a namespace based on the source
module's namespace + name.</li>
<li>Private - If a source module is specified, look in a private collection at
the source module's namespace, if one exists that is definitive for the
requested type.</li>
<li>Associated - If an associated type is specified, look in the definitive
collection for that associated type. Only resolve if the collection can
contain the requested type.</li>
<li>Top-level - In the definitive collection for the requested type, defined at
its top-level.</li>
</ol>
<p>The resolver must maintain mappings of modules at multiple levels to make these
resolutions efficient. A lookup tree can be pre-built for production builds.</p>
<a class="header" href="print.html#example-resolutions" id="example-resolutions"><h4>Example Resolutions</h4></a>
<p>Let's walk through some example resolutions from the above blogging app paired
with the <code>ember-power-select</code> addon. We'll assume that the package name for
the app is <code>blogmeister</code>, and the package name for the addon is
<code>ember-power-select</code>. The addon has a <code>rootName</code> of <code>power-select</code> for cleaner
references.</p>
<hr />
<p>From <code>blogmeister/src/ui/components/list-paginator/template</code>:</p>
<p><code>{{paginator-control}}</code> resolves to <code>blogmeister/src/ui/components/list-paginator/paginator-control/component</code></p>
<p><code>{{date-picker}}</code> resolves to <code>blogmeister/src/ui/components/date-picker/component</code></p>
<p><code>{{power-select}}</code> resolves to <code>ember-power-select/src/ui/components/main/component</code></p>
<p><code>{{power-select::multiple}}</code> resolves to <code>ember-power-select/src/ui/components/multiple/component</code></p>
<hr />
<p>From <code>blogmeister/src/routes/posts/post/template</code>:</p>
<p><code>{{post-viewer}}</code> resolves to <code>blogmeister/src/ui/routes/posts/post/-components/post-viewer/component</code></p>
<p><code>{{date-picker}}</code> resolves to <code>blogmeister/src/ui/components/date-picker/component</code></p>
<p><code>{{power-select}}</code> resolves to <code>ember-power-select/src/ui/components/main/component</code></p>
<a class="header" href="print.html#other-refactorings" id="other-refactorings"><h2>Other Refactorings</h2></a>
<a class="header" href="print.html#generators-and-blueprints" id="generators-and-blueprints"><h3>Generators and Blueprints</h3></a>
<p>Generators and blueprints will need to be made aware of the new module
conventions.</p>
<p>Let's take a look at the files that some generators will create (note: tests
have been left out of these examples for now):</p>
<p><code>ember g component date-picker</code>:</p>
<ul>
<li><code>src/ui/components/date-picker/component.js</code></li>
<li><code>src/ui/components/date-picker/template.hbs</code></li>
</ul>
<p><code>ember g component ui/routes/posts/post-editor</code>:</p>
<ul>
<li><code>src/ui/routes/posts/-components/post-editor/component.js</code></li>
<li><code>src/ui/routes/posts/-components/post-editor/template.hbs</code></li>
</ul>
<p><code>ember g helper titleize</code>:</p>
<ul>
<li><code>src/ui/components/titleize.js</code></li>
</ul>
<a class="header" href="print.html#how-we-teach-this-17" id="how-we-teach-this-17"><h1>How We Teach This</h1></a>
<p>The Ember guides will need to be updated significantly to reflect the new
conventions.</p>
<a class="header" href="print.html#teaching-conventions-through-tooling" id="teaching-conventions-through-tooling"><h2>Teaching Conventions through Tooling</h2></a>
<p>As discussed above, generators and blueprints will be made aware of the new
module conventions. This will help new projects start on track and stay on
track as modules are added.</p>
<p>Developers with existing projects will be able to use Robert Jackson's
<a href="https://github.com/rwjblue/ember-module-migrator">migration tool</a> to move their
projects over to use the new conventions. This tool is a WIP and will continue
to be refined to work well with both the classic and pods structures. It's
possible these migration capabilities will eventually be rolled into Ember
Watson.</p>
<p>Furthermore, the Ember Inspector should be enhanced to understand the new
conventions and become more type and collection aware.</p>
<a class="header" href="print.html#new-concepts" id="new-concepts"><h2>New Concepts</h2></a>
<p>It will be important for both new and experienced Ember developers to
understand some core concepts that are proposed in this RFC.</p>
<a class="header" href="print.html#collections-and-types" id="collections-and-types"><h3>Collections and Types</h3></a>
<p>This proposal's concept of collections and types should feel familiar enough to
users of both the classic and pods layouts to enable a smooth transition. In
many ways, this proposal merges the classic and pods layouts into a single
uniform layout.</p>
<p>The core driver to collections is to store &quot;like with like&quot;. However, instead of
the classic layout's narrow definition of &quot;like&quot; to be of a <em>single</em> type, this
proposal takes the pods approach that <em>multiple</em> types can be related. A good
test of whether multiple module types should be stored together is whether they
should be considered to share a common namespace. Routes, controllers, and
templates are a good example, as are models, adapters, and serializers.</p>
<p>A related concept to understand about collections is the notion of a default
type. Every top-level module within a collection can be considered to match its
default type (unless named exports are used in those modules to represent types
other than the default). Within a collection's namespaces, every module must be
either that default type or related to it. It's helpful to consider that every
namespace within a collection represents a set of named module exports, and that
the default type represents the default export for that collection.</p>
<p>Here's an illustration of exports from a collection:</p>
<pre><code>src
  data
    models
      author.js &lt;- exports an Author `model`, the default type in the `models` collection
      comment
        adapter.js     &lt;- exports a Comment `adapter`
        model.js       &lt;- exports a Comment `model`
        serializer.js  &lt;- exports a Comment `serializer`
</code></pre>
<a class="header" href="print.html#components" id="components"><h4>Components</h4></a>
<p>The term &quot;component&quot; has been widely adopted across most front-end frameworks
to describe a broad swath of UI concerns. Using the same term for the collection
of template-invocable UI elements will lower the learning curve for developers
who are new to Ember, while allowing for a useful set of specialized terms to
flourish to describe particular <em>types</em> of components.</p>
<p>We've already started down the road of component specialization by introducing
the concept of &quot;routable components&quot;. Once we start actually using &quot;routable
components&quot; in practice, it will become necessary to refer to plain old
components as something more specific, like &quot;template components&quot;. And this
distinction will probably lead to plain old helpers being referred to as
&quot;template helpers&quot;. Other concepts, such as &quot;Glimmer components&quot; and &quot;template
component modifiers&quot; will soon be mixed in. We will end up with a multi-faceted
toolbox available at the template layer which deserves a simple name that
matches developer expectations. The general term &quot;components&quot; seems a good fit.</p>
<a class="header" href="print.html#scope-1" id="scope-1"><h3>Scope</h3></a>
<p>Developers should understand the available levels of module scope, as well as
when each is appropriate to use. Scope should be considered when modules are
generated, and developers should feel free to move modules if they expand or
contract in scope.</p>
<p>The following levels of scope should be understood:</p>
<ul>
<li>
<p>Private - private collections should be used when a component or utility
function is needed from a single namespace.</p>
</li>
<li>
<p>Project - top-level, project-wide collections should be used for modules that
are needed throughout a project.</p>
</li>
<li>
<p>Local package - namespaced collections can be useful to group a common set of
cross-cutting concerns within a project.</p>
</li>
<li>
<p>Local engine - a type of local package that encapsulates a set of
functionality that benefits from run-time isolation and strict dependency
sharing.</p>
</li>
</ul>
<a class="header" href="print.html#testing" id="testing"><h3>Testing</h3></a>
<p>Unit, integration, and some acceptance tests can now be co-located with their
associated modules. Co-location should be encouraged because it makes test
modules easier to locate in the file system, and easier to move if a module's
scope changes.</p>
<p>Robert Jackson plans to adapt the
<a href="https://github.com/emberjs/rfcs/pull/119">Grand Testing Unification RFC</a>
to illustrate test co-location and to introduce module types for tests.</p>
<a class="header" href="print.html#drawbacks-41" id="drawbacks-41"><h1>Drawbacks</h1></a>
<p>Any change to a pattern as fundamental as file naming will incur some mental
friction for developers who are accustomed to the current conventions. It is
hoped that tooling like Robert's migrator and Ember Watson can lessen this
friction by automating transitions, and that updated guides, generators, and
blueprints can make these conventions easy to follow.</p>
<p>Of course, we won't prevent usage of the currently used patterns for some time,
but they will eventually be deprecated. Some efficiencies, especially in the
resolver, may not be fully realized until the new patterns are used throughout
a project.</p>
<a class="header" href="print.html#alternatives-42" id="alternatives-42"><h1>Alternatives</h1></a>
<a class="header" href="print.html#the-module-normalization-rfc" id="the-module-normalization-rfc"><h2>The Module Normalization RFC</h2></a>
<p>Perhaps the most prominent alternative that has been explored is the
<a href="https://github.com/emberjs/rfcs/pull/124">Module Normalization RFC</a>. Module
Unification shares many aspects with Module Normalization, but with one
fundamental difference: buckets in Module Normalization are normalized away
for the resolver, while collections in Module Unification play an important
role in module resolution.</p>
<p>The Ember Core Team decided that the sleight of hand required to allow buckets
to be used for organization only, and not for resolution, could create
confusion. Essentially, modules could conflict across buckets, because they
could have matching namespaces, names, and types. This kind of conflict could
not be allowed, so developers would need to understand too much about the
resolution strategy to make it ergonomic.</p>
<a class="header" href="print.html#other-alternatives" id="other-alternatives"><h2>Other Alternatives</h2></a>
<p><a href="https://gist.github.com/dgeb/396fed953184acb04f4f">A large number of other alternatives have been explored</a>
before settling on this recommendation. Feel free to explore the history of any
of the linked gists to understand some of the subtle alternatives.</p>
<p>Of course, one alternative is to simply not change anything and accept the
drawbacks discussed in the Motivation section above. However, even if we accept
inefficiencies in our resolver and confusion over divergent file structuring
strategies, we still need to solve the &quot;local lookup&quot; problem, which does not
have a clean solution in today's module system.</p>
<a class="header" href="print.html#unresolved-questions-36" id="unresolved-questions-36"><h1>Unresolved questions</h1></a>
<a class="header" href="print.html#how-should-tests-be-co-located-in-src" id="how-should-tests-be-co-located-in-src"><h2>How should tests be co-located in <code>src</code>?</h2></a>
<p>Should tests be allowed within <code>src</code> via <code>*-test</code> types (e.g.
<code>component-integration-test</code>, <code>component-unit-test</code>, etc.) within respective
collections?</p>
<p>If this RFC is approved, then Robert Jackson plans to adapt the
<a href="https://github.com/emberjs/rfcs/pull/119">Grand Testing Unification RFC</a> to
propose answers to these questions.</p>
<a class="header" href="print.html#what-about-routable-components" id="what-about-routable-components"><h2>What about routable components?</h2></a>
<p>Should routable components have a type that's unique from other components?</p>
<p>Should they exist alongside <code>route</code> and <code>template</code> types in the <code>routes</code>
collection?</p>
<p>It seems plausible that routable components could simply use the <code>component</code>
type, and that we could lint against allowing template-invocable components
alongside routes.</p>
<a class="header" href="print.html#how-should-configuration-declarations-be-made-in-the-main-module" id="how-should-configuration-declarations-be-made-in-the-main-module"><h2>How should configuration declarations be made in the <code>main</code> module?</h2></a>
<p>For example:</p>
<ul>
<li>How should resolvable exports be declared from addons?</li>
<li>Can apps override the root names of addons? For example, if
<code>ember-power-select</code> has a root name of <code>power-select</code>, could a consuming app
override this?</li>
<li>How do addons and apps declare their collection and type exports? For example,
how could liquid-fire allow for a <code>transition</code> type and an <code>animations</code>
collection?</li>
</ul>
<a class="header" href="print.html#should-we-allow-collection-groups" id="should-we-allow-collection-groups"><h2>Should we allow collection groups?</h2></a>
<p>Do the organizational benefits of collection groups outweigh the potential
confusion over where lines are drawn between a group/collection/namespace
when viewing a project structure.</p>
<ul>
<li>Start Date: 2016-06-11</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/150">#150</a></li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/pull/14360">#14360</a></li>
</ul>
<a class="header" href="print.html#summary-43" id="summary-43"><h1>Summary</h1></a>
<p>With the goal of making significant performance improvements and of adding
public API to support use cases long-served by a private API, a new API of
<code>factoryFor</code> will be added to <code>ApplicationInstance</code> instances.</p>
<a class="header" href="print.html#motivation-44" id="motivation-44"><h1>Motivation</h1></a>
<p>Ember's dependency injection container has long supported fetching a factory
that will be created with any injections present. Using the private API that
provided this support allows an instance of the factory to be created
with initial values passed via <code>create</code>. For example:</p>
<pre><code class="language-js">// app/logger/main.js
import Ember from 'ember';

export default Ember.Logger.extend({
  someService: Ember.inject.service()
});
</code></pre>
<pre><code class="language-js">import Ember from 'ember';
const { Component, getOwner } = Ember;

export default Component.extend(
  init() {
    this._super(...arguments);
    let Factory = getOwner(this)._lookupFactory('logger:main');
    this.logger = Factory.create({ level: 'low' });
  }
});
</code></pre>
<p>In this API, the <code>Factory</code> is actually a subclass the original main logger
class. When <code>_lookupFactory</code> is called, an additional <code>extend</code> takes place
to add any injections (such as <code>someService</code> above). The class/object setup
looks like this:</p>
<ul>
<li>In the module: <code>MyClass = Ember.Object.extend(</code></li>
<li>In <code>_lookupFactory</code>: <code>MyFactoryWithInjections = MyClass.extend(</code></li>
<li>And when used: <code>MyFactoryWithInjections.create(</code></li>
</ul>
<p>The second call to <code>extend</code> implements Ember's owner/DI
framework and permits <code>someService</code> to be resolved later. The &quot;owner&quot; object
is merged into the new <code>MyFactoryWithInjections</code> class along with any
registered injections.</p>
<p>This &quot;double extend&quot; (once at define time, once at <code>_lookupFactory</code> time)
takes a toll on performance booting an app. This design flaw has motivated
a desire to keep <code>_lookupFactory</code> private.</p>
<p>The <code>MyFactoryWithInjections</code> class also features as a cache. Because it is
attached to the owner/container, it is cleared between test runs or
application instances. To illustrate, this flow-chart shows how
<code>MyFactoryWithInjections</code> diverges between tests:</p>
<pre><code>               +-------------------------------+
               |                               |
               |      /app/models/foo.js       |
               |                               |
               +-------------------------------+
                               |
              first test run   |    nth test run
              +----------------+---------------+
              |                                |
              v                                v
   +---------------------+          +--------------------+
   |resolve('model:foo') |   ===    |resolve('model:foo')|
   +---------------------+          +--------------------+
              |                                |
              |                                |
              v                                v

     extend(injections)               extend(injections)

              |                                |
              |                                |
              |                                |
              v                                v
+--------------------------+     +---------------------------+
|lookupFactory('model:foo')| !== |lookupFactory('model:foo') |
+--------------------------+     +---------------------------+
</code></pre>
<p>Despite the design flaws in this API, it does fill a meaningful role in
Ember's DI solution. Use of the private API is common. Some examples:</p>
<ul>
<li><a href="https://github.com/DockYard/ember-cart">ember-cart</a> uses the functionality to create model objects without
tying them to the store <a href="https://github.com/DockYard/ember-cart/blob/c01eb22eaf2e97f8c80481c3174d4be917e476a9/tests/dummy/app/controllers/application.js#L16">example a</a>,
<a href="https://github.com/DockYard/ember-cart/blob/c01eb22eaf2e97f8c80481c3174d4be917e476a9/tests/dummy/app/models/dog.js#L11">example b</a></li>
<li>Ember-Data's <a href="https://github.com/emberjs/data/blob/54ea432b1cbb0d1231d9a0454b09d3b3a0bc2533/addon/-private/system/store.js#L1868"><code>modelFactoryFor</code></a></li>
</ul>
<p>The goal of this RFC is to create a public API for fetching factories with
better performance characteristics than <code>_lookupFactory</code>.</p>
<a class="header" href="print.html#detailed-design-43" id="detailed-design-43"><h1>Detailed design</h1></a>
<p>Throughout this document I reference Ember 2.12 as it is the next LTS at writing. This
proposal may ship for 2.12-LTS or be bumped to the next LTS.</p>
<p>This feature will be added in these steps.</p>
<ol>
<li>In Ember introduce a <code>ApplicationInstance#factoryFor</code> based on
<code>_lookupFactory</code>. It should be documented that certain behaviors
inherent to &quot;double extend&quot; are not supported. In development builds
and supporting browsers, wrap return values in a Proxy. The proxy should
throw an error when any property besides <code>create</code> or <code>class</code> is accessed.
<code>class</code> must return the registered factory, not the double extended factory.</li>
<li>In the same release add a deprecation message to usage of <code>_lookupFactory</code>.
As this API is intimate it must be maintained through at least one LTS
release (2.12 at this writing).</li>
<li>In 2.13 drop <code>_lookupFactory</code> and migrate the <code>factoryFor</code> implementation to avoid
&quot;double-extend&quot; entirely.</li>
</ol>
<p>Additionally, a polyfill will be released for this feature supporting prior
versions of Ember.</p>
<a class="header" href="print.html#design-of-applicationinstancefactoryfor" id="design-of-applicationinstancefactoryfor"><h4>Design of <code>ApplicationInstance#factoryFor</code></h4></a>
<p>A new API will be introduced. This API will return both the original base
class registered into or resolved by the container, and will also return a function
to generate a dependency-injected instance. For example:</p>
<pre><code class="language-js">import Ember from 'ember';
const { Component, getOwner } = Ember;

export default Component.extend(
  init() {
    this._super(...arguments);
    let factory = getOwner(this).factoryFor('logger:main');
    this.logger = factory.create({ level: 'low' });
  }
});
</code></pre>
<p>Unlike <code>_lookupFactory</code>, <code>factoryFor</code> will not return an extended class with
DI applied. Instead it will return a factory object with two properties:</p>
<pre><code class="language-js">// factoryFor returns:
let {

  // a function taking an argument of initial properties passed to the object
  // and returning an instance
  create,

  // The class registered into (or resolved by) the container
  class

} = owner.factoryFor('type:name');
</code></pre>
<p>This API should meet two requirements of the use-cases described in
&quot;Motivation&quot;:</p>
<ul>
<li>Because <code>factoryFor</code> only returns a <code>create</code> method and reference to the
original class, its internal implementation can diverge away from the
&quot;double extend&quot;. A side-effect of this is that the
class of an object instantiated via <code>_lookupFactory(name).create()</code>
and <code>factoryFor(name).create()</code> may not be the same, given the
same original factory.</li>
<li>The presence of <code>class</code> will make it easy to identify the base class of the
factory at runtime.</li>
</ul>
<p>For example today's <code>_lookupFactory</code> creates an inheritance structure like
the following:</p>
<pre><code>                    Current:
       +-------------------------------+
       |                               |
       |      /app/models/foo.js       |
       |                               |
       +-------------------------------+
                       |
                       |
                       |
                       v
            +--------------------+
            |  Class[model/Foo]  |
            +--------------------+
                       |
                       |
                       |
       first test run  |   nth test run
           +-----------+----------+
           |                      |
           |                      |
           |                      |
           v                      v
+--------------------+ +--------------------+
|     subclass of    | |     subclass of    |
|  Class[model/Foo]  | |  Class[model/Foo]  |
+--------------------+ +--------------------+
</code></pre>
<p>Between test runs 2 instances of <code>model:foo</code> will have a common
shared ancestor the grandparent <code>Class[model/Foo]</code>.</p>
<p>This implementation of <code>factoryFor</code> proposes to remove the intermediate
subclass and instead have a generic
factory object which holds the injections and allows for injected instances
to be created. The resulting object graph would look something like this:</p>
<pre><code>                  Proposed:
      +-------------------------------+
      |                               |
      |      /app/models/foo.js       |
      |                               |
      +-------------------------------+
                      |
                      |
                      |
                      v
           +--------------------+
           |  Class[model/Foo]  |
           +--------------------+
                      |
                      |
                      |
      first test run  |   nth test run
           +----------+-----------+
           |                      |
           |                      |
           |                      |
           v                      v
+--------------------+ +--------------------+
|     Factory of     | |     Factory of     |
|  Class[model/Foo]  | |  Class[model/Foo]  |
+--------------------+ +--------------------+
</code></pre>
<p>With <code>factoryFor</code> instances of <code>model:foo</code> will share a common constructor.
Any state stored on the constructor would of course leak between the tests.</p>
<p>An example implementation of <code>factoryFor</code> can be reviewed <a href="https://github.com/emberjs/rfcs/issues/125#issuecomment-193827658">on this GitHub
comment</a>.</p>
<a class="header" href="print.html#implications-for-ownerregister" id="implications-for-ownerregister"><h5>Implications for <code>owner.register</code></h5></a>
<p>Currently, factories registered into Ember's DI system are required to
provide an <code>extend</code> method. Removing support for extend-based DI in <code>_lookupFactory</code>
will permit factories without <code>extend</code> to be registered. Instead factories
must only provide a <code>create</code> method. For example:</p>
<pre><code class="language-js">let factory = {
  create(options={}) {
    /* Some implementation of `create` */
    return Object.create({});
  }
};
owner.register('my-type:a-factory', factory);
let factoryWithDI = owner.factoryFor('my-type:a-factory');

factoryWithDI.class === factory;
</code></pre>
<a class="header" href="print.html#development-mode-proxy" id="development-mode-proxy"><h5>Development-mode Proxy</h5></a>
<p>Because many developers will simply re-write <code>_lookupFactory</code> to <code>factoryFor</code>,
it is important to provide some aid and ensure they actually complete the
migration completely (they they avoid setting state on the factory). A proxy
wrapping the return value of <code>factoryFor</code> and raising assertions when any
property besides <code>create</code> or <code>class</code> is accessed will be added in development.</p>
<p>Additionally, using <code>instanceof</code> on the result of <code>factoryFor</code> should be
disallowed, causing an exception to be raised.</p>
<p>A good rule of thumb is that, in development, using anything besides <code>class</code> or
<code>create</code> on the return value of <code>factoryFor</code> should fail with a helpful message.</p>
<a class="header" href="print.html#releasing-a-polyfill" id="releasing-a-polyfill"><h5>Releasing a polyfill</h5></a>
<p>A polyfill addon, similar to <a href="https://github.com/rwjblue/ember-getowner-polyfill">ember-getowner-polyfill</a>
will be released for this feature. This polyfill will provide the <code>factoryFor</code>
API going back to at least 2.8, provide the API and silence the deprecation
in versions before <code>factoryFor</code> is available, and be a no-op in versions where
<code>factoryFor</code> is available.</p>
<a class="header" href="print.html#how-we-teach-this-18" id="how-we-teach-this-18"><h1>How We Teach This</h1></a>
<p>This feature should be introduced along side <code>lookup</code> in the
<a href="https://guides.emberjs.com/v2.6.0/applications/dependency-injection/">relevant guide</a>.
The return value of <code>factoryFor</code> should be taught as a POJO and not as
an extended class.</p>
<a class="header" href="print.html#example-deprecation-guide-migrating-from-_lookupfactory-to-factoryfor" id="example-deprecation-guide-migrating-from-_lookupfactory-to-factoryfor"><h4>Example deprecation guide: Migrating from <code>_lookupFactory</code> to <code>factoryFor</code></h4></a>
<p>Ember owner objects have long provided an intimate API used to
fetch a factory with dependency injections. This API, <code>_lookupFactory</code>, is deprecated
in Ember 2.12 and will be removed in Ember 2.13. To ease the transition to this
new public API, a polyfill is provided with support back to at least Ember 2.8.</p>
<p><code>_lookupFactory</code> returned the class of resolved factory extended with
a mixin containing its injections. For example:</p>
<pre><code class="language-js">let factory = Ember.Object.extend();
owner.register('my-type:a-name', factory);
let klass = owner._lookupFactory('my-type:a-name');
klass.constructor.superclass === factory; // true
let instance = klass.create();
</code></pre>
<p><code>factoryFor</code> instead returns an object with two properties: <code>create</code> and <code>class</code>.
For example:</p>
<pre><code class="language-js">let factory = Ember.Object.extend();
owner.register('my-type:a-name', factory);
let klass = owner.factoryFor('my-type:a-name');
klass.class === factory; // true
let instance = klass.create();
</code></pre>
<p>A common use-case for <code>_lookupFactory</code> was to fetch an factory with
specific needs in mind:</p>
<ul>
<li>The factory needs to be created with initial values (which cannot be
provided at create-time via <code>lookup</code>.</li>
<li>The instances of that factory need access to Ember's DI framework (injections,
registered dependencies).</li>
</ul>
<p>For example:</p>
<pre><code class="language-js">// app/widgets/slow.js
import Ember from 'ember';

export default Ember.Object.extend({
  // this instance requires access to Ember's DI framework
  store: Ember.inject.service(),

  convertToModel() {
    this.get('store').createRecord('widget', {
      widgetType: 'slow',
      name, canWobble
    });
  }

});
</code></pre>
<pre><code class="language-js">// app/services/widget-manager.js
import Ember from 'ember';

export default Ember.Service.extend({

  init() {
    this.set('widgets', []);
  },

  /*
   * Create a widget of a type, and add it to the widgets array.
   */
  addWidget(type, name, canWobble) {
    let owner = Ember.getOwner(this);
    // Use `_lookupFactory` so the `store` is accessible on instances.
    let WidgetFactory = owner._lookupFactory(`widget:${type}`);
    let widget = WidgetFactory.create({name, canWobble});
    this.get('widgets').pushObject(widget);
    return widget;
  }

});
</code></pre>
<p>For these common cases where only <code>create</code> is called on the factory, migration
to <code>factoryFor</code> is mechanical. Change <code>_lookupFactory</code> to <code>factoryFor</code> in the
above examples, and the migration would be complete.</p>
<a class="header" href="print.html#migration-of-static-method-calls" id="migration-of-static-method-calls"><h5>Migration of static method calls</h5></a>
<p>Factories may have had static methods or properties that were being accessed
after resolving a factory with <code>_lookupFactory</code>. For example:</p>
<pre><code class="language-js">// app/widgets/slow.js
import Ember from 'ember';

const SlowWidget = Ember.Object.extend();
SlowWidget.reopenClass({
  SPEEDS: [
    'slow',
    'verySlow'
  ],
  hasSpeed(speed) {
    return this.SPEEDS.contains(speed);
  }
});

export default SlowWidget;
</code></pre>
<pre><code class="language-js">let factory = owner._lookupFactory('widget:slow');
factory.SPEEDS.length; // 2
factory.hasSpeed('slow'); // true
</code></pre>
<p>With <code>factoryFor</code>, access to these methods or properties should be done via
the <code>class</code> property:</p>
<pre><code class="language-js">let factory = owner.factoryFor('widget:slow');
let klass = factory.class;
klass.SPEEDS.length; // 2
klass.hasSpeed('slow'); // true
</code></pre>
<a class="header" href="print.html#drawbacks-42" id="drawbacks-42"><h1>Drawbacks</h1></a>
<p>The main drawback to this solution is the removal of double extend. Double
extend is a performance troll, however it also means if a single class is registered
multiple times each <code>_lookupFactory</code> returns a unique factory. It is plausible
that some use-case relying on this behavior would get trolled in the migration
to <code>factoryFor</code>, however it is unlikely.</p>
<p>For example these cases where state is stored on the factory would no
longer be scope to one instance of the owner (like one test). Instead, setting
a value on the class would set it on the registered class.</p>
<p>Some real-world examples of setting state on the factory class:</p>
<ul>
<li>ember-model
<ul>
<li>https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L404 and https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L457
with <code>factoryFor</code> will increment a shared counter across application and
container instances.</li>
<li>https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L723-L725
would also set properties on the base <code>Ember.Model</code> factory instead of
an extension of that class.</li>
</ul>
</li>
<li>ember-data
<ul>
<li>If attrs change between test runs (seems very unlikely) then https://github.com/emberjs/data/blob/387630db5e7daec6aac7ef8c6172358a3bd6394c/addon/-private/system/model/attr.js#L57
would be affected. The CP of <code>attributes</code> will have a value cached on the
factory, and where with <code>_lookupFactory</code>'s double-extend the cache would be
on the extended class, in <code>factoryFor</code> that CP cache will be on the
class registered as a factory.</li>
</ul>
</li>
<li>Any other of the following:
<ul>
<li><code>lookupFactory(x).reopen</code> / <code>reopenClass</code> at runtime (or test time to monkey patch code)</li>
<li><code>lookupFactory(x).something = value</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#alternatives-43" id="alternatives-43"><h1>Alternatives</h1></a>
<p>More aggressive timelines have been considered for this change.</p>
<p>However we have considered the possibility that removing <code>_lookupFactory</code> in 2.13
(something LTS technically permits) would be too aggressive for the
community of addons. Providing a polyfill is part of the strategy to handle
this change.</p>
<a class="header" href="print.html#unresolved-questions-37" id="unresolved-questions-37"><h1>Unresolved questions</h1></a>
<p>Are there any use-cases for the double extend not considered?</p>
<ul>
<li>Start Date: 2016-11-05</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/176</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-44" id="summary-44"><h1>Summary</h1></a>
<p>Make Ember feel less overwhelming to new users, and make Ember applications
start faster, by replacing the <code>Ember</code> global with a first-class system for
importing just the parts of the framework you need.</p>
<a class="header" href="print.html#motivation-45" id="motivation-45"><h1>Motivation</h1></a>
<p>ECMAScript 2015 (also known as ES2015 or ES6) introduced a syntax for importing
and exporting values from modules. Ember aggressively adopted modules, and if
you've used Ember before, you're probably familiar with this syntax:</p>
<pre><code class="language-js">import Ember from &quot;ember&quot;;
import Analytics from &quot;../mixins/analytics&quot;;

export default Ember.Component.extend(Analytics, {
  // ...
});
</code></pre>
<p>One thing to notice is that the entire Ember framework is imported as a single
package. Rather than importing <code>Component</code> directly, for example, you import
<code>Ember</code> and subclass <code>Ember.Component</code>. (And this example still works even if
you forget the import, because we also create a global variable called
<code>Ember</code>.)</p>
<p>Using Ember via a monolithic package or global object is not ideal for several
reasons:</p>
<ul>
<li>It's overwhelming for learners. There's a giant list of classes and functions
with no hints about how they're related. The API documentation reflects this.</li>
<li>Experienced developers who don't want all of Ember's features feel like
they're adding unnecessary and inescapable bloat to their application.</li>
<li>The <code>Ember</code> object must be built at boot time, requiring that we ship the
entire framework to the browser. This has two major costs:
<ol>
<li>Increased download time, particularly noticeable on slower connections.</li>
<li>Increased parsing/evaluation cost, which still must be paid even when
assets are cached. On some browsers/devices, this can far exceed the cost of the
download itself.</li>
</ol>
</li>
</ul>
<p>Defining a public API for importing parts of Ember via JavaScript modules helps
us lay the groundwork for solving all of these problems.</p>
<a class="header" href="print.html#reducing-load-time" id="reducing-load-time"><h4>Reducing Load Time</h4></a>
<p>Modules help us eliminate unneeded code. The module syntax is <em>statically
analyzable</em>, meaning that a tool like Ember CLI can analyze an application's
source code and reliably determine which files, in both the framework and the
application, are actually needed. Anything that's not needed is omitted from the
final build.</p>
<p>This allows us to provide the file size benefits of a &quot;small modules&quot; approach
to building web applications while retaining the productivity benefits of a
complete, opinionated framework.</p>
<p>For example, if your application never used the <code>Ember.computed.union</code> computed
property helper, Ember could detect this and remove its code when you build your
application. This technique for slimming down the payload automatically is often
referred to as <em>tree shaking</em> or <em>dead code elimination</em>.</p>
<p>Building the module graph doesn't just mean we get a list of files used by the application—
we also know which files are used <em>route-by-route</em>.</p>
<p>We can use this knowledge to optimize boot time even more, by prioritizing
sending only the JavaScript needed for the requested route, rather than the
entire application.</p>
<p>For example, if the user requests the URL
<code>https://app.example.com/articles/123</code>, the server could first send the code for
<code>ArticlesRoute</code>, the <code>Article</code> model, the <code>articles</code> template, and any
components and framework code used in the route. Only after the route is
rendered would we start to send the remainder of the application and framework
code in the background.</p>
<a class="header" href="print.html#guiding-learners" id="guiding-learners"><h4>Guiding Learners</h4></a>
<p>We can group framework classes and utilities by functionality, making it clear
what things are related and how they should work together. People can feel
confident they are getting only what they need at that moment, not an entire
framework that they're not sure they're benefiting from.</p>
<a class="header" href="print.html#modernizing-ember" id="modernizing-ember"><h4>Modernizing Ember</h4></a>
<p>Lastly, developers are growing increasingly accustomed to using JavaScript
modules to import libaries. If we don't adapt to modules, Ember will feel clunky
and antiquated compared to modern alternatives.</p>
<a class="header" href="print.html#prior-art" id="prior-art"><h3>Prior Art</h3></a>
<p>Initial efforts to define a module API for Ember began with the
<a href="https://github.com/ember-cli/ember-cli-shims"><code>ember-cli-shims</code></a> addon. This addon provides a set of &quot;shim&quot; modules
that re-export a value off the global <code>Ember</code>. While this setup doesn't offer
the benefits of true modules, it did allow us to rapidly experiment with a
module API without making changes to Ember core.</p>
<p>Common feedback from shim users was that, while they were a net improvement,
they introduced too much verbosity and were hard for beginners to remember.</p>
<p>An oft-cited example of this verbosity is that implementing an object and using
<code>Ember.get</code> and <code>Ember.set</code> requires three different imports:</p>
<pre><code class="language-js">import EmberObject from &quot;ember-object&quot;;
import get from &quot;ember-metal/get&quot;;
import set from &quot;ember-metal/set&quot;;
</code></pre>
<p>In fact, one of the principles outlined in this RFC is designed to correct this
verbosity; namely, that <a href="print.html#utility-functions-are-named-exports">utility functions and the class they are related to
should share a module</a>.</p>
<p>For those who have already adopted modules via the <code>ember-cli-shims</code> package, we
will provide a migration tool to rewrite shim modules into the final module API.
The static nature of the import syntax makes this even easier and more reliable
than migrating globals-based apps. The upgrade process should take no more than
a few minutes (see <a href="print.html#migration">Migration</a>).</p>
<p>This RFC also builds significantly on <a href="https://github.com/zeppelin">@zeppelin's</a>
previous <a href="https://github.com/emberjs/rfcs/pull/68">ES6 modules RFC</a>, which drove
initial discussion, including the idea to use scoped packages.</p>
<a class="header" href="print.html#detailed-design-44" id="detailed-design-44"><h1>Detailed Design</h1></a>
<a class="header" href="print.html#terminology-1" id="terminology-1"><h2>Terminology</h2></a>
<ul>
<li><strong>Package</strong> - a bundle of JavaScript addressable by npm and other package
managers, it may contain many modules (but has a default module, usually
called <code>index.js</code>).</li>
<li><strong>Scoped Package</strong> - a namespaced package whose name starts with an <code>@</code>, like
<code>import Thing from &quot;@scope/thing&quot;</code>.</li>
<li><strong>Module</strong> - a JavaScript file with at least one default export or named
export.</li>
<li><strong>Top-Level Module</strong> - the module provided by importing a package directly,
like <code>import Component from &quot;@ember/component&quot;</code>.</li>
<li><strong>Nested Module</strong> - a module provided at a path <em>inside</em> a package, like
<code>import { addObserver } from &quot;@ember/object/observers&quot;</code>.</li>
</ul>
<a class="header" href="print.html#module-naming--organization" id="module-naming--organization"><h2>Module Naming &amp; Organization</h2></a>
<p>Because our goal is to eliminate the <code>Ember</code> global object, any public classes,
functions or properties that currently exist on the global need an equivalent
module that can be imported.</p>
<p>Given how fundamental modules are to the development process, how we organize
and name them impacts new learners and seasoned veterans alike. Thus we must try
to find a balance between predictability for new and intermediate users, and
terseness for experienced developers with large apps.</p>
<p>There is another goal at play: we would like to help dispel the misconception
that Ember is a monolithic framework. Ideally, module names help us tell a story
about Ember's layered features. Rather than inheriting the entire framework at
once, you can pull in just the pieces you need.</p>
<p>For that reason, package names should assist the developer in understanding what
capabilities are added by bringing in that new package. We should pick
meaningful names, not let our public API be a by-product of how Ember's
internals are organized.</p>
<p>A full table of proposed mappings from global to module is available in
<a href="print.html#addendum-1---table-of-module-names-and-exports-by-global">Addendum 1 - Table of Module Names and Exports by
Global</a> and <a href="print.html#addendum-2---table-of-module-names-and-exports-by-package">Addendum
2 - Table of Module Names and Exports by
Package</a>. Because
there is some implicit functionality that you get when loading Ember that is not
encapsulated in a global property (for example, automatically adding prototype
extensions), there is also <a href="print.html#addendum-3---table-of-modules-with-side-effects">Addendum 3 - Table of Modules with Side
Effects</a>.</p>
<p>Before diving in to these tables, however, it may be helpful to understand some
of the thinking that guided this proposal. And keep in mind, this RFC specifies
a <em>baseline</em> module API. Nothing here precludes adding additional models in the
future, as we discover missing pieces.</p>
<a class="header" href="print.html#use-scoped-packages" id="use-scoped-packages"><h3>Use Scoped Packages</h3></a>
<p>Last year, <a href="http://blog.npmjs.org/post/116936804365/solving-npms-hard-problem-naming-packages">npm introduced support for scoped packages</a>. Scopes
are similar to organizations on GitHub. They allow us to use any package name,
even if it's already in use on npm, by namespacing it inside a scope.</p>
<p>For example, the <a href="https://www.npmjs.com/package/component"><code>component</code></a> package is already reserved by an
unmaintained tool; we couldn't use <code>component</code> as a package name even if we
wanted to.</p>
<p>However, scopes allow us to create a package named <code>component</code> that lives under
the <code>@ember</code> scope: <code>import Component from &quot;@ember/component&quot;</code>.</p>
<p>The advantages of using scoped packages, as this proposal does, are two-fold:</p>
<ol>
<li>&quot;Official&quot; packages are clearly differentiated from community packages.</li>
<li>There is no risk of naming conflicts with existing community packages.</li>
</ol>
<p>Note that actually publishing packages to npm may not be immediately necessary
to implement this RFC. We should still design around this constraint so that we
have the option available to us in the future. For more discussion, see the
<a href="print.html#distribution">Distribution unresolved question</a>.</p>
<a class="header" href="print.html#prefer-common-terminology" id="prefer-common-terminology"><h3>Prefer Common Terminology</h3></a>
<p>Module names should use terms people are more likely to be familiar with. For
example, instead of the ambiguous <code>platform</code>, polyfills should be in a module
called <code>polyfill</code>.</p>
<p>Similarly, the vast majority of advanced Ember developers couldn't crisply
articulate the difference between <code>ember-metal</code> and <code>ember-runtime</code>. Instead, we
should prefer <code>ember-object</code>, to match how people actually talk about these
features: the Ember object model.</p>
<a class="header" href="print.html#organize-by-mental-model" id="organize-by-mental-model"><h3>Organize by Mental Model</h3></a>
<p>One of the biggest barriers to learning is the fact that short-term memory is
limited. To understand a complex system like a modern web application, the
learner must hold in their head many different concepts—more concepts than most
people can reason about at once.</p>
<p><a href="https://en.wikipedia.org/wiki/Chunking_(psychology)">Chunking</a> is a strategy for dealing with this. It means that you
present concepts that are conceptually related together. When the learner needs
to reason about the overall system, in their mind they can replace a group of
related concepts with a single, overarching concept.</p>
<p>For example, if you tell someone that in order to build an Ember app, they will
need to understand computed properties, actions (bubbling and closure),
components, containers, registries, routes, helpers (stateful and stateless),
dependent keys, controllers, route maps, observers, transitions, mixins,
computed property macros, injected properties, the run loop, and array
proxies—they will rightfully feel like Ember is an overwhelming, overcomplicated
framework. Most people (your RFC author included) simply cannot keep this many
discrete concepts in their head at once.</p>
<p>The day-to-day reality of building an Ember app, of course, is not nearly so
complex. For those developers who stick through the learning curve, they end up
with a greatly simplified mental model.</p>
<p>This proposal attempts to re-align module naming with that simplified mental
model, placing everything into packages based on the chunk of functionality they
provide:</p>
<ul>
<li><code>@ember/application</code> - Application-level concerns, like bootstrapping,
initializers, and dependency injection.</li>
<li><code>@ember/component</code> - Classes and utilities related to UI components.</li>
<li><code>@ember/routing</code> - Classes used for multi-page routing.</li>
<li><code>@ember/service</code> - Classes and utilities for cross-cutting services.</li>
<li><code>@ember/controller</code> - Classes and utilities related to controllers.</li>
<li><code>@ember/object</code> - Classes and utilities related to Ember's object model,
including <code>Ember.Object</code>, computed properties and observers.</li>
<li><code>@ember/runloop</code> - Methods for scheduling behavior on to the run loop.</li>
</ul>
<p>It includes a few other packages that, over time, your author hopes become
either unneeded or can be moved outside of core into standalone packages:</p>
<ul>
<li><code>@ember/array</code> - Array utilities and observation. Ideally these can be replaced
with a combination of ES2015+ features and array diffing in Glimmer.</li>
<li><code>@ember/enumerable</code> - Replaced by iterables in ES2015.</li>
<li><code>@ember/string</code> - String formatting utilities (dasherize, camelize, etc.).</li>
<li><code>@ember/map</code> - Replaced by <code>Map</code> and <code>WeakMap</code> in ES2015.</li>
<li><code>@ember/polyfills</code> - Polyfills for <code>Object.keys</code>, <code>Object.assign</code> and <code>Object.create</code>.</li>
<li><code>@ember/utils</code> - Grab bag of utilities that could likely be replaced with
something like lodash.</li>
</ul>
<p>And finally, some packages that may be used by internals, extensions, or addons
but are not used day-to-day by app developers:</p>
<ul>
<li><code>@ember/instrumentation</code> - Instrumentation hooks for measuring performance.</li>
<li><code>@ember/debug</code> - Utility functions for debugging, and hooks used by debugger tools like Ember Inspector.</li>
</ul>
<a class="header" href="print.html#classes-are-default-exports" id="classes-are-default-exports"><h3>Classes are Default Exports</h3></a>
<p>Classes that the user is supposed to import and subclass are always the default
export, never a named export. In the case where a package has more than one primary class,
those classes live in a nested module.</p>
<p>This rule ensures there is no ambiguity about whether something is a named
export or a default export: classes are always default exports. In tandem with
the following rule (<a href="print.html#utility-functions-are-named-exports">Utility Functions are Named
Exports</a>), this also means that classes
and the functions that act on them are grouped into the same <code>import</code> line.</p>
<a class="header" href="print.html#examples-2" id="examples-2"><h4>Examples</h4></a>
<p>Primary class only:</p>
<pre><code class="language-js">import EmberObject from &quot;@ember/object&quot;;
</code></pre>
<p>Primary class plus secondary classes:</p>
<pre><code class="language-js">import Component from &quot;@ember/component&quot;;
import Checkbox from &quot;@ember/component/checkbox&quot;;

import Map from &quot;@ember/map&quot;;
import MapWithDefault from &quot;@ember/map/with-default&quot;;
</code></pre>
<p>Multiple primary classes:</p>
<pre><code class="language-js">import Router from &quot;@ember/routing/router&quot;;
import Route from &quot;@ember/routing/route&quot;;
</code></pre>
<a class="header" href="print.html#utility-functions-are-named-exports" id="utility-functions-are-named-exports"><h3>Utility Functions are Named Exports</h3></a>
<p>Functions that are only useful with a particular class, or are used most frequently with
that class, are named exports from the package that exports the class.</p>
<a class="header" href="print.html#examples-3" id="examples-3"><h4>Examples</h4></a>
<pre><code class="language-js">import Service, { inject } from &quot;@ember/service&quot;;
import EmberObject, { get, set } from &quot;@ember/object&quot;;
</code></pre>
<p>In cases where there are many utility functions associated with a class, they can be further subdivided into
nested packages but remain named exports:</p>
<pre><code class="language-js">import EmberObject, { get, set } from &quot;@ember/object&quot;;
import { addObserver } from &quot;@ember/object/observers&quot;;
import { addListener } from &quot;@ember/object/events&quot;;
</code></pre>
<p>In the future, <a href="http://tc39.github.io/proposal-decorators/">decorators</a> would be included under this rule as
well. In fact, designing with an eye towards decorators was a large driver
behind this principle. For more discussion, see the <a href="print.html#everything-is-a-named-export">Everything is a Named
Export alternative</a>.</p>
<a class="header" href="print.html#one-level-deep" id="one-level-deep"><h3>One Level Deep</h3></a>
<p>To avoid deep directory hierarchies with mostly-empty directories, this proposal
limits nesting inside a top-level package to a single level. Deep nesting like
this can add additional time to navigating the hierarchy without adding much
benefit.</p>
<p>Java packages often have this problem due to their URL-based namespacing; see
e.g. <a href="https://github.com/elvishew/xLog/tree/fbfb60f9472e32723436b3d6bdd6c1878a5afb37/library/src">this Java
library</a>
where you end up with deeply nested directories, like
<code>xLog/library/src/test/java/com/elvishew/xlog/printer/AndroidPrinterTest.java</code>.</p>
<p>This rule leads to including the type in the name of the module in some cases
where it might otherwise be grouped instead. For example, instead of
<code>@ember/routing/locations/none</code>, we prefer <code>@ember/routing/none-location</code> to
avoid the second level of nesting.</p>
<a class="header" href="print.html#no-non-module-namespaces" id="no-non-module-namespaces"><h3>No Non-Module Namespaces</h3></a>
<p>The global version of Ember includes several functions that also act as a
namespace to group related functionality.</p>
<p>For example, <code>Ember.run</code> can be used to run some code inside a run loop, while
<code>Ember.run.scheduleOnce</code> is used to schedule a function onto the run loop once.</p>
<p>Similarly, <code>Ember.computed</code> can be used to indicate a method should be treated as
a computed property, but computed property macros also live on <code>Ember.computed</code>, like
<code>Ember.computed.alias</code>.</p>
<p>When consumed via modules, these functions no longer act as a namespace. That's
because tacking these secondary functions on to the main function requires us to
eagerly evaluate them (not to mention the potential deoptimizations in
JavaScript VMs by adding properties to a function object).</p>
<p>In practice, that means that this won't work:</p>
<pre><code class="language-js">// Won't work!
import { run } from &quot;@ember/runloop&quot;;
run.scheduleOnce(function() {
  // ...
});
</code></pre>
<p>Instead, you'd have to do this:</p>
<pre><code class="language-js">import { scheduleOnce } from &quot;@ember/runloop&quot;;
scheduleOnce(function() {
  // ...
});
</code></pre>
<p>The <a href="print.html#migration">migration tool</a>, described below, is designed to detect these
cases and migrate them correctly.</p>
<a class="header" href="print.html#prototype-extensions-and-other-code-with-side-effects" id="prototype-extensions-and-other-code-with-side-effects"><h3>Prototype Extensions and Other Code with Side Effects</h3></a>
<p>Some parts of Ember change global objects rather than exporting classes or
functions. For example, Ember (by default) installs additional methods on
<code>String.prototype</code>, like the <code>camelize()</code> method.</p>
<p>Any code that has side effects lives in a module without any exports; importing
the module is enough to produce the desired side effects. For example, if I
wanted to make the string extensions available to the application, I could
write:</p>
<pre><code class="language-js">import &quot;@ember/extensions/string&quot;
</code></pre>
<p>Generally speaking, modules that have side effects are harder to debug and can
cause compatibility issues, and should be avoided if possible.</p>
<a class="header" href="print.html#migration-1" id="migration-1"><h2>Migration</h2></a>
<p>To assist in assessing this RFC in real-world applications, and to help upgrade
apps should this RFC be accepted and implemented, your author has provided an
automatic migration utility, or &quot;codemod&quot;:</p>
<p><a href="https://github.com/tomdale/ember-modules-codemod">ember-modules-codemod</a></p>
<p>To run the codemod, <code>cd</code> into an existing Ember app and run the following commands.</p>
<pre><code class="language-sh">npm install ember-modules-codemod -g
ember-modules-codemod
</code></pre>
<p><strong>Note</strong>: The codemod currently requires Node 6 or later to run.</p>
<p>This codemod uses <a href="https://github.com/facebook/jscodeshift"><code>jscodeshift</code></a> to
update an Ember application in-place to the module syntax proposed in this RFC.
It can update apps that use the global <code>Ember</code>, and will eventually also support
apps using <a href="https://github.com/ember-cli/ember-cli-shims">ember-cli-shims</a>.</p>
<p><strong>Make sure you save any changes in your app before running the codemod, because
it modifies files in place. Obviously, because this RFC is speculative, your app
will not function after applying this codemod. For now, the codemod is only
useful for assessing how this proposal looks in real-world applications.</strong></p>
<p>For example, it will rewrite code that looks like this:</p>
<pre><code class="language-js">import Ember from 'ember';

export default Ember.Component.extend({
  isAnimal: Ember.computed.or('isDog', 'isCat')
});
</code></pre>
<p>Into this:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { or } from '@ember/object/computed';

export default Component.extend({
  isAnimal: or('isDog', 'isCat')
});
</code></pre>
<p>For more information, see the <a href="https://github.com/tomdale/ember-modules-codemod">README</a>.</p>
<a class="header" href="print.html#how-we-teach-this-19" id="how-we-teach-this-19"><h1>How We Teach This</h1></a>
<p>This RFC makes changes to one of the most foundational (and historically stable)
concepts in Ember: how you access framework code. Because of that, it is hard to
overstate the impact these changes will have. We need to proceed carefully to
avoid confusion and churn.</p>
<p>It is possible that the work required to update the documentation and other
learning materials will be significantly more than the work required to do the
actual implementation. That means we need to start getting ready <em>now</em>, so that
when the code changes are ready, it is not blocked by a big documentation
effort.</p>
<p>That said, we do have the advantage of the new modules being &quot;just JavaScript.&quot;
We can lean heavily on the greater JavaScript community's learning materials,
and any teaching we do has the benefit of being transferable and not an
&quot;Ember-only&quot; skill.</p>
<a class="header" href="print.html#documentation-examples" id="documentation-examples"><h2>Documentation Examples</h2></a>
<p>Examples in the Getting Started tutorial, guides and API docs will need to be
updated to the new module syntax.</p>
<p>Probably the most efficient and least painful way to do this would be to write a
tool that can extract code snippets from Markdown files and run the
<a href="print.html#migration">migrator</a> on them, then replace the extracted code with the updated
version. For the API docs, this tool would need to be able to handle Markdown embedded
in JSDoc-style documentation.</p>
<p>The benefit of this approach is that, once we have verified the script works
reliably, we can wait until the last possible moment to make the switch. If we
attempt to update everything by hand, the duration and tediousness of that
process will likely take out an effective &quot;lock&quot; on the documentation code base,
where people will put off making big changes because of the potential for merge
conflicts.</p>
<a class="header" href="print.html#generators" id="generators"><h2>Generators</h2></a>
<p>Generators are used by new users to help them get a handle on the framework, and
by experienced users to avoid typing repetitive boilerplate. We need to ensure
that the generators that ship with Ember are updated to use modules as soon as
they are ready. The recent work by the Ember CLI team to ship generators with
the Ember package itself, rather than Ember CLI, should make this relatively
painless.</p>
<a class="header" href="print.html#api-documentation" id="api-documentation"><h2>API Documentation</h2></a>
<p>Our API documentation has long been a source of frustration, because the laundry
list of (often rarely used or internal) classes makes Ember feel far more
overwhelming than it really is.</p>
<p>The shift to modules gives us a good opportunity to rethink the presentation of
our API documentation. Instead of the imposing mono-list, we should group the
API documentation by package–which, conveniently in this proposal, means they
will also be grouped by area of functionality.</p>
<p>We should investigate the broader ecosystem to see if there is a good tool that
generates package-oriented documentation for JavaScript projects. If not, we may
wish to adapt an existing tool to do so.</p>
<a class="header" href="print.html#explaining-the-migration" id="explaining-the-migration"><h2>Explaining the Migration</h2></a>
<p>Once the guides and API documentation are updated, modules should be
straightforward for new learners—indeed, more and more new learners are starting
with JavaScript modules as the baseline.</p>
<p>The most challenging aspect of teaching the new modules API, counterintuitively,
will likely be <em>existing</em> users. In particular, for changes that touch nearly
every file, most teams working on large apps cannot pause work for a week to
implement the change.</p>
<p>Our focus needs to be:</p>
<ul>
<li>Communicating clearly that the existing global build will work for the
foreseeable future.</li>
<li>Making clear the file size benefits of moving to modules.</li>
<li>Building robust tooling that allows even large apps to migrate in a day or
two, not a week.</li>
</ul>
<p>It is important to frame the module transition as a carrot, not a stick. We
should avoid dire warnings or deprecation notices. Instead, we should provide
good reporting when doing Ember CLI builds. If an app is compiled in globals
mode, we can offer suggestions for how to reduce the file size, providing a
helpful pointer to the modules migration guide. This will make the transition
feel less like churn and more like an optimization opportunity that developers
can take advantage of when they have the time or resources.</p>
<a class="header" href="print.html#addons" id="addons"><h3>Addons</h3></a>
<p>One pitfall is that a <em>single</em> use of the <code>Ember</code> global means we have to
include the entire framework. That means that a developer could migrate their
entire app to modules, but a single old addon that uses the Ember globals will
negate the benefits.</p>
<p>This requires a two-pronged strategy:</p>
<ul>
<li>Tight integration into Ember CLI
<ul>
<li>Good reporting to make it obvious when a fallback to globals mode
occurs, and which addons/files are causing it.</li>
<li>An opt-in mode to prohibit globals mode. Installing an incompatible addon
would produce an error.</li>
</ul>
</li>
<li>Community outreach and pull requests to help authors update addons.</li>
</ul>
<a class="header" href="print.html#drawbacks-43" id="drawbacks-43"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#complexity" id="complexity"><h2>Complexity</h2></a>
<p>There is something elegantly simple about a single <code>Ember</code> global that contains
everything. Introducing multiple packages means you don't just have to know what
you need—you also need to know where to import it from.</p>
<p>JavaScript module syntax is also something not everyone will be familiar with,
given its newness. However, this is something we must deal with anyway because
module syntax is already in use within apps.</p>
<a class="header" href="print.html#module-churn" id="module-churn"><h2>Module Churn</h2></a>
<p>The <code>ember-cli-shims</code> package is already included by default in new Ember apps,
and is in fairly common usage. Many developers are already familiar with its
API. This drawback can be at least partially mitigated by <a href="print.html#migration">the automated
migration process</a>, which will be easily applied to existing shimmed
apps.</p>
<a class="header" href="print.html#scoped-packages-are-an-unknown-quantity" id="scoped-packages-are-an-unknown-quantity"><h2>Scoped Packages Are an Unknown Quantity</h2></a>
<p>This proposal relies on scoped packages. Despite being released over a year ago,
scoped packages are not always well supported.</p>
<p>For example, <a href="https://github.com/yarnpkg/yarn/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20is%3Aopen%20scoped%20packages">scoped packages currently wreak havoc on Yarn</a>. Until very
recently, the <a href="https://npmjs.com">npmjs.com</a> search did not include scoped
packages. Generally speaking, there will be a long-tail of tools in the
ecosystem that will choke on scoped packages.</p>
<p>That said, Angular 2 is distributed under the <code>@angular</code> scope, and TypeScript
recently adopted the <code>@types</code> scope for publishing TypeScript typings to npm.
The popularity of both of these should drive compatibility. Despite this, we can
expect <a href="https://github.com/angular/angular/issues/8422">similar compatibility issues</a> for some time.</p>
<a class="header" href="print.html#nested-modules" id="nested-modules"><h2>Nested Modules</h2></a>
<p>To satisfy the <a href="print.html#classes-are-default-exports">Classes are Default Exports</a> rule,
this RFC proposes the use of nested modules. That is, a module name may contain
an additional path segment beyond the package name. For example,
<code>@ember/object/observers</code> is a nested module, while <code>@ember/object</code> is not.</p>
<p>In the Node/CommonJS world, nested modules are unusual but not unheard of. For
example, Lodash offers a <a href="https://github.com/lodash/lodash/wiki/FP-Guide">functional programming
style</a> accessed by calling
<code>require('lodash/fp')</code>.</p>
<p>There are two drawbacks associated with nested modules:</p>
<ol>
<li>Because they are uncommon, developers may be confused by the syntax.</li>
<li>Because they allow you to &quot;reach in&quot; to the package for an
arbitrary file, encouraging the end user to use nested modules may
inadvertently <em>also</em> encourage them to access private modules, thinking they are
public.</li>
</ol>
<p>The first issue is surmountable with education, good reference documentation,
and good tools to help guide developers in the right direction. That this style
is uncommon in the Node ecosystem seems to be more a <a href="http://blog.izs.me/post/44149270867/why-no-directorieslib-in-node-the-less-snarky">function of
dogma</a>
than any technical shortcoming of nested modules.</p>
<p>To ensure that developers don't inadvertently access private modules, we have
two good options:</p>
<ol>
<li>Package modules in such a way that private modules <em>cannot</em> be accessed.</li>
<li>Take a page from Ember Data and put all private modules in a <code>-private</code>
directory, hopefully making it clear accessing this module is not playing by
the rules.</li>
</ol>
<p>We could avoid using this uncommon style by hoisting nested modules up to their
own package. For example, <code>@ember/object/observers</code> could become
<code>@ember/observers</code> or <code>@ember/object-observers</code>. However, because I could not
find a strong technical reason against it, and because having more packages is
in tension with the explicit goal to <a href="print.html#organize-by-mental-model">make Ember feel less
overwhelming</a>, I decided it was worth the small cost.</p>
<a class="header" href="print.html#alternatives-44" id="alternatives-44"><h1>Alternatives</h1></a>
<a class="header" href="print.html#ember--prefix" id="ember--prefix"><h3><code>ember-</code> prefix</h3></a>
<p>One alternative to the <code>@ember</code> scope is to use the <code>ember-</code> prefix. This avoids
the drawbacks around scoped packages described above. However, they would be
indistinguishable from the large number of community packages that begin with
<code>ember-</code>.</p>
<a class="header" href="print.html#everything-is-a-named-export" id="everything-is-a-named-export"><h3>Everything is a Named Export</h3></a>
<p>This proposal argues that classes should be a module's default export, and any
utility functions should be a named export. That means you can never have more
than one class per module, and <em>that</em> means, inherently, more <code>import</code>
statements than a system where multiple classes can live in one module.</p>
<p>Additionally, in cases where there is not a clear &quot;primary&quot; class, this can feel
a little awkward:</p>
<pre><code class="language-js">import Route from &quot;@ember/routing/route&quot;;
import Router from &quot;@ember/routing/router&quot;;
</code></pre>
<p>One commonly proposed alternative is to say that classes become named exports,
and default exports are not used at all. The above example would become:</p>
<pre><code class="language-js">import { Route, Router } from &quot;@ember/routing&quot;;
</code></pre>
<p>In this case, classes are distinguished by being capitalized, rather than by
being a default export.</p>
<p>There is one major change coming to JavaScript and Ember that, your author
believes, deals a fatal blow to this approach: decorators.</p>
<p>If you're unfamiliar with decorators, see <a href="http://tc39.github.io/proposal-decorators/">Addy Osmani's great
overview</a>. Decorators provide a mechanism for adding declarative
annotations to classes, methods, properties and functions.</p>
<p>For example, Robert Jackson has an <a href="https://github.com/rwjblue/ember-computed-decorators">experimental library for using decorators to
annotate computed properties in a class</a>. Something
like this will probably make its way into Ember in the future:</p>
<pre><code class="language-js">import EmberObject, { computed } from &quot;@ember/object&quot;;

export default class Cat extends EmberObject {
  @computed(&quot;hairLength&quot;)
  isDomesticShortHair(hairLength) {
    return hairLength &lt; 3;
  }
}
</code></pre>
<p>Most decorators are tightly coupled to a particular class because they configure
some aspect of behavior that is only relevant to that class. If every decorator
and every class share a namespace, it is hard to identify which go with each
other.</p>
<pre><code class="language-js">import { Router, Route, resource, model, location, inject, queryParam } from &quot;@ember/routing&quot;;
</code></pre>
<p>Can you tell me which of these decorators goes with which class?</p>
<p>And this import is getting so long, you'd probably be tempted to break it up
into multiple lines <em>anyway</em>, so it's not clear that it's actually a win over
separate imports.</p>
<p>Contrast this with the same thing expressed using the rules in
this RFC:</p>
<pre><code class="language-js">import Router, { resource, location } from &quot;@ember/routing/router&quot;;
import Route, { model, inject, queryParam } from &quot;@ember/routing/route&quot;;
</code></pre>
<p>Here, the decorators are clearly tied to their class. And it's far nicer from a
refactoring perspective: if you delete a class from a file, you then delete a
single line from your imports.</p>
<p>Contrast that with making fiddly edits to a long list of named exports unrelated
to each other.</p>
<a class="header" href="print.html#unresolved-questions-38" id="unresolved-questions-38"><h1>Unresolved Questions</h1></a>
<a class="header" href="print.html#intimate-apis" id="intimate-apis"><h3>Intimate APIs</h3></a>
<p>How much do we want to provide module API for so-called &quot;intimate
APIs&quot;—technically private, but in widespread use?</p>
<a class="header" href="print.html#backwards-compatibility-for-addons" id="backwards-compatibility-for-addons"><h3>Backwards Compatibility for Addons</h3></a>
<p>How do we provide an API for addons to use modules but fall back to globals mode
in older versions of Ember? We should ensure that, at minimum, addons can
continue to support LTS releases. At the same time, it's critical that adding an
addon doesn't opt your entire application back in to the entire framework.</p>
<p>Because there is a lot of implementation-specific detail to get right here, and
because it doesn't otherwise block landing this module naming RFC, the final
design of API for addon authors should be broken out into a separate RFC.</p>
<a class="header" href="print.html#distribution" id="distribution"><h3>Distribution</h3></a>
<p>In practice, how do we ship this code to end users of Ember CLI?</p>
<p>When building client-side apps, it's very important to avoid duplicate
dependencies, which can quickly cause file size to balloon out of control.</p>
<p>Unfortunately, npm@3's de-duping is so naïve that it's likely that users would
end up in dependency hell if we shipped the framework as separate npm packages.
There's no good way to ship dependencies in version lockstep and feel confident
that they will reliably be de-duped.</p>
<p>Until Yarn usage is more widespread, and to eliminate significant complexity in
the first iteration, it probably makes sense for the first phase of
implementation to continue shipping a single npm package that Ember CLI apps can
depend on. This gives us atomic updates and makes sure you never have one piece
of the framework interacting with a different piece that is inadvertently three
versions old.</p>
<p>What this means is that, rather than shipping <code>@ember/object</code> on npm, we'd ship
a single <code>ember-source</code> (or something) package that includes the entire
framework. At build time, the Ember build process would virtually map the
<code>@ember/object</code> package to the right file inside <code>ember-source</code>. In essence, all
of the benefits of smaller bundles without the boiling hellbroth of managing
dependencies.</p>
<p>That said, because this RFC is designed with an eye towards eventually
publishing each package to npm individually, we will have that option available
to us in the future once we determine that we can do so without causing lots of
pain.</p>
<a class="header" href="print.html#addenda" id="addenda"><h1>Addenda</h1></a>
<p><em>(Ed. note: These tables are automatically generated from the scripts in the <a href="https://github.com/tomdale/ember-modules-codemod">codemod</a> repository.)</em></p>
<a class="header" href="print.html#addendum-1---table-of-module-names-and-exports-by-global" id="addendum-1---table-of-module-names-and-exports-by-global"><h2>Addendum 1 - Table of Module Names and Exports by Global</h2></a>
<table><thead><tr><th> Before                                </th><th> After                                                                      </th></tr></thead><tbody>
<tr><td> <code>Ember.$</code>                             </td><td> <code>import $ from &quot;jquery&quot;</code>                                                   </td></tr>
<tr><td> <code>Ember.A</code>                             </td><td> <code>import { A } from &quot;@ember/array&quot;</code>                                         </td></tr>
<tr><td> <code>Ember.Application</code>                   </td><td> <code>import Application from &quot;@ember/application&quot;</code>                             </td></tr>
<tr><td> <code>Ember.Array</code>                         </td><td> <code>import EmberArray from &quot;@ember/array&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.ArrayProxy</code>                    </td><td> <code>import ArrayProxy from &quot;@ember/array/proxy&quot;</code>                              </td></tr>
<tr><td> <code>Ember.AutoLocation</code>                  </td><td> <code>import AutoLocation from &quot;@ember/routing/auto-location&quot;</code>                  </td></tr>
<tr><td> <code>Ember.Checkbox</code>                      </td><td> <code>import Checkbox from &quot;@ember/component/checkbox&quot;</code>                         </td></tr>
<tr><td> <code>Ember.Component</code>                     </td><td> <code>import Component from &quot;@ember/component&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.ContainerDebugAdapter</code>         </td><td> <code>import ContainerDebugAdapter from &quot;@ember/debug/container-debug-adapter&quot;</code> </td></tr>
<tr><td> <code>Ember.Controller</code>                    </td><td> <code>import Controller from &quot;@ember/controller&quot;</code>                               </td></tr>
<tr><td> <code>Ember.DataAdapter</code>                   </td><td> <code>import DataAdapter from &quot;@ember/debug/data-adapter&quot;</code>                      </td></tr>
<tr><td> <code>Ember.DefaultResolver</code>               </td><td> <code>import GlobalsResolver from &quot;@ember/application/globals-resolver&quot;</code>        </td></tr>
<tr><td> <code>Ember.Enumerable</code>                    </td><td> <code>import Enumerable from &quot;@ember/enumerable&quot;</code>                               </td></tr>
<tr><td> <code>Ember.Evented</code>                       </td><td> <code>import Evented from &quot;@ember/object/evented&quot;</code>                              </td></tr>
<tr><td> <code>Ember.HashLocation</code>                  </td><td> <code>import HashLocation from &quot;@ember/routing/hash-location&quot;</code>                  </td></tr>
<tr><td> <code>Ember.Helper</code>                        </td><td> <code>import Helper from &quot;@ember/component/helper&quot;</code>                             </td></tr>
<tr><td> <code>Ember.Helper.helper</code>                 </td><td> <code>import { helper } from &quot;@ember/component/helper&quot;</code>                         </td></tr>
<tr><td> <code>Ember.HistoryLocation</code>               </td><td> <code>import HistoryLocation from &quot;@ember/routing/history-location&quot;</code>            </td></tr>
<tr><td> <code>Ember.LinkComponent</code>                 </td><td> <code>import LinkComponent from &quot;@ember/routing/link-component&quot;</code>                </td></tr>
<tr><td> <code>Ember.Location</code>                      </td><td> <code>import Location from &quot;@ember/routing/location&quot;</code>                           </td></tr>
<tr><td> <code>Ember.Map</code>                           </td><td> <code>import EmberMap from &quot;@ember/map&quot;</code>                                        </td></tr>
<tr><td> <code>Ember.MapWithDefault</code>                </td><td> <code>import MapWithDefault from &quot;@ember/map/with-default&quot;</code>                     </td></tr>
<tr><td> <code>Ember.Mixin</code>                         </td><td> <code>import Mixin from &quot;@ember/object/mixin&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.MutableArray</code>                  </td><td> <code>import MutableArray from &quot;@ember/array/mutable&quot;</code>                          </td></tr>
<tr><td> <code>Ember.NoneLocation</code>                  </td><td> <code>import NoneLocation from &quot;@ember/routing/none-location&quot;</code>                  </td></tr>
<tr><td> <code>Ember.Object</code>                        </td><td> <code>import EmberObject from &quot;@ember/object&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.RSVP</code>                          </td><td> <code>import RSVP from &quot;rsvp&quot;</code>                                                  </td></tr>
<tr><td> <code>Ember.Resolver</code>                      </td><td> <code>import Resolver from &quot;@ember/application/resolver&quot;</code>                       </td></tr>
<tr><td> <code>Ember.Route</code>                         </td><td> <code>import Route from &quot;@ember/routing/route&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.Router</code>                        </td><td> <code>import Router from &quot;@ember/routing/router&quot;</code>                               </td></tr>
<tr><td> <code>Ember.Service</code>                       </td><td> <code>import Service from &quot;@ember/service&quot;</code>                                     </td></tr>
<tr><td> <code>Ember.String.camelize</code>               </td><td> <code>import { camelize } from &quot;@ember/string&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.String.capitalize</code>             </td><td> <code>import { capitalize } from &quot;@ember/string&quot;</code>                               </td></tr>
<tr><td> <code>Ember.String.classify</code>               </td><td> <code>import { classify } from &quot;@ember/string&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.String.dasherize</code>              </td><td> <code>import { dasherize } from &quot;@ember/string&quot;</code>                                </td></tr>
<tr><td> <code>Ember.String.decamelize</code>             </td><td> <code>import { decamelize } from &quot;@ember/string&quot;</code>                               </td></tr>
<tr><td> <code>Ember.String.fmt</code>                    </td><td> <code>import { fmt } from &quot;@ember/string&quot;</code>                                      </td></tr>
<tr><td> <code>Ember.String.htmlSafe</code>               </td><td> <code>import { htmlSafe } from &quot;@ember/string&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.String.loc</code>                    </td><td> <code>import { loc } from &quot;@ember/string&quot;</code>                                      </td></tr>
<tr><td> <code>Ember.String.underscore</code>             </td><td> <code>import { underscore } from &quot;@ember/string&quot;</code>                               </td></tr>
<tr><td> <code>Ember.String.w</code>                      </td><td> <code>import { w } from &quot;@ember/string&quot;</code>                                        </td></tr>
<tr><td> <code>Ember.TextArea</code>                      </td><td> <code>import TextArea from &quot;@ember/component/text-area&quot;</code>                        </td></tr>
<tr><td> <code>Ember.TextField</code>                     </td><td> <code>import TextField from &quot;@ember/component/text-field&quot;</code>                      </td></tr>
<tr><td> <code>Ember.addListener</code>                   </td><td> <code>import { addListener } from &quot;@ember/object/events&quot;</code>                       </td></tr>
<tr><td> <code>Ember.addObserver</code>                   </td><td> <code>import { addObserver } from &quot;@ember/object/observers&quot;</code>                    </td></tr>
<tr><td> <code>Ember.aliasMethod</code>                   </td><td> <code>import { aliasMethod } from &quot;@ember/object&quot;</code>                              </td></tr>
<tr><td> <code>Ember.assert</code>                        </td><td> <code>import { assert } from &quot;@ember/debug&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.assign</code>                        </td><td> <code>import { assign } from &quot;@ember/polyfills&quot;</code>                                </td></tr>
<tr><td> <code>Ember.cacheFor</code>                      </td><td> <code>import { cacheFor } from &quot;@ember/object/internals&quot;</code>                       </td></tr>
<tr><td> <code>Ember.compare</code>                       </td><td> <code>import { compare } from &quot;@ember/utils&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.computed</code>                      </td><td> <code>import { computed } from &quot;@ember/object&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.computed.alias</code>                </td><td> <code>import { alias } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.and</code>                  </td><td> <code>import { and } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.bool</code>                 </td><td> <code>import { bool } from &quot;@ember/object/computed&quot;</code>                            </td></tr>
<tr><td> <code>Ember.computed.collect</code>              </td><td> <code>import { collect } from &quot;@ember/object/computed&quot;</code>                         </td></tr>
<tr><td> <code>Ember.computed.deprecatingAlias</code>     </td><td> <code>import { deprecatingAlias } from &quot;@ember/object/computed&quot;</code>                </td></tr>
<tr><td> <code>Ember.computed.empty</code>                </td><td> <code>import { empty } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.equal</code>                </td><td> <code>import { equal } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.filter</code>               </td><td> <code>import { filter } from &quot;@ember/object/computed&quot;</code>                          </td></tr>
<tr><td> <code>Ember.computed.filterBy</code>             </td><td> <code>import { filterBy } from &quot;@ember/object/computed&quot;</code>                        </td></tr>
<tr><td> <code>Ember.computed.filterProperty</code>       </td><td> <code>import { filterProperty } from &quot;@ember/object/computed&quot;</code>                  </td></tr>
<tr><td> <code>Ember.computed.gt</code>                   </td><td> <code>import { gt } from &quot;@ember/object/computed&quot;</code>                              </td></tr>
<tr><td> <code>Ember.computed.gte</code>                  </td><td> <code>import { gte } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.intersect</code>            </td><td> <code>import { intersect } from &quot;@ember/object/computed&quot;</code>                       </td></tr>
<tr><td> <code>Ember.computed.lt</code>                   </td><td> <code>import { lt } from &quot;@ember/object/computed&quot;</code>                              </td></tr>
<tr><td> <code>Ember.computed.lte</code>                  </td><td> <code>import { lte } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.map</code>                  </td><td> <code>import { map } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.mapBy</code>                </td><td> <code>import { mapBy } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.mapProperty</code>          </td><td> <code>import { mapProperty } from &quot;@ember/object/computed&quot;</code>                     </td></tr>
<tr><td> <code>Ember.computed.match</code>                </td><td> <code>import { match } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.max</code>                  </td><td> <code>import { max } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.min</code>                  </td><td> <code>import { min } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.none</code>                 </td><td> <code>import { none } from &quot;@ember/object/computed&quot;</code>                            </td></tr>
<tr><td> <code>Ember.computed.not</code>                  </td><td> <code>import { not } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.notEmpty</code>             </td><td> <code>import { notEmpty } from &quot;@ember/object/computed&quot;</code>                        </td></tr>
<tr><td> <code>Ember.computed.oneWay</code>               </td><td> <code>import { oneWay } from &quot;@ember/object/computed&quot;</code>                          </td></tr>
<tr><td> <code>Ember.computed.or</code>                   </td><td> <code>import { or } from &quot;@ember/object/computed&quot;</code>                              </td></tr>
<tr><td> <code>Ember.computed.readOnly</code>             </td><td> <code>import { readOnly } from &quot;@ember/object/computed&quot;</code>                        </td></tr>
<tr><td> <code>Ember.computed.reads</code>                </td><td> <code>import { reads } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.setDiff</code>              </td><td> <code>import { setDiff } from &quot;@ember/object/computed&quot;</code>                         </td></tr>
<tr><td> <code>Ember.computed.sort</code>                 </td><td> <code>import { sort } from &quot;@ember/object/computed&quot;</code>                            </td></tr>
<tr><td> <code>Ember.computed.sum</code>                  </td><td> <code>import { sum } from &quot;@ember/object/computed&quot;</code>                             </td></tr>
<tr><td> <code>Ember.computed.union</code>                </td><td> <code>import { union } from &quot;@ember/object/computed&quot;</code>                           </td></tr>
<tr><td> <code>Ember.computed.uniq</code>                 </td><td> <code>import { uniq } from &quot;@ember/object/computed&quot;</code>                            </td></tr>
<tr><td> <code>Ember.copy</code>                          </td><td> <code>import { copy } from &quot;@ember/object/internals&quot;</code>                           </td></tr>
<tr><td> <code>Ember.create</code>                        </td><td> <code>import { create } from &quot;@ember/polyfills&quot;</code>                                </td></tr>
<tr><td> <code>Ember.debug</code>                         </td><td> <code>import { debug } from &quot;@ember/debug&quot;</code>                                     </td></tr>
<tr><td> <code>Ember.deprecate</code>                     </td><td> <code>import { deprecate } from &quot;@ember/application/deprecations&quot;</code>              </td></tr>
<tr><td> <code>Ember.deprecateFunc</code>                 </td><td> <code>import { deprecateFunc } from &quot;@ember/application/deprecations&quot;</code>          </td></tr>
<tr><td> <code>Ember.get</code>                           </td><td> <code>import { get } from &quot;@ember/object&quot;</code>                                      </td></tr>
<tr><td> <code>Ember.getOwner</code>                      </td><td> <code>import { getOwner } from &quot;@ember/application&quot;</code>                            </td></tr>
<tr><td> <code>Ember.getProperties</code>                 </td><td> <code>import { getProperties } from &quot;@ember/object&quot;</code>                            </td></tr>
<tr><td> <code>Ember.guidFor</code>                       </td><td> <code>import { guidFor } from &quot;@ember/object/internals&quot;</code>                        </td></tr>
<tr><td> <code>Ember.inject.controller</code>             </td><td> <code>import { inject } from &quot;@ember/controller&quot;</code>                               </td></tr>
<tr><td> <code>Ember.inject.service</code>                </td><td> <code>import { inject } from &quot;@ember/service&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.inspect</code>                       </td><td> <code>import { inspect } from &quot;@ember/debug&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.instrument</code>                    </td><td> <code>import { instrument } from &quot;@ember/instrumentation&quot;</code>                      </td></tr>
<tr><td> <code>Ember.isArray</code>                       </td><td> <code>import { isArray } from &quot;@ember/array&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.isBlank</code>                       </td><td> <code>import { isBlank } from &quot;@ember/utils&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.isEmpty</code>                       </td><td> <code>import { isEmpty } from &quot;@ember/utils&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.isEqual</code>                       </td><td> <code>import { isEqual } from &quot;@ember/utils&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.isNone</code>                        </td><td> <code>import { isNone } from &quot;@ember/utils&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.isPresent</code>                     </td><td> <code>import { isPresent } from &quot;@ember/utils&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.keys</code>                          </td><td> <code>import { keys } from &quot;@ember/polyfills&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.makeArray</code>                     </td><td> <code>import { makeArray } from &quot;@ember/array&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.observer</code>                      </td><td> <code>import { observer } from &quot;@ember/object&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.on</code>                            </td><td> <code>import { on } from &quot;@ember/object/evented&quot;</code>                               </td></tr>
<tr><td> <code>Ember.onLoad</code>                        </td><td> <code>import { onLoad } from &quot;@ember/application&quot;</code>                              </td></tr>
<tr><td> <code>Ember.platform.defineProperty</code>       </td><td> <code>import { defineProperty } from &quot;@ember/polyfills&quot;</code>                        </td></tr>
<tr><td> <code>Ember.platform.hasPropertyAccessors</code> </td><td> <code>import { hasPropertyAccessors } from &quot;@ember/polyfills&quot;</code>                  </td></tr>
<tr><td> <code>Ember.removeListener</code>                </td><td> <code>import { removeListener } from &quot;@ember/object/events&quot;</code>                    </td></tr>
<tr><td> <code>Ember.removeObserver</code>                </td><td> <code>import { removeObserver } from &quot;@ember/object/observers&quot;</code>                 </td></tr>
<tr><td> <code>Ember.reset</code>                         </td><td> <code>import { reset } from &quot;@ember/instrumentation&quot;</code>                           </td></tr>
<tr><td> <code>Ember.run</code>                           </td><td> <code>import { run } from &quot;@ember/runloop&quot;</code>                                     </td></tr>
<tr><td> <code>Ember.run.begin</code>                     </td><td> <code>import { begin } from &quot;@ember/runloop&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.run.bind</code>                      </td><td> <code>import { bind } from &quot;@ember/runloop&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.run.cancel</code>                    </td><td> <code>import { cancel } from &quot;@ember/runloop&quot;</code>                                  </td></tr>
<tr><td> <code>Ember.run.debounce</code>                  </td><td> <code>import { debounce } from &quot;@ember/runloop&quot;</code>                                </td></tr>
<tr><td> <code>Ember.run.end</code>                       </td><td> <code>import { end } from &quot;@ember/runloop&quot;</code>                                     </td></tr>
<tr><td> <code>Ember.run.join</code>                      </td><td> <code>import { join } from &quot;@ember/runloop&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.run.later</code>                     </td><td> <code>import { later } from &quot;@ember/runloop&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.run.next</code>                      </td><td> <code>import { next } from &quot;@ember/runloop&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.run.once</code>                      </td><td> <code>import { once } from &quot;@ember/runloop&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.run.schedule</code>                  </td><td> <code>import { schedule } from &quot;@ember/runloop&quot;</code>                                </td></tr>
<tr><td> <code>Ember.run.scheduleOnce</code>              </td><td> <code>import { scheduleOnce } from &quot;@ember/runloop&quot;</code>                            </td></tr>
<tr><td> <code>Ember.run.throttle</code>                  </td><td> <code>import { throttle } from &quot;@ember/runloop&quot;</code>                                </td></tr>
<tr><td> <code>Ember.runInDebug</code>                    </td><td> <code>import { runInDebug } from &quot;@ember/debug&quot;</code>                                </td></tr>
<tr><td> <code>Ember.runLoadHooks</code>                  </td><td> <code>import { runLoadHooks } from &quot;@ember/application&quot;</code>                        </td></tr>
<tr><td> <code>Ember.sendEvent</code>                     </td><td> <code>import { sendEvent } from &quot;@ember/object/events&quot;</code>                         </td></tr>
<tr><td> <code>Ember.set</code>                           </td><td> <code>import { set } from &quot;@ember/object&quot;</code>                                      </td></tr>
<tr><td> <code>Ember.setOwner</code>                      </td><td> <code>import { setOwner } from &quot;@ember/application&quot;</code>                            </td></tr>
<tr><td> <code>Ember.setProperties</code>                 </td><td> <code>import { setProperties } from &quot;@ember/object&quot;</code>                            </td></tr>
<tr><td> <code>Ember.subscribe</code>                     </td><td> <code>import { subscribe } from &quot;@ember/instrumentation&quot;</code>                       </td></tr>
<tr><td> <code>Ember.tryInvoke</code>                     </td><td> <code>import { tryInvoke } from &quot;@ember/utils&quot;</code>                                 </td></tr>
<tr><td> <code>Ember.trySet</code>                        </td><td> <code>import { trySet } from &quot;@ember/object&quot;</code>                                   </td></tr>
<tr><td> <code>Ember.typeOf</code>                        </td><td> <code>import { typeOf } from &quot;@ember/utils&quot;</code>                                    </td></tr>
<tr><td> <code>Ember.unsubscribe</code>                   </td><td> <code>import { unsubscribe } from &quot;@ember/instrumentation&quot;</code>                     </td></tr>
<tr><td> <code>Ember.warn</code>                          </td><td> <code>import { warn } from &quot;@ember/debug&quot;</code>                                      </td></tr>
</tbody></table>
<a class="header" href="print.html#addendum-2---table-of-module-names-and-exports-by-package" id="addendum-2---table-of-module-names-and-exports-by-package"><h2>Addendum 2 - Table of Module Names and Exports by Package</h2></a>
<p>Each package is sorted by module name, then export name.</p>
<a class="header" href="print.html#emberapplication" id="emberapplication"><h3><code>@ember/application</code></h3></a>
<table><thead><tr><th> Module                                                              </th><th> Global                  </th></tr></thead><tbody>
<tr><td> <code>import Application from &quot;@ember/application&quot;</code>                      </td><td> <code>Ember.Application</code>     </td></tr>
<tr><td> <code>import { getOwner } from &quot;@ember/application&quot;</code>                     </td><td> <code>Ember.getOwner</code>        </td></tr>
<tr><td> <code>import { onLoad } from &quot;@ember/application&quot;</code>                       </td><td> <code>Ember.onLoad</code>          </td></tr>
<tr><td> <code>import { runLoadHooks } from &quot;@ember/application&quot;</code>                 </td><td> <code>Ember.runLoadHooks</code>    </td></tr>
<tr><td> <code>import { setOwner } from &quot;@ember/application&quot;</code>                     </td><td> <code>Ember.setOwner</code>        </td></tr>
<tr><td> <code>import { deprecate } from &quot;@ember/application/deprecations&quot;</code>       </td><td> <code>Ember.deprecate</code>       </td></tr>
<tr><td> <code>import { deprecateFunc } from &quot;@ember/application/deprecations&quot;</code>   </td><td> <code>Ember.deprecateFunc</code>   </td></tr>
<tr><td> <code>import GlobalsResolver from &quot;@ember/application/globals-resolver&quot;</code> </td><td> <code>Ember.DefaultResolver</code> </td></tr>
<tr><td> <code>import Resolver from &quot;@ember/application/resolver&quot;</code>                </td><td> <code>Ember.Resolver</code>        </td></tr>
</tbody></table>
<a class="header" href="print.html#emberarray" id="emberarray"><h3><code>@ember/array</code></h3></a>
<table><thead><tr><th> Module                                            </th><th> Global               </th></tr></thead><tbody>
<tr><td> <code>import EmberArray from &quot;@ember/array&quot;</code>           </td><td> <code>Ember.Array</code>        </td></tr>
<tr><td> <code>import { A } from &quot;@ember/array&quot;</code>                </td><td> <code>Ember.A</code>            </td></tr>
<tr><td> <code>import { isArray } from &quot;@ember/array&quot;</code>          </td><td> <code>Ember.isArray</code>      </td></tr>
<tr><td> <code>import { makeArray } from &quot;@ember/array&quot;</code>        </td><td> <code>Ember.makeArray</code>    </td></tr>
<tr><td> <code>import MutableArray from &quot;@ember/array/mutable&quot;</code> </td><td> <code>Ember.MutableArray</code> </td></tr>
<tr><td> <code>import ArrayProxy from &quot;@ember/array/proxy&quot;</code>     </td><td> <code>Ember.ArrayProxy</code>   </td></tr>
</tbody></table>
<a class="header" href="print.html#embercomponent" id="embercomponent"><h3><code>@ember/component</code></h3></a>
<table><thead><tr><th> Module                                                </th><th> Global                </th></tr></thead><tbody>
<tr><td> <code>import Component from &quot;@ember/component&quot;</code>            </td><td> <code>Ember.Component</code>     </td></tr>
<tr><td> <code>import Checkbox from &quot;@ember/component/checkbox&quot;</code>    </td><td> <code>Ember.Checkbox</code>      </td></tr>
<tr><td> <code>import Helper from &quot;@ember/component/helper&quot;</code>        </td><td> <code>Ember.Helper</code>        </td></tr>
<tr><td> <code>import { helper } from &quot;@ember/component/helper&quot;</code>    </td><td> <code>Ember.Helper.helper</code> </td></tr>
<tr><td> <code>import TextArea from &quot;@ember/component/text-area&quot;</code>   </td><td> <code>Ember.TextArea</code>      </td></tr>
<tr><td> <code>import TextField from &quot;@ember/component/text-field&quot;</code> </td><td> <code>Ember.TextField</code>     </td></tr>
</tbody></table>
<a class="header" href="print.html#embercontroller" id="embercontroller"><h3><code>@ember/controller</code></h3></a>
<table><thead><tr><th> Module                                       </th><th> Global                    </th></tr></thead><tbody>
<tr><td> <code>import Controller from &quot;@ember/controller&quot;</code> </td><td> <code>Ember.Controller</code>        </td></tr>
<tr><td> <code>import { inject } from &quot;@ember/controller&quot;</code> </td><td> <code>Ember.inject.controller</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#emberdebug" id="emberdebug"><h3><code>@ember/debug</code></h3></a>
<table><thead><tr><th> Module                                                                     </th><th> Global                        </th></tr></thead><tbody>
<tr><td> <code>import { assert } from &quot;@ember/debug&quot;</code>                                    </td><td> <code>Ember.assert</code>                </td></tr>
<tr><td> <code>import { debug } from &quot;@ember/debug&quot;</code>                                     </td><td> <code>Ember.debug</code>                 </td></tr>
<tr><td> <code>import { inspect } from &quot;@ember/debug&quot;</code>                                   </td><td> <code>Ember.inspect</code>               </td></tr>
<tr><td> <code>import { runInDebug } from &quot;@ember/debug&quot;</code>                                </td><td> <code>Ember.runInDebug</code>            </td></tr>
<tr><td> <code>import { warn } from &quot;@ember/debug&quot;</code>                                      </td><td> <code>Ember.warn</code>                  </td></tr>
<tr><td> <code>import ContainerDebugAdapter from &quot;@ember/debug/container-debug-adapter&quot;</code> </td><td> <code>Ember.ContainerDebugAdapter</code> </td></tr>
<tr><td> <code>import DataAdapter from &quot;@ember/debug/data-adapter&quot;</code>                      </td><td> <code>Ember.DataAdapter</code>           </td></tr>
</tbody></table>
<a class="header" href="print.html#emberenumerable" id="emberenumerable"><h3><code>@ember/enumerable</code></h3></a>
<table><thead><tr><th> Module                                       </th><th> Global             </th></tr></thead><tbody>
<tr><td> <code>import Enumerable from &quot;@ember/enumerable&quot;</code> </td><td> <code>Ember.Enumerable</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#emberinstrumentation" id="emberinstrumentation"><h3><code>@ember/instrumentation</code></h3></a>
<table><thead><tr><th> Module                                                 </th><th> Global              </th></tr></thead><tbody>
<tr><td> <code>import { instrument } from &quot;@ember/instrumentation&quot;</code>  </td><td> <code>Ember.instrument</code>  </td></tr>
<tr><td> <code>import { reset } from &quot;@ember/instrumentation&quot;</code>       </td><td> <code>Ember.reset</code>       </td></tr>
<tr><td> <code>import { subscribe } from &quot;@ember/instrumentation&quot;</code>   </td><td> <code>Ember.subscribe</code>   </td></tr>
<tr><td> <code>import { unsubscribe } from &quot;@ember/instrumentation&quot;</code> </td><td> <code>Ember.unsubscribe</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#embermap" id="embermap"><h3><code>@ember/map</code></h3></a>
<table><thead><tr><th> Module                                                 </th><th> Global                 </th></tr></thead><tbody>
<tr><td> <code>import EmberMap from &quot;@ember/map&quot;</code>                    </td><td> <code>Ember.Map</code>            </td></tr>
<tr><td> <code>import MapWithDefault from &quot;@ember/map/with-default&quot;</code> </td><td> <code>Ember.MapWithDefault</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#emberobject" id="emberobject"><h3><code>@ember/object</code></h3></a>
<table><thead><tr><th> Module                                                      </th><th> Global                            </th></tr></thead><tbody>
<tr><td> <code>import EmberObject from &quot;@ember/object&quot;</code>                   </td><td> <code>Ember.Object</code>                    </td></tr>
<tr><td> <code>import { aliasMethod } from &quot;@ember/object&quot;</code>               </td><td> <code>Ember.aliasMethod</code>               </td></tr>
<tr><td> <code>import { computed } from &quot;@ember/object&quot;</code>                  </td><td> <code>Ember.computed</code>                  </td></tr>
<tr><td> <code>import { get } from &quot;@ember/object&quot;</code>                       </td><td> <code>Ember.get</code>                       </td></tr>
<tr><td> <code>import { getProperties } from &quot;@ember/object&quot;</code>             </td><td> <code>Ember.getProperties</code>             </td></tr>
<tr><td> <code>import { observer } from &quot;@ember/object&quot;</code>                  </td><td> <code>Ember.observer</code>                  </td></tr>
<tr><td> <code>import { set } from &quot;@ember/object&quot;</code>                       </td><td> <code>Ember.set</code>                       </td></tr>
<tr><td> <code>import { setProperties } from &quot;@ember/object&quot;</code>             </td><td> <code>Ember.setProperties</code>             </td></tr>
<tr><td> <code>import { trySet } from &quot;@ember/object&quot;</code>                    </td><td> <code>Ember.trySet</code>                    </td></tr>
<tr><td> <code>import { alias } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.alias</code>            </td></tr>
<tr><td> <code>import { and } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.and</code>              </td></tr>
<tr><td> <code>import { bool } from &quot;@ember/object/computed&quot;</code>             </td><td> <code>Ember.computed.bool</code>             </td></tr>
<tr><td> <code>import { collect } from &quot;@ember/object/computed&quot;</code>          </td><td> <code>Ember.computed.collect</code>          </td></tr>
<tr><td> <code>import { deprecatingAlias } from &quot;@ember/object/computed&quot;</code> </td><td> <code>Ember.computed.deprecatingAlias</code> </td></tr>
<tr><td> <code>import { empty } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.empty</code>            </td></tr>
<tr><td> <code>import { equal } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.equal</code>            </td></tr>
<tr><td> <code>import { filter } from &quot;@ember/object/computed&quot;</code>           </td><td> <code>Ember.computed.filter</code>           </td></tr>
<tr><td> <code>import { filterBy } from &quot;@ember/object/computed&quot;</code>         </td><td> <code>Ember.computed.filterBy</code>         </td></tr>
<tr><td> <code>import { filterProperty } from &quot;@ember/object/computed&quot;</code>   </td><td> <code>Ember.computed.filterProperty</code>   </td></tr>
<tr><td> <code>import { gt } from &quot;@ember/object/computed&quot;</code>               </td><td> <code>Ember.computed.gt</code>               </td></tr>
<tr><td> <code>import { gte } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.gte</code>              </td></tr>
<tr><td> <code>import { intersect } from &quot;@ember/object/computed&quot;</code>        </td><td> <code>Ember.computed.intersect</code>        </td></tr>
<tr><td> <code>import { lt } from &quot;@ember/object/computed&quot;</code>               </td><td> <code>Ember.computed.lt</code>               </td></tr>
<tr><td> <code>import { lte } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.lte</code>              </td></tr>
<tr><td> <code>import { map } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.map</code>              </td></tr>
<tr><td> <code>import { mapBy } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.mapBy</code>            </td></tr>
<tr><td> <code>import { mapProperty } from &quot;@ember/object/computed&quot;</code>      </td><td> <code>Ember.computed.mapProperty</code>      </td></tr>
<tr><td> <code>import { match } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.match</code>            </td></tr>
<tr><td> <code>import { max } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.max</code>              </td></tr>
<tr><td> <code>import { min } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.min</code>              </td></tr>
<tr><td> <code>import { none } from &quot;@ember/object/computed&quot;</code>             </td><td> <code>Ember.computed.none</code>             </td></tr>
<tr><td> <code>import { not } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.not</code>              </td></tr>
<tr><td> <code>import { notEmpty } from &quot;@ember/object/computed&quot;</code>         </td><td> <code>Ember.computed.notEmpty</code>         </td></tr>
<tr><td> <code>import { oneWay } from &quot;@ember/object/computed&quot;</code>           </td><td> <code>Ember.computed.oneWay</code>           </td></tr>
<tr><td> <code>import { or } from &quot;@ember/object/computed&quot;</code>               </td><td> <code>Ember.computed.or</code>               </td></tr>
<tr><td> <code>import { readOnly } from &quot;@ember/object/computed&quot;</code>         </td><td> <code>Ember.computed.readOnly</code>         </td></tr>
<tr><td> <code>import { reads } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.reads</code>            </td></tr>
<tr><td> <code>import { setDiff } from &quot;@ember/object/computed&quot;</code>          </td><td> <code>Ember.computed.setDiff</code>          </td></tr>
<tr><td> <code>import { sort } from &quot;@ember/object/computed&quot;</code>             </td><td> <code>Ember.computed.sort</code>             </td></tr>
<tr><td> <code>import { sum } from &quot;@ember/object/computed&quot;</code>              </td><td> <code>Ember.computed.sum</code>              </td></tr>
<tr><td> <code>import { union } from &quot;@ember/object/computed&quot;</code>            </td><td> <code>Ember.computed.union</code>            </td></tr>
<tr><td> <code>import { uniq } from &quot;@ember/object/computed&quot;</code>             </td><td> <code>Ember.computed.uniq</code>             </td></tr>
<tr><td> <code>import Evented from &quot;@ember/object/evented&quot;</code>               </td><td> <code>Ember.Evented</code>                   </td></tr>
<tr><td> <code>import { on } from &quot;@ember/object/evented&quot;</code>                </td><td> <code>Ember.on</code>                        </td></tr>
<tr><td> <code>import { addListener } from &quot;@ember/object/events&quot;</code>        </td><td> <code>Ember.addListener</code>               </td></tr>
<tr><td> <code>import { removeListener } from &quot;@ember/object/events&quot;</code>     </td><td> <code>Ember.removeListener</code>            </td></tr>
<tr><td> <code>import { sendEvent } from &quot;@ember/object/events&quot;</code>          </td><td> <code>Ember.sendEvent</code>                 </td></tr>
<tr><td> <code>import { cacheFor } from &quot;@ember/object/internals&quot;</code>        </td><td> <code>Ember.cacheFor</code>                  </td></tr>
<tr><td> <code>import { copy } from &quot;@ember/object/internals&quot;</code>            </td><td> <code>Ember.copy</code>                      </td></tr>
<tr><td> <code>import { guidFor } from &quot;@ember/object/internals&quot;</code>         </td><td> <code>Ember.guidFor</code>                   </td></tr>
<tr><td> <code>import Mixin from &quot;@ember/object/mixin&quot;</code>                   </td><td> <code>Ember.Mixin</code>                     </td></tr>
<tr><td> <code>import { addObserver } from &quot;@ember/object/observers&quot;</code>     </td><td> <code>Ember.addObserver</code>               </td></tr>
<tr><td> <code>import { removeObserver } from &quot;@ember/object/observers&quot;</code>  </td><td> <code>Ember.removeObserver</code>            </td></tr>
</tbody></table>
<a class="header" href="print.html#emberpolyfills" id="emberpolyfills"><h3><code>@ember/polyfills</code></h3></a>
<table><thead><tr><th> Module                                                    </th><th> Global                                </th></tr></thead><tbody>
<tr><td> <code>import { assign } from &quot;@ember/polyfills&quot;</code>               </td><td> <code>Ember.assign</code>                        </td></tr>
<tr><td> <code>import { create } from &quot;@ember/polyfills&quot;</code>               </td><td> <code>Ember.create</code>                        </td></tr>
<tr><td> <code>import { defineProperty } from &quot;@ember/polyfills&quot;</code>       </td><td> <code>Ember.platform.defineProperty</code>       </td></tr>
<tr><td> <code>import { hasPropertyAccessors } from &quot;@ember/polyfills&quot;</code> </td><td> <code>Ember.platform.hasPropertyAccessors</code> </td></tr>
<tr><td> <code>import { keys } from &quot;@ember/polyfills&quot;</code>                 </td><td> <code>Ember.keys</code>                          </td></tr>
</tbody></table>
<a class="header" href="print.html#emberrouting" id="emberrouting"><h3><code>@ember/routing</code></h3></a>
<table><thead><tr><th> Module                                                          </th><th> Global                  </th></tr></thead><tbody>
<tr><td> <code>import AutoLocation from &quot;@ember/routing/auto-location&quot;</code>       </td><td> <code>Ember.AutoLocation</code>    </td></tr>
<tr><td> <code>import HashLocation from &quot;@ember/routing/hash-location&quot;</code>       </td><td> <code>Ember.HashLocation</code>    </td></tr>
<tr><td> <code>import HistoryLocation from &quot;@ember/routing/history-location&quot;</code> </td><td> <code>Ember.HistoryLocation</code> </td></tr>
<tr><td> <code>import LinkComponent from &quot;@ember/routing/link-component&quot;</code>     </td><td> <code>Ember.LinkComponent</code>   </td></tr>
<tr><td> <code>import Location from &quot;@ember/routing/location&quot;</code>                </td><td> <code>Ember.Location</code>        </td></tr>
<tr><td> <code>import NoneLocation from &quot;@ember/routing/none-location&quot;</code>       </td><td> <code>Ember.NoneLocation</code>    </td></tr>
<tr><td> <code>import Route from &quot;@ember/routing/route&quot;</code>                      </td><td> <code>Ember.Route</code>           </td></tr>
<tr><td> <code>import Router from &quot;@ember/routing/router&quot;</code>                    </td><td> <code>Ember.Router</code>          </td></tr>
</tbody></table>
<a class="header" href="print.html#emberrunloop" id="emberrunloop"><h3><code>@ember/runloop</code></h3></a>
<table><thead><tr><th> Module                                          </th><th> Global                   </th></tr></thead><tbody>
<tr><td> <code>import { begin } from &quot;@ember/runloop&quot;</code>        </td><td> <code>Ember.run.begin</code>        </td></tr>
<tr><td> <code>import { bind } from &quot;@ember/runloop&quot;</code>         </td><td> <code>Ember.run.bind</code>         </td></tr>
<tr><td> <code>import { cancel } from &quot;@ember/runloop&quot;</code>       </td><td> <code>Ember.run.cancel</code>       </td></tr>
<tr><td> <code>import { debounce } from &quot;@ember/runloop&quot;</code>     </td><td> <code>Ember.run.debounce</code>     </td></tr>
<tr><td> <code>import { end } from &quot;@ember/runloop&quot;</code>          </td><td> <code>Ember.run.end</code>          </td></tr>
<tr><td> <code>import { join } from &quot;@ember/runloop&quot;</code>         </td><td> <code>Ember.run.join</code>         </td></tr>
<tr><td> <code>import { later } from &quot;@ember/runloop&quot;</code>        </td><td> <code>Ember.run.later</code>        </td></tr>
<tr><td> <code>import { next } from &quot;@ember/runloop&quot;</code>         </td><td> <code>Ember.run.next</code>         </td></tr>
<tr><td> <code>import { once } from &quot;@ember/runloop&quot;</code>         </td><td> <code>Ember.run.once</code>         </td></tr>
<tr><td> <code>import { run } from &quot;@ember/runloop&quot;</code>          </td><td> <code>Ember.run</code>              </td></tr>
<tr><td> <code>import { schedule } from &quot;@ember/runloop&quot;</code>     </td><td> <code>Ember.run.schedule</code>     </td></tr>
<tr><td> <code>import { scheduleOnce } from &quot;@ember/runloop&quot;</code> </td><td> <code>Ember.run.scheduleOnce</code> </td></tr>
<tr><td> <code>import { throttle } from &quot;@ember/runloop&quot;</code>     </td><td> <code>Ember.run.throttle</code>     </td></tr>
</tbody></table>
<a class="header" href="print.html#emberservice" id="emberservice"><h3><code>@ember/service</code></h3></a>
<table><thead><tr><th> Module                                    </th><th> Global                 </th></tr></thead><tbody>
<tr><td> <code>import Service from &quot;@ember/service&quot;</code>    </td><td> <code>Ember.Service</code>        </td></tr>
<tr><td> <code>import { inject } from &quot;@ember/service&quot;</code> </td><td> <code>Ember.inject.service</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#emberstring" id="emberstring"><h3><code>@ember/string</code></h3></a>
<table><thead><tr><th> Module                                       </th><th> Global                    </th></tr></thead><tbody>
<tr><td> <code>import { camelize } from &quot;@ember/string&quot;</code>   </td><td> <code>Ember.String.camelize</code>   </td></tr>
<tr><td> <code>import { capitalize } from &quot;@ember/string&quot;</code> </td><td> <code>Ember.String.capitalize</code> </td></tr>
<tr><td> <code>import { classify } from &quot;@ember/string&quot;</code>   </td><td> <code>Ember.String.classify</code>   </td></tr>
<tr><td> <code>import { dasherize } from &quot;@ember/string&quot;</code>  </td><td> <code>Ember.String.dasherize</code>  </td></tr>
<tr><td> <code>import { decamelize } from &quot;@ember/string&quot;</code> </td><td> <code>Ember.String.decamelize</code> </td></tr>
<tr><td> <code>import { fmt } from &quot;@ember/string&quot;</code>        </td><td> <code>Ember.String.fmt</code>        </td></tr>
<tr><td> <code>import { htmlSafe } from &quot;@ember/string&quot;</code>   </td><td> <code>Ember.String.htmlSafe</code>   </td></tr>
<tr><td> <code>import { loc } from &quot;@ember/string&quot;</code>        </td><td> <code>Ember.String.loc</code>        </td></tr>
<tr><td> <code>import { underscore } from &quot;@ember/string&quot;</code> </td><td> <code>Ember.String.underscore</code> </td></tr>
<tr><td> <code>import { w } from &quot;@ember/string&quot;</code>          </td><td> <code>Ember.String.w</code>          </td></tr>
</tbody></table>
<a class="header" href="print.html#emberutils" id="emberutils"><h3><code>@ember/utils</code></h3></a>
<table><thead><tr><th> Module                                     </th><th> Global            </th></tr></thead><tbody>
<tr><td> <code>import { compare } from &quot;@ember/utils&quot;</code>   </td><td> <code>Ember.compare</code>   </td></tr>
<tr><td> <code>import { isBlank } from &quot;@ember/utils&quot;</code>   </td><td> <code>Ember.isBlank</code>   </td></tr>
<tr><td> <code>import { isEmpty } from &quot;@ember/utils&quot;</code>   </td><td> <code>Ember.isEmpty</code>   </td></tr>
<tr><td> <code>import { isNone } from &quot;@ember/utils&quot;</code>    </td><td> <code>Ember.isNone</code>    </td></tr>
<tr><td> <code>import { isPresent } from &quot;@ember/utils&quot;</code> </td><td> <code>Ember.isPresent</code> </td></tr>
<tr><td> <code>import { tryInvoke } from &quot;@ember/utils&quot;</code> </td><td> <code>Ember.tryInvoke</code> </td></tr>
<tr><td> <code>import { typeOf } from &quot;@ember/utils&quot;</code>    </td><td> <code>Ember.typeOf</code>    </td></tr>
</tbody></table>
<a class="header" href="print.html#jquery" id="jquery"><h3><code>jquery</code></h3></a>
<table><thead><tr><th> Module                   </th><th> Global    </th></tr></thead><tbody>
<tr><td> <code>import $ from &quot;jquery&quot;</code> </td><td> <code>Ember.$</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#rsvp" id="rsvp"><h3><code>rsvp</code></h3></a>
<table><thead><tr><th> Module                    </th><th> Global       </th></tr></thead><tbody>
<tr><td> <code>import RSVP from &quot;rsvp&quot;</code> </td><td> <code>Ember.RSVP</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#addendum-3---table-of-modules-with-side-effects" id="addendum-3---table-of-modules-with-side-effects"><h2>Addendum 3 - Table of Modules with Side Effects</h2></a>
<table><thead><tr><th> Module                               </th><th> Description                                </th></tr></thead><tbody>
<tr><td> <code>import &quot;@ember/extensions&quot;</code>         </td><td> Adds all of Ember's prototype extensions.  </td></tr>
<tr><td> <code>import &quot;@ember/extensions/string&quot;</code>  </td><td> Adds just <code>String</code> prototype extensions.   </td></tr>
<tr><td> <code>import &quot;@ember/extensions/array&quot;</code>   </td><td> Adds just <code>Array</code> prototype extensions.    </td></tr>
<tr><td> <code>import &quot;@ember/extensions/function&quot;</code></td><td> Adds just <code>Function</code> prototype extensions. </td></tr>
</tbody></table>
<ul>
<li>Start Date: 2016-11-18</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/178">#178</a></li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/issues/14746">#14746</a></li>
</ul>
<a class="header" href="print.html#summary-45" id="summary-45"><h1>Summary</h1></a>
<p>The <code>Ember.K</code> utility function is a low level utility that has lost most of its value today.</p>
<a class="header" href="print.html#motivation-46" id="motivation-46"><h1>Motivation</h1></a>
<p>Let's start explaining what <code>Ember.K</code> is.</p>
<p>It is an utility function to avoid boilerplace code and limit the creation of function instances
in Ember's internals. The source code for this API is the following:</p>
<pre><code class="language-js">Ember.K = function() {
  return this;
}
</code></pre>
<p>In a world of globals, writing <code>somefn: Ember.K</code> was effectively shorter
than writing</p>
<pre><code class="language-js">someFn: function() {
  return this;
}
</code></pre>
<p>and generated fewer function allocations.</p>
<p>However with the introduction of ES6 modules and the modularization of Ember
in process (#176), keeping this feature would require to design an import path for it.</p>
<p>While doable, the transpiled output is actually bigger then defining the functions
inline, specially with the ES6 shorthand method syntax, and the perf difference
of saving a few function allocations is negligible.</p>
<p>The second downside of reusing the same instance in many places is that if for
some reason the VM deoptimizes that function, that deoptimization is spreaded
across all the usages of <code>Ember.K</code>.</p>
<p>Third, the chainable nature of <code>Ember.K</code> tends to surprise the users:</p>
<pre><code class="language-js">let derp = {
  foo: Ember.K,
  bar: Ember.K,
  baz: Ember.K
}

derp.foo().bar().baz(); // O_o
</code></pre>
<p>And lastly but more importantly for simplicity. Consider the following code:</p>
<pre><code class="language-js">export default Component.extend({
  onSubmit() {}
});
</code></pre>
<p>Any JS developer will understand that this is an empty function and will probably understand
that is a placeholder to provide your own function instead. However, JS developers that come
across <code>Ember.K</code> for the first time will se this:</p>
<pre><code class="language-js">export default Component.extend({
  onSubmit: Ember.K
});
</code></pre>
<p>and will think that it is some cryptic Ember magic that they have to learn.</p>
<a class="header" href="print.html#transition-path-1" id="transition-path-1"><h1>Transition Path</h1></a>
<p>The necessary first step is to make sure Ember, Ember Data and other pieces of the
ecosystem don't use <code>Ember.K</code> internally.</p>
<p>Phased approach:</p>
<ul>
<li>Deprecate <code>Ember.K</code>: Use the deprecation API to signal the deprecation, and deprecation guide entry.
Target version will be 3.0, as usual.</li>
<li>Add rule to ember-watson</li>
<li>Do not include export path in https://github.com/emberjs/rfcs/pull/176, but include it until 3.0 in the &quot;globals&quot; build.</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-20" id="how-we-teach-this-20"><h1>How We Teach This</h1></a>
<p>Since it is a very low-level utility,
the amount of people that will have to update their code should be a limited set of developers, working mostly on addons.
This allows us to cover most use cases with the following strategy:</p>
<ul>
<li>Improve the current documentation to help developers finding the API for the first time in the future;</li>
<li>Provide an automated path forward through tooling such as <a href="https://github.com/abuiles/ember-watson">ember-watson</a>. (see Addendum 1)</li>
<li>Introduce the mandatory entry in the deprecations guide referencing the automated tooling.</li>
</ul>
<p>If this RFC is done as part of https://github.com/emberjs/rfcs/pull/176 as suggested,
it will be in the document or blog post announcing the final transition to modules.</p>
<a class="header" href="print.html#drawbacks-44" id="drawbacks-44"><h1>Drawbacks</h1></a>
<p>Although this utility is not very used, there is a chance that is used by some
addons and as a placeholder of a hook that is called a lot and would trigger
hundreds of deprecation warnings.</p>
<a class="header" href="print.html#alternatives-45" id="alternatives-45"><h1>Alternatives</h1></a>
<p>The feature could continue to exist.</p>
<a class="header" href="print.html#addenda-1" id="addenda-1"><h1>Addenda</h1></a>
<a class="header" href="print.html#addendum-1---codemod-to-automatically-remove-all-usages-of-emberk-on-any-project" id="addendum-1---codemod-to-automatically-remove-all-usages-of-emberk-on-any-project"><h2>Addendum 1 - Codemod to automatically remove all usages of <code>Ember.K</code> on any project.</h2></a>
<p>https://github.com/cibernox/ember-k-codemod</p>
<p>To use it you can install it globally and invoke the command on any app or addon.</p>
<p>The commands <strong>requires</strong> the user to decide the approach to replace occurenced of <code>Ember.K</code>. The
possible flags are <code>--empty</code> and <code>--return-this</code>.</p>
<ul>
<li><code>--empty</code> replaces <code>Ember.K</code> with an empty function. This leads to the most idiomatic and
intention-revealing code, but does not allow chaining, like the original <code>Ember.K</code> did.
Despite of that, chaining <code>Ember.K</code> was such an uncommon patterns that we thing virtually
everybody can use this option.</li>
<li><code>--return-this</code> replaces <code>Ember.K</code> with a function that just returns <code>this</code>. This allows chaining
like the original one.</li>
</ul>
<p>Example usage:</p>
<pre><code>npm install -g ember-k-codemod &amp;&amp; ember-k-codemod --empty
</code></pre>
<p>Versions of <a href="https://github.com/abuiles/ember-watson">ember-watson</a> starting in <code>0.8.5</code> wrap this
codemod so you can achieve the same transformation with it:</p>
<pre><code>ember-watson remove-ember-k --empty

// or if installed as an addon

ember watson:remove-ember-k --empty
</code></pre>
<a class="header" href="print.html#addendum-2---emberk-usage-across-published-addons" id="addendum-2---emberk-usage-across-published-addons"><h2>Addendum 2 - <code>Ember.K</code> usage across published addons</h2></a>
<pre><code>ae-select/addon/components/ae-select.js:  action: Ember.K, // action to fire on change
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-change': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-add': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-search': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:        return this.get('on-add') !== Ember.K;
antd-ember/addon/components/io-searchable-select/searchable-select.js:        return this.get('on-search') === Ember.K;
ella-list-view/addon/views/list-item.coffee:  prepareContent: Ember.K
ella-list-view/addon/views/list-item.coffee:  teardownContent: Ember.K
ella-list-view/addon/views/list.coffee:  arrayWillChange: Ember.K
ella-list-view/addon/views/list.coffee:  didScrollToTop: Ember.K
ella-list-view/addon/views/list.coffee:  didScrollToBottom: Ember.K
ella-list-view/addon/views/list.coffee:  visibleItemsDidChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:    if @didRequestRange isnt Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:    unless (@didRequestLength is Ember.K) or get(@, 'isRequestingLength')
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  sparseContentWillChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  sparseContentDidChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didReplaceSparseArrayItem: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestIndex: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestRange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestLength: Ember.K
elvis-network/addon/components/visjs-child.js:  didCreateLayer: Ember.K,
elvis-network/addon/components/visjs-child.js:  willDestroyLayer: Ember.K,
ember-animate/ember-animate.js:        willAnimateIn : Ember.K,
ember-animate/ember-animate.js:        willAnimateOut : Ember.K,
ember-animate/ember-animate.js:        didAnimateIn : Ember.K,
ember-animate/ember-animate.js:        didAnimateOut : Ember.K,
ember-animate/ember-animate.js:        _currentViewWillChange : Ember.K,
ember-aupac-typeahead/addon/components/aupac-typeahead.js:  action: Ember.K, //@public
ember-aupac-typeahead/addon/components/aupac-typeahead.js:  source : Ember.K, //@public
ember-autoresize/addon/mixins/autoresize.js:let trim = Ember.K;
ember-bootstrap/addon/components/bs-form-element.js:  setupValidations: Ember.K,
ember-bootstrap/addon/components/bs-select.js:  action: Ember.K, // action to fire on change
ember-bootstrap-components/addon/components/bs-select.js:  action: Ember.K, // action to fire on change
ember-bugsnag/app/instance-initializers/bugsnag.js:  let originalOnError = Ember.onerror || Ember.K;
ember-charts/addon/components/bubble-chart.js:      return Ember.K;
ember-charts/addon/components/bubble-chart.js:      return Ember.K;
ember-charts/addon/components/horizontal-bar-chart.js:      return Ember.K;
ember-charts/addon/components/horizontal-bar-chart.js:      return Ember.K;
ember-charts/addon/components/pie-chart.js:      return Ember.K;
ember-charts/addon/components/pie-chart.js:      return Ember.K;
ember-charts/addon/components/scatter-chart.js:      return Ember.K;
ember-charts/addon/components/scatter-chart.js:      return Ember.K;
ember-charts/addon/components/stacked-vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/stacked-vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/time-series-chart.js:      return Ember.K;
ember-charts/addon/components/time-series-chart.js:      return Ember.K;
ember-charts/addon/components/vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/mixins/legend.js:      return Ember.K;
ember-charts/addon/mixins/legend.js:      return Ember.K;
ember-charts/addon/mixins/resize-handler.js:  onResizeStart: Ember.K,
ember-charts/addon/mixins/resize-handler.js:  onResizeEnd: Ember.K,
ember-charts/addon/mixins/resize-handler.js:  onResize: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResizeStart: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResizeEnd: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResize: Ember.K,
ember-cli-adapter-pattern/tests/dummy/app/starships/starship.js:  _makeItSo: Ember.K
ember-cli-airbrake/README.md:In all cases, an `airbrake` service will be exposed. If airbrake isn't configured the airbrake service uses the Ember.K &quot;no-op&quot; function for its methods. This facilitates the usage of the airbrake service without having to add environment-checking code in your app.
ember-cli-airbrake/README.md:exist, but all its methods will be no-ops (`Ember.K`). This way your tests will still run happily even
ember-cli-airbrake/app/instance-initializers/ember-cli-airbrake.js:  let originalOnError = Ember.onerror || Ember.K;
ember-cli-analytics/addon/integrations/base.js:  trackPage: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  trackEvent: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  trackConversion: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  identify: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  alias: Ember.K
ember-cli-analytics/tests/unit/mixins/trackable-test.js:  const analytics = { trackPage: Ember.K };
ember-cli-aptible-shared/tests/unit/utils/changeset-test.js:      initialValue: Ember.K
ember-cli-aptible-shared/tests/unit/utils/changeset-test.js:      key: Ember.K
ember-cli-bugsnag/app/instance-initializers/bugsnag.js:      const originalDidTransition = router.didTransition || Ember.K;
ember-cli-coreweb/app/initializers/ember-coreweb.js:  initialize: Ember.K
ember-cli-dialog/packages/ember-dialog/lib/ember-initializer.js:// var K = Ember.K;
ember-cli-dimple/addon/components/dimple-chart/component.coffee:  customizeChart: Ember.K
ember-cli-dimple/addon/components/dimple-chart/component.js:  customizeChart: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResizeStart: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResizeEnd: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResize: Ember.K,
ember-cli-dynamic-forms/addon/components/dynamic-form.js:  renderSchema: Ember.K,
ember-cli-erraroo/addon/erraroo.js:    const oldEmberOnerror = Ember.onerror || Ember.K;
ember-cli-fullpagejs-view/addon/initializers/remove-fullpage.js:  initialize: Ember.K
ember-cli-infinite-scroll/addon/mixins/infinite-scroll.js:  beforeInfiniteQuery: Ember.K,
ember-cli-ion-rangeslider/addon/ember-ion-rangeslider.js:          onChange: Ember.K,
ember-cli-ion-rangeslider/addon/ember-ion-rangeslider.js:      options.onFinish = Ember.K;
ember-cli-jsoneditor/addon/components/json-editor.js:  onChange: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onError: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onModeChange: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onEditable: Ember.K,
ember-cli-maskedinput/addon/components/masked-input.js:  'on-change': Ember.K,
ember-cli-nvd3/addon/components/nvd3-chart.js:  beforeSetup: Ember.K,
ember-cli-nvd3/addon/components/nvd3-chart.js:  afterSetup: Ember.K,
ember-cli-nvd3-multichart/addon/components/nvd3-multichart.js:  chartContextFn: Ember.K,
ember-cli-remote-inspector/tests/acceptance.js:    this.ember.kill('SIGINT');
ember-cli-remote-inspector/tests/acceptance.js:    this.ember.kill('SIGINT');
ember-cli-selectize/addon/components/ember-selectize.js:  _groupedContentArrayWillChange: Ember.K,
ember-cli-visjs/addon/components/visjs-child.js:  didCreateLayer: Ember.K,
ember-cli-visjs/addon/components/visjs-child.js:  willDestroyLayer: Ember.K,
ember-collection/addon/components/ember-collection.js:          willChange: Ember.K,
ember-collection/addon/components/ember-collection.js:          willChange: Ember.K,
ember-concurrency/addon/utils.js:      let disposer = typeof maybeDisposer === 'function' ? maybeDisposer : Ember.K;
ember-confirm-dialog/addon/components/confirm-dialog.js:  confirmAction: Ember.K,//optional action executed when user confirms the dialog
ember-confirm-dialog/addon/components/confirm-dialog.js:  cancelAction: Ember.K,//optional action executed when user cancels confirmation dialog
ember-cookie-consent-cnil/app/mixins/click-else-where.js:  onOutsideClick: Ember.K,
ember-data-model-fragments/addon/states.js:  propertyWasReset: Ember.K,
ember-data-model-fragments/addon/states.js:  becomeDirty: Ember.K,
ember-data-model-fragments/addon/states.js:  rolledBack: Ember.K,
ember-data-model-fragments/addon/states.js:      pushedData: Ember.K,
ember-data-model-fragments/addon/states.js:      didCommit: Ember.K,
ember-data-sails/addon/initializers/ember-data-sails.js:      methods[level] = Ember.K;
ember-dev-fixtures/private/utils/dev-fixtures/module.js:      define(this.get('fullPath'), ['exports'], Ember.K);
ember-dp-map/addon/components/_dp-base-map-element.js:  didLoadMap: Ember.K
ember-drag-drop/addon/mixins/droppable.js:  acceptDrop: Ember.K,
ember-drag-drop/addon/mixins/droppable.js:  handleDragOver: Ember.K,
ember-drag-drop/addon/mixins/droppable.js:  handleDragOut: Ember.K,
ember-form-object/tests/unit/forms/model-form-test.js:  }).catch(Ember.K);
ember-froala/addon/components/froala-editor.js:        var buttons = this.get('customButtons') || Ember.K;
ember-google-charts/tests/integration/components/options-change-test.js:    this.on('chartDidRender', Ember.K);
ember-img-cache/app/initializers/ember-img-cache.js:  initialize: Ember.K
ember-img-manager/app/utils/img-manager/img-clone-holder.js:  this.handler = Ember.K;
ember-img-manager/app/utils/img-manager/img-clone-holder.js:      this.handler = Ember.K;
ember-img-manager/app/utils/img-manager/img-clone-holder.js:   * @param {Function} [handler=Ember.K]
ember-img-manager/app/utils/img-manager/img-clone-holder.js:    this.handler = handler || Ember.K;
ember-infinity/tests/unit/mixins/route-test.js:      pushObjects: Ember.K,
ember-infinity/tests/unit/mixins/route-test.js:        pushObjects: Ember.K,
ember-infinity/tests/unit/mixins/route-test.js:        pushObjects: Ember.K,
ember-jsonapi-resources/addon/adapters/application.js:    let cleanup = Ember.K;
ember-jsonapi-resources/tests/unit/adapters/application-test.js:  adapter.serializer = {deserialize: sandbox.spy(), deserializeIncluded: Ember.K};
ember-jsonapi-resources/tests/unit/adapters/application-test.js:  adapter.serializer = { deserialize: sandbox.spy(), deserializeIncluded: Ember.K };
ember-jsonapi-resources/tests/unit/mixins/fetch-test.js:  this.subject.serializer = { deserialize: function(res) { return res.data; }, deserializeIncluded: Ember.K };
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:        trigger: Ember.K
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:      guns: {kind: 'hasMany', mapBy: Ember.K }, // hasMany('guns')
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:      horse: {kind: 'hasOne', get: Ember.K } // hasOne('horse')
ember-jsonapi-resources-form/addon/components/resource-form.js:    if (!action) { return Ember.K; /* fail silently if no action */ }
ember-jsonapi-resources-list/addon/mixins/controllers/jsonapi-list.js:    filtering: Ember.K,
ember-key-responder/app/key-responder.js:    comments for Ember.KeyResponderStack above for more insight.
ember-list-card/addon/components/list-card/header-dropdown-item.js:   onSelect: Ember.K,
ember-list-card/addon/components/list-card/header-dropdown-item.js:   onDeselect: Ember.K,
ember-list-card/addon/components/list-card/header-dropdown.js:  onItemSelect: Ember.K,
ember-list-card/addon/components/list-card/header.js:  onQueryOptionSelect: Ember.K,
ember-material-design/addon/mixins/events.js:    start: Ember.K,
ember-material-design/addon/mixins/events.js:    move: Ember.K,
ember-material-design/addon/mixins/events.js:    end: Ember.K
ember-material-design/addon/mixins/gesture-events.js:    onStart: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onMove: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onEnd: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onCancel: Ember.K,
ember-material-design/app/services/ripple.js:            return Ember.K;
ember-metrics/tests/dummy/app/metrics-adapters/local-dummy-adapter.js:  init: Ember.K,
ember-metrics/tests/dummy/app/metrics-adapters/local-dummy-adapter.js:  willDestroy: Ember.K
ember-mixpanel/addon/mixpanel.js:          return Ember.K;
ember-mixpanel/addon/mixpanel.js:      return Ember.K;
ember-notifyme/addon/objects/notification-message.js:  onClick: Ember.K,
ember-notifyme/addon/objects/notification-message.js:  onClose: Ember.K,
ember-notifyme/addon/services/notification-service.js:           onClick: options.onClick || Ember.K,
ember-notifyme/addon/services/notification-service.js:           onClose: options.onClose || Ember.K,
ember-notifyme/addon/services/notification-service.js:           onCloseTimeout: options.onCloseTimeout || Ember.K,
ember-off-canvas-components/addon/initializers/custom-events.js:  initialize: Ember.K
ember-pardon/addon/mixins/ember-pardon.js:	beforeDestroy: Ember.K,
ember-phoenix-channel/tests/integration/components/socket-message-log-test.js:  on: Ember.K
ember-pikaday/addon/components/pikaday-inputless.js:  onPikadayOpen: Ember.K,
ember-pikaday/addon/components/pikaday-inputless.js:  onPikadayClose: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onOpen: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onClose: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onSelection: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onDraw: Ember.K,
ember-pikaday-with-time/addon/components/pikaday-input.js:  onPikadayOpen: Ember.K,
ember-pikaday-with-time/addon/components/pikaday-input.js:  onPikadayRedraw: Ember.K,
ember-processes/addon/utils.js:      let disposer = typeof maybeDisposer === 'function' ? maybeDisposer : Ember.K;
ember-render-stack/addon/route-mixin.js:  renderStack: Ember.K,
ember-restless/dist/ember-restless.js:  var noop = Ember.K;
ember-restless/dist/ember-restless.js:    _onPropertyChange: Ember.K
ember-restless/src/model/read-only-model.js:  _onPropertyChange: Ember.K
ember-restless/src/model/state.js:var noop = Ember.K;
ember-reveal-js/addon/components/reveal-presentation/component.js:      before: Ember.K,
ember-rl-dropdown/addon/mixins/rl-dropdown-component.js:  onOpen: Ember.K,
ember-rl-dropdown/addon/mixins/rl-dropdown-component.js:  onClose: Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-change': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-add': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-search': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-close': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:    return this.get('on-add') !== Ember.K;
ember-searchable-select/addon/components/searchable-select.js:    return this.get('on-search') === Ember.K;
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-change                 | Specify your own named action to trigger when the selection changes. eg. &lt;code&gt;(action &quot;update&quot;)&lt;/code&gt; &lt;br&gt; For single selection (default behaviour), the selected object is sent as an argument. For multiple selections, an array of options is sent. | Ember action  | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-add                    | Allow unfound items to be added to the content array by specifying your own named action. eg. `(action &quot;addNew&quot;)` The new item name is sent as an argument. You must handle adding the item to the content array and selecting the new item outside the component. | Ember action  | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    provided.     | Ember action    | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-close                  | Specify your own named action to trigger when the menu closes. Useful hook for clearing out content that was previously passed in with AJAX. | Ember action | Ember.K
ember-select-list/addon/components/select-list.js:  action: Ember.K, // action to fire on change
ember-smart-banner/addon/components/smart-banner.js:      const visitFn = Ember.getWithDefault(this, 'attrs.onvisit', Ember.K);
ember-smart-banner/addon/components/smart-banner.js:      const closeFn = Ember.getWithDefault(this, 'attrs.onclose', Ember.K);
ember-sqlite-adapter/addon/migration.js:  run: Ember.K,
ember-stripe-service/addon/services/stripe.js:      this.card[name] = Ember.K;
ember-table/addon/components/ember-table.js:    addColumn: Ember.K,
ember-table/addon/components/ember-table.js:    sortByColumn: Ember.K
ember-table/addon/mixins/mouse-wheel-handler.js:  onMouseWheel: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResizeStart: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResizeEnd: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResize: Ember.K,
ember-table/addon/mixins/scroll-handler.js:  onScroll: Ember.K,
ember-table/addon/mixins/touch-move-handler.js:  onTouchMove: Ember.K,
ember-table/addon/models/column-definition.js:  setCellContent: Ember.K,
ember-table/addon/views/lazy-item.js:  prepareContent: Ember.K,
ember-table/addon/views/lazy-item.js:  teardownContent: Ember.K,
ember-ted-select/README.md:      &lt;td&gt;&lt;code&gt;Ember.K&lt;/code&gt; (noop)&lt;/td&gt;
ember-ted-select/tests/dummy/app/pods/application/template.hbs:        &lt;td&gt;&lt;code&gt;Ember.K&lt;/code&gt; (noop)&lt;/td&gt;
ember-theater/addon/ember-theater/director/directions/sound.js:  fadeTo(volume, duration, callback = Ember.K) {
ember-to-string/tests/unit/helpers/to-string-test.js:    lookup: Ember.K
ember-ui-components/addon/mixins/click-outside.js:  handleClickOutside: Ember.K,
ember-unauthorized/tests/unit/mixins/access-test.js:  subject.set('authorize', Ember.K);
ember-unauthorized/tests/unit/mixins/access-test.js:  subject.set('authorize', Ember.K);
ember-unauthorized/tests/unit/mixins/route-access-test.js:      transitionTo: Ember.K
ember-watson/tests/fixtures/resource-router-mapping/new-complex-ember-cli-sample.js:    }, Ember.K);
ember-watson/tests/fixtures/resource-router-mapping/old-complex-ember-cli-sample.js:    this.resource('dashboard', Ember.K);
emberx-select/addon/components/x-select.js:  &quot;on-blur&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-click&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-change&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-focus-out&quot;: Ember.K,
fireplace/addon/collections/indexed.js:      then(Ember.K.bind(this));
fireplace/addon/collections/object.js:    const promise = this.listenToFirebase().then(Ember.K.bind(this));
justa-table/addon/components/table-vertical-collection.js:  'on-row-click': Ember.K
list-view/addon/list-view-mixin.js:  _scrollTo: Ember.K,
list-view/addon/list-view-mixin.js:  arrayWillChange: Ember.K,
list-view/addon/reusable-list-item-view.js:  prepareForReuse: Ember.K,
mantel/addon/fireplace/collections/indexed.js:      then(Ember.K.bind(this));
mantel/addon/fireplace/collections/object.js:    var promise = this.listenToFirebase().then(Ember.K.bind(this));
plaid/addon/mixins/dimensions.js:  didMeasureDimensions: Ember.K,
plaid/addon/mixins/global-resize.js:  didResize: Ember.K
spree-ember-paypal-express/addon/services/paypal-express.js:  spree: Ember.K,
torii/addon/services/torii-session.js:  setUnknownProperty: Ember.K,
torii/tests/unit/redirect-handler-test.js:    close: Ember.K
torii/tests/unit/services/popup-test.js:    focus: Ember.K,
torii/tests/unit/services/popup-test.js:    close: Ember.K
</code></pre>
<a class="header" href="print.html#addendum-3---emberk-usage-via-destructuring-across-published-addons" id="addendum-3---emberk-usage-via-destructuring-across-published-addons"><h2>Addendum 3 - <code>Ember.K</code> usage via destructuring across published addons</h2></a>
<pre><code>CogAuth/tests/helpers/flash-message.js:const { K } = Ember;
ember-annotative-models/addon/utils/action.coffee:{K, isBlank, A} = Ember
ember-annotative-models/tests/unit/utils/action-test.coffee:{K} = Ember
ember-cli-airbrake/addon/utils/get-client.js:const { K } = Ember;
ember-cli-flash/blueprints/ember-cli-flash/files/tests/helpers/flash-message.js:const { K } = Ember;
ember-cli-mapkit/addon/components/ui-abstract-map.js:const {isEmpty, computed, on, K, run} = Ember;
ember-cli-pixijs/addon/components/pixi-canvas.js:const { Component, computed, K } = Ember;
ember-click-outside/addon/mixins/click-outside.js:const { computed, K } = Ember;
ember-composable-helpers/addon/-private/create-needle-haystack-helper.js:const { K, isEmpty } = Ember;
ember-composable-helpers/tests/unit/helpers/pipe-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-composable-helpers/tests/unit/helpers/queue-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-d3-helpers/tests/unit/helpers/d3-line-test.js:const { K } = Ember;
ember-form-object/addon/forms/model-form.js:const { ObjectProxy, computed, computed: { readOnly }, assert, Logger, run, A: createArray, K: noop, String: { camelize } } = Ember;
ember-form-tool/addon/mixins/drag-drop.coffee:{K, Mixin, computed: {equal}} = Ember
ember-functional-helpers/addon/-private/create-needle-haystack-helper.js:const { K, isEmpty } = Ember;
ember-functional-helpers/tests/unit/helpers/pipe-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-functional-helpers/tests/unit/helpers/queue-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-imdt-magic-crud/tests/helpers/flash-message.js:const { K } = Ember;
ember-keyword-complete/addon/components/keyword-complete.js:const {observer, computed, run, assert, K, $} = Ember;
ember-leaflet/addon/components/base-layer.js:const { assert, computed, Component, run, K, A, String: { classify } } = Ember;
ember-light-table/tests/helpers/responsive.js:const { K, getOwner } = Ember;
ember-metrics/tests/unit/services/metrics-test.js:const { get, set, K } = Ember;
ember-paper/addon/components/paper-autocomplete.js:const { assert, computed, inject, isNone, defineProperty, K: emberNop } = Ember;
ember-paper/addon/mixins/events-mixin.js:const { Mixin, K } = Ember;
ember-redux/app/services/redux.js:const { assert, isArray, K } = Ember;
ember-responsive/blueprints/ember-responsive/files/tests/helpers/responsive.js:const { K, getOwner } = Ember;
ember-select-box/addon/mixins/select-box/select-box/inputtable.js:const { K } = Ember;
ember-shepherd/addon/services/tour.js:const { Evented, K, Service, isPresent, run, $, isEmpty, observer } = Ember;
ember-simple-auth/addon/session-stores/cookie.js:const { RSVP, computed, run: { next, cancel, later, scheduleOnce }, isEmpty, typeOf, testing, isBlank, isPresent, K, A } = Ember;
ember-simple-auth/tests/unit/internal-session-test.js:const { RSVP, K, run: { next } } = Ember;
ember-simple-auth/tests/unit/session-stores/shared/store-behavior.js:const { run: { next }, K } = Ember;
ember-simple-auth-chrome-app/tests/unit/session-stores/shared/store-behavior.js:const { K, run: { next } } = Ember;
ember-sinon-qunit/tests/helpers/assert-sinon-in-test-context.js:const { K: EmptyFunc, typeOf } = Ember;
ember-user-activity/tests/unit/services/user-activity-test.js:const { A: emberArray, K: noOp, typeOf } = Ember;
ui-bootstrap/tests/helpers/flash-message.js:const { K } = Ember;
yes-or-no/tests/helpers/responsive.js:const { K, getOwner } = Ember;
</code></pre>
<ul>
<li>Start Date: 2016-11-22</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-46" id="summary-46"><h1>Summary</h1></a>
<p>The goal of this RFC is to remove the <code>data-adapter</code>, <code>injectStore</code>,
<code>transforms</code>, and <code>store</code> Ember application initializers that Ember Data injects
into apps.  The <code>ember-data</code> initializer will not be changed and any code
that previously depended on the ordering of these initializers (via
the <code>before</code> or <code>after</code> properties on an initalizer) can be
changed to use the <code>ember-data</code> initializers for ordering.</p>
<a class="header" href="print.html#motivation-47" id="motivation-47"><h1>Motivation</h1></a>
<p>The initializers <code>data-adapter</code>, <code>injectStore</code>, <code>transforms</code>, and
<code>store</code> have not been used by Ember Data since
<a href="https://github.com/emberjs/data/commit/d25e23f622a3677b8372db535b2ab824ad306a16">Apr 8, 2014</a>. However,
they are still injected into every Ember app that depends on Ember
Data because existing apps may depend on these initializers
for ordering their own initializers to run before or after Ember
Data's setup code.</p>
<p>Removing these initializers will help reduce the amount of code Ember
Data needs to support.</p>
<p>Since these initializers are noop functions that run after the
<code>ember-data</code> initializer, any initializers that depends on one of the
deprecated initializers listed in this rfc can easly be replaced by
depending on the <code>ember-data</code> initializer instead.</p>
<a class="header" href="print.html#detailed-design-45" id="detailed-design-45"><h1>Detailed design</h1></a>
<p>Ember Data's instance initializer will start checking for any
initializers whose <code>before</code> or <code>after</code> properties depend on one of
these deprecated initalizer. If it finds an initalizer that references
one of the deprecated initalizers, Ember Data will then log a
deprecation message that states the name of the offending initalizers
and suggest changing the <code>before</code> or <code>after</code> property (the deprecation
message will refer to the correct property dynamically) to depend on
Ember Data instead.</p>
<p>This deprecation message will continue to appear until Ember Data
3.0.0 when these initalizers and the deprecation code will be finally
removed.</p>
<a class="header" href="print.html#how-we-teach-this-21" id="how-we-teach-this-21"><h1>How We Teach This</h1></a>
<p>This change should have no impact on how we teach Ember or Ember
Data. The initalizers that will be removed have been unused for a long
time and are not mentioned anywhere in today's guides or API docs.</p>
<p>Users who need to run initalizer code before or after Ember Data
injects the store into routes should be taught to use <code>before: 'ember-data'</code>, or <code>after: 'ember-data'</code> on their initializers.</p>
<a class="header" href="print.html#drawbacks-45" id="drawbacks-45"><h1>Drawbacks</h1></a>
<ul>
<li>This change will require users who depend on these deprecated initalizers to update their code.</li>
</ul>
<a class="header" href="print.html#alternatives-46" id="alternatives-46"><h1>Alternatives</h1></a>
<ul>
<li>We could leave the noop initalizers in Ember Data and continue to support them in Ember Data 3.0.0 and beyond.</li>
</ul>
<a class="header" href="print.html#unresolved-questions-39" id="unresolved-questions-39"><h1>Unresolved questions</h1></a>
<p>None</p>
<ul>
<li>Start Date: 2016/12/05</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/186</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-47" id="summary-47"><h1>Summary</h1></a>
<p>Track unique history location states</p>
<a class="header" href="print.html#motivation-48" id="motivation-48"><h1>Motivation</h1></a>
<p>The path alone does not provide enough information. For example, if you
visit page A, scroll down, then click on a link to page B, then click on
a link back to page A. Your actual browser history stack is [A, B, A].
Each of those nodes in the history should have their own unique scroll
position. In order to record this position we need a UUID
for each node in the history.</p>
<p>This API will allow other libraries to reflect upon each location to
determine unique state. For example,
<a href="https://github.com/dollarshaveclub/ember-router-scroll">ember-router-scroll</a>
is making use of a <a href="https://github.com/dollarshaveclub/ember-router-scroll/blob/master/addon/locations/router-scroll.js">modified <code>Ember.HistoryLocation</code> object to get this
behavior</a>.</p>
<p>Tracking unique state is required when setting the scroll position
properly based upon where you are in the history stack, as described in
<a href="print.html#motivation">Motivation</a></p>
<a class="header" href="print.html#detailed-design-46" id="detailed-design-46"><h1>Detailed design</h1></a>
<p>Code: <a href="https://github.com/emberjs/ember.js/pull/14011">PR#14011</a></p>
<p>We simply unique identifier (UUID) so we can track uniqueness on two
dimensions. Both <code>path</code> and the generated <code>uuid</code>. A simple UUID
generator such as
https://gist.github.com/lukemelia/9daf074b1b2dfebc0bd87552d0f6a537
should suffice.</p>
<a class="header" href="print.html#how-we-teach-this-22" id="how-we-teach-this-22"><h1>How We Teach This</h1></a>
<p>We could describe what meta data is generated for each location in the
history stack. For example, it could look like:</p>
<pre><code class="language-js">// visit page A

[
  { path: '/', uuid: 1 }
]

// visit page B

[
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]

// visit page A

[
  { path: '/', uuid: 3 },
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]

// click back button

[
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]
</code></pre>
<a class="header" href="print.html#drawbacks-46" id="drawbacks-46"><h1>Drawbacks</h1></a>
<ul>
<li>The property access is writable</li>
</ul>
<a class="header" href="print.html#alternatives-47" id="alternatives-47"><h1>Alternatives</h1></a>
<p>The purpose for this behavior is to enable scroll position libraries.
There are two other solutions in the wild. One is in the guides that
suggests resetting the scroll position to <code>(0, 0)</code> on each new route
entry. The other is
<a href="https://github.com/ef4/memory-scroll">ember-memory-scroll</a> which I
believe is better suited for tracking scroll positions for components
rather than the current page.</p>
<p>However, in both cases neither solution provides the experience that
users have come to expect from server-rendered pages. The browser tracks
scroll position and restores it when you revisit the page in the history
stack. The scroll position is unique even if you have multiple instances
of the same page in the stack.</p>
<a class="header" href="print.html#unresolved-questions-40" id="unresolved-questions-40"><h1>Unresolved questions</h1></a>
<p>None at this time.</p>
<ul>
<li>Start Date: 2016-12-14</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/191">#191</a></li>
<li>Ember Issue: <a href="https://github.com/emberjs/ember.js/pull/14711">#14711</a></li>
</ul>
<a class="header" href="print.html#summary-48" id="summary-48"><h1>Summary</h1></a>
<p>We would like to deprecate and remove the <strong>arguments</strong> passed to the <code>didInitAttrs</code>, <code>didReceiveAttrs</code> and <code>didUpdateAttrs</code> component lifecycle hooks. These arguments are currently undocumented on purpose and considered a private API, imposes an unnecessary performance hit on <em>all</em> components whether they are used or not, and can be easily replicated by the users in cases where they are needed.</p>
<a class="header" href="print.html#motivation-49" id="motivation-49"><h1>Motivation</h1></a>
<p>In the road leading up to Ember.js 2.0, <a href="http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html#toc_component-lifecycle-hooks">new lifecycle hooks</a> were introduced to components in order to help users shift to a new mental model, dubbed Data Down Actions Up. The hooks were introduced by name, and their semantics explained, but there were no mentions of possible arguments received by them.</p>
<p>This lack of documentation for lifecycle hook arguments was deliberate. The hooks were introduced as an experiment with an eye to the then-upcoming angle bracket components, so the arguments to the hooks were considered private by the framework maintainers, as their design was still ongoing.</p>
<p>However, references to the lifecycle hook arguments started appearing in community resources. Users started betting on these arguments as the way forward, which in conjunction with the lack of an RFC process and clear messaging from the Ember.js maintainers lead to confusion.</p>
<p>This left the core team in a difficult position. Despite no longer endorsing lifecycle hook arguments, trying to communicate such could have the reverse effect by pointing a spotlight at them. The purpose of this RFC is then to clarify that lifecycle hook arguments have no future in the framework, and you should update your code to not make use of them.</p>
<p>The reason to officially deprecate lifecycle hook arguments is not only about messaging, but also because providing these arguments imposes an unnecessary performance penalty to every component in your application even if the arguments are not used.</p>
<p>To provide the arguments to the lifecycle hooks, Ember.js has to eagerly &quot;reify&quot; and save-off any passed-in attributes to allow diffing and construct several wrapper objects. In the few occasions where this logic is actually necessary, developers should be able to use programmatic patterns familiar to them and manually track changes as needed, as exemplified in the Transition Path section below.</p>
<a class="header" href="print.html#transition-path-2" id="transition-path-2"><h1>Transition Path</h1></a>
<p>The transition path followed will be the standard one, which encompasses using the deprecation API to deprecate the feature and the related deprecation guide. While the lifecycle hooks share a deprecation identifier, they will be addressed in turn.</p>
<a class="header" href="print.html#didinitattrs" id="didinitattrs"><h3><code>didInitAttrs</code></h3></a>
<p>Since this lifecycle hook is <a href="http://emberjs.com/deprecations/v2.x/#toc_ember-component-didinitattrs">already deprecated</a>, we suggest taking this chance to address two deprecations at the same time. Imagine you have a component that stores a timestamp when it's initialized for later comparison.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didInitAttrs({ attrs }) {
    this.set('initialTimestamp', attrs.timestamp);
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  init() {
    this._super(...arguments);

    this.set('initialTimestamp', this.get('timestamp'));
  }
});
</code></pre>
<a class="header" href="print.html#didreceiveattrs" id="didreceiveattrs"><h3><code>didReceiveAttrs</code></h3></a>
<p>Let's say you want to animate a map widget from the old coordinates to the new coordinates.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didReceiveAttrs({ oldAttrs, newAttrs }) {
    if (oldAttrs &amp;&amp; oldAttrs.coordinates !== newAttrs.coordinates) {
      this.map.move({ from: oldAttrs.coordinates, to: newAttrs.coordinates });
    }
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didReceiveAttrs() {
    let oldCoordinates = this.get('_previousCoordinates');
    let newCoordinates = this.get('coordinates');

    if (oldCoordinates &amp;&amp; oldCoordinates !== newCoordinates) {
      this.map.move({ from: oldCoordinates, to: newCoordinates });
    }

    this.set('_previousCoordinates', newCoordinates);
  }
});
</code></pre>
<a class="header" href="print.html#didupdateattrs" id="didupdateattrs"><h3><code>didUpdateAttrs</code></h3></a>
<p>This hook is very similar to <code>didReceiveAttrs</code>, except it only runs on re-renders and not the initial render.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didUpdateAttrs({ oldAttrs, newAttrs }) {
    if (oldAttrs &amp;&amp; oldAttrs.coordinates !== newAttrs.coordinates) {
      this.map.move({ from: oldAttrs.coordinates, to: newAttrs.coordinates });
    }
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didUpdateAttrs() {
    let oldCoordinates = this.get('_previousCoordinates');
    let newCoordinates = this.get('coordinates');

    if (oldCoordinates &amp;&amp; oldCoordinates !== newCoordinates) {
      this.map.move({ from: oldCoordinates, to: newCoordinates });
    }

    this.set('_previousCoordinates', newCoordinates);
  }
});
</code></pre>
<a class="header" href="print.html#how-we-teach-this-23" id="how-we-teach-this-23"><h1>How We Teach This</h1></a>
<p>Due to the previous undocumented nature of the arguments, there is no official documentation that will require updating deprecated usage.</p>
<p>As required for framework deprecations, there will be a deprecation guide written up and linked from within the deprecation message. This deprecation guide will address the more common usage patterns associated with lifecycle hook arguments, such as the Transition Path example.</p>
<p>Additionally, the usage patterns present in the deprecation guide could also be documented in the component section of the official Guides, as a proactive approach for teaching newcomers.</p>
<a class="header" href="print.html#drawbacks-47" id="drawbacks-47"><h1>Drawbacks</h1></a>
<p>One immediate drawback of this proposal is that due to references to the arguments in community resources, there are uses of them in the wild. Updating deprecated code will have to be done mostly manually, as automation might prove difficult.</p>
<p>Another drawback is that by the very nature of publishing this RFC, attention will be drawn to the arguments. It is our hope that the increased awareness will be a net positive due to the clear guidance gained by users of the framework.</p>
<p>It is then our assessment that these drawbacks are outweighed by the benefits of the change.</p>
<a class="header" href="print.html#alternatives-48" id="alternatives-48"><h1>Alternatives</h1></a>
<p>There are two standout alternatives to the proposal presented here which are doing nothing, or making the arguments public and supporting them going forward, both of which are less than ideal for reasons stated previously.</p>
<p>Doing nothing would perpetuate the confusion surrounding lifecycle hook arguments. While it might be argued that that ship has sailed, we prefer to think that it's never too late to provide users of the framework with clearer messaging regarding usage of certain features.</p>
<p>Making the arguments public and supported would mean supporting APIs that did not go through the RFC process, meaning they do not align with some of the current values of the framework, nor would iteration on them would be possible without introducing breakage. Additionally, there are some performance penalties to supporting these arguments, mentioned in the Motivation section.</p>
<a class="header" href="print.html#unresolved-questions-41" id="unresolved-questions-41"><h1>Unresolved questions</h1></a>
<p>None.</p>
<ul>
<li>Start Date: 2016-12-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/194</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/14754</li>
</ul>
<a class="header" href="print.html#summary-49" id="summary-49"><h1>Summary</h1></a>
<p>Support for component <code>eventManger</code>s is a seldom used feature and should
be deprecated.</p>
<a class="header" href="print.html#motivation-50" id="motivation-50"><h1>Motivation</h1></a>
<p>We should strive to simplify the Ember API and source code where possible. As
the custom <code>eventManager</code> feature is rarely used in apps, we should deprecate
it.</p>
<a class="header" href="print.html#detailed-design-47" id="detailed-design-47"><h1>Detailed design</h1></a>
<p>We'll introduce a deprecation warning which will be displayed when a component
defines an <code>eventManager</code> property or when <code>canDispatchToEventManager</code> is set to
true on <code>EventDispatcher</code>. The warning will have a target version of <code>3.0</code>.</p>
<p>If required, we can create an addon which extends the <code>EventDispatcher</code> allowing
for opt-in custom <code>eventManager</code>s in Ember apps.</p>
<a class="header" href="print.html#how-we-teach-this-24" id="how-we-teach-this-24"><h1>How We Teach This</h1></a>
<p>As this is a seldom used feature, we can simply note the deprecation in a
future release blog post.</p>
<a class="header" href="print.html#drawbacks-48" id="drawbacks-48"><h1>Drawbacks</h1></a>
<p>This adds a little more churn for apps that rely on this feature.</p>
<a class="header" href="print.html#alternatives-49" id="alternatives-49"><h1>Alternatives</h1></a>
<p>This feature was <a href="https://github.com/emberjs/ember.js/pull/14756">recently made pay-as-you-go</a>,
so the immediate performance concerns have been addressed. We could decide to
leave this in the framework as an opt-in feature.</p>
<ul>
<li>Start Date: 2017-03-13</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/213</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/16301</li>
</ul>
<a class="header" href="print.html#summary-50" id="summary-50"><h1>Summary</h1></a>
<p>This RFC aims to expose a <em>low-level primitive</em> for defining <em>custom
components</em>.</p>
<p>This API will allow addon authors to provide special-purpose component base
classes that their users can subclass from in apps. These components are
invokable in templates just like any other Ember components (descendants of
<code>Ember.Component</code>) today.</p>
<a class="header" href="print.html#motivation-51" id="motivation-51"><h1>Motivation</h1></a>
<p>The ability to author reusable, composable components is a core feature of
Ember.js. Despite being a <a href="http://emberjs.com/blog/2013/06/23/ember-1-0-rc6.html">last-minute addition</a>
to Ember 1.0, the <code>Ember.Component</code> API and programming model has proven itself
to be an extremely versatile tool and has aged well over time into the primary
unit of composition in Ember's view layer.</p>
<p>That being said, the current component API (hereinafter &quot;classic components&quot;)
does have some noticeable shortcomings. Over time, classic components have also
accumulated some cruft due to backwards compatibility constraints.</p>
<p>These problems led to the original &quot;angle bracket components&quot; proposal (see RFC
<a href="https://github.com/emberjs/rfcs/blob/master/text/0015-the-road-to-ember-2-0.md">#15</a>
and <a href="https://github.com/emberjs/rfcs/pull/60">#60</a>), which promised to address
these problems via the angle bracket invocation opt-in (i.e. <code>&lt;foo-bar ...&gt;</code>
instead of <code>{{foo-bar ...}}</code>).</p>
<p>Since the transition to the angle bracket invocation syntax was seen as a rare,
once-in-a-lifetime opportunity, it became very tempting to debate every single
shortcomings and missing features in the classic components API in the process
and attempt to design solutions for all of them.</p>
<p>While that discussion was very helpful in capturing constraints and guiding the
overall direction, designing that One True API™ in the abstract turned out to
be extremely difficult. It also went against our philosophy that framework
features should be extracted from applications and designed iteratively with
feedback from real-world usage.</p>
<p>Since that original proposal, we have rewritten Ember's rendering engine from
the ground up (the &quot;Glimmer 2&quot; project). One of the goals of the Glimmer 2
effort was to build first-class support for Ember's view-layer features into
the rendering engine. As part of the process, we worked to rationalize these
features and to re-think the role of components in Ember.js. This exercise has
brought plenty of new ideas and constraints to the table.</p>
<p>The initial Glimmer 2 integration was completed in <a href="http://emberjs.com/blog/2016/11/30/ember-2-10-released.html">Ember 2.10</a>.
As of that version, classic components have been re-implemented using the new
primitives provided by the rendering engine, and we are very happy with the
results.</p>
<p>This approach yielded a number of very powerful and flexible primitives:
in addition to classic components, we were able to implement Ember's
<code>{{mount}}</code>, <code>{{outlet}}</code> and <code>{{render}}</code> helpers as &quot;components&quot; under the
hood.</p>
<p>Based on our experience, we believe it would be beneficial to open up these new
primitives to the wider community. Specifically, there are at least two clear
benefits that comes to mind:</p>
<p>First, it provides addon authors fine-grained control over the exact behavior
and semantics of their components in cases where the general-purpose components
are a poor fit. For example, a low-overhead component designed to be used in
performance hotspot can opt-out of certain convinence features using this API.</p>
<p>Second, it allows the community to experiment with and iterate on alternative
component APIs outside of the core framework. Following the success of FastBoot
and Engines, we believe the best way to design the new &quot;Glimmer Components&quot; API
is to first stablize the underlying primitives in the core framework and
experiment with the surface API through an addon.</p>
<a class="header" href="print.html#detailed-design-48" id="detailed-design-48"><h1>Detailed design</h1></a>
<p>This RFC introduces the concept of <em>component managers</em>. A component manager is
an object that is responsible for coordinating the lifecycle events that occurs
when invoking, rendering and re-rendering a component.</p>
<a class="header" href="print.html#registering-component-managers" id="registering-component-managers"><h2>Registering component managers</h2></a>
<p>Component managers are registered with the <code>component-manger</code> type in the
application's registry. Similar to services, component managers are singleton
objects (i.e. <code>{ singleton: true, instantiate: true }</code>), meaning that Ember
will create and maintain (at most) one instance of each unique component
manager for every application instance.</p>
<p>To register a component manager, an addon will put it inside its <code>app</code> tree:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  // ...
});
</code></pre>
<p>(Typically, the convention is for addons to define classes like this in its
<code>addon</code> tree and then re-export them from the <code>app</code> tree. For brevity, we will
just inline them in the <code>app</code> tree directly for the examples in this RFC.)</p>
<p>This allows the component manager to participate in the DI system – receiving
injections, using services, etc. Alternatively, component managers can also
be registered with imperative API. This could be useful for testing or opt-ing
out of the DI system. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/initializers/register-basic-component-manager.js

const MANAGER = {
  // ...
};

export function initialize(application) {
  // We want to use a POJO here, so we are opt-ing out of instantiation
  application.register('component-manager:basic', MANAGER, { instantiate: false });
}

export default {
  name: 'register-basic-component-manager',
  initialize
};
</code></pre>
<a class="header" href="print.html#determining-which-component-manager-to-use" id="determining-which-component-manager-to-use"><h2>Determining which component manager to use</h2></a>
<p>For the purpose of this section, we will assume components with a JavaScript
file (such as <code>app/components/foo-bar.js</code> or the equivilant in &quot;pods&quot; and
<a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">Module Unification</a>
apps) and optionally a template file (<code>app/templates/components/foo-bar.hbs</code>
or equivilant). The example section has additional information about how this
relates to <a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">template-only components</a>.</p>
<p>When invoking the component <code>{{foo-bar ...}}</code>, Ember will first resolve the
component class (<code>component:foo-bar</code>, usually the <code>default</code> export from
<code>app/components/foo-bar.js</code>). Next, it will determine the appropiate component
manager to use based on the resolved component class.</p>
<p>Ember will provide a new API to assign the component manager for a component
class:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('awesome', EmberObject.extend({
  // ...
}));
</code></pre>
<p>This tells Ember to use the <code>awesome</code> manager (<code>component-manager:awesome</code>) for
the <code>foo-bar</code> component. <code>setComponentManager</code> function returns the class.</p>
<p>In the future, this function can also be invoked as a decorator:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import EmberObject from '@ember/object';
import { componentManager } from '@ember/component';

export default @componentManager('awesome') EmberObject.extend({
  // ...
});
</code></pre>
<p>In reality, an app developer would never have to write this in their apps,
since the component manager would already be assigned on a super-class provided
by the framework or an addon. The <code>setComponentManager</code> function is essentially
a low-level API designed for addon authors and not intended to be used by app
developers.</p>
<p>For example, the <code>Ember.Component</code> class would have the <code>classic</code> component
manager pre-assigned, therefore the following code will continue to work as
intended:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import Component from '@ember/component';

export default Component.extend({
  // ...
});
</code></pre>
<p>Similarly, an addon can provided the following super-class:</p>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import EmberObject from '@ember/object';
import { componentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend({
  // ...
}));
</code></pre>
<p>With this, app developers can simply inherit from this in their app:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import BasicComponent from 'ember-basic-component';

export default BasicComponent.extend({
  // ...
});
</code></pre>
<p>Here, the <code>foo-bar</code> component would automatically inherit the <code>basic</code> component
manager from its super-class.</p>
<p>It is not advisable to override the component manager assigned by the framework
or an addon. Attempting to reassign the component manager when one is already
assinged on a super-class will be an error. If no component manager is set, it
will also result in a runtime error when invoking the component.</p>
<a class="header" href="print.html#component-lifecycle" id="component-lifecycle"><h2>Component Lifecycle</h2></a>
<p>Back to the <code>{{foo-bar ...}}</code> example.</p>
<p>Once Ember has determined the component manager to use, it will be used to
manage the component's lifecycle.</p>
<a class="header" href="print.html#createcomponent" id="createcomponent"><h3><code>createComponent</code></h3></a>
<p>The first step is to create an instance of the component. Ember will invoke the
component manager's <code>createComponent</code> method:</p>
<pre><code class="language-javascript">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  // ...
});
</code></pre>
<p>The <code>createComponent</code> method on the component manager is responsible for taking
the component's factory and the arguments passed to the component (the <code>...</code> in
<code>{{foo-bar ...}}</code>) and return an instantiated component.</p>
<p>The first argument passed to <code>createComponent</code> is the result returned from the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0150-factory-for.md"><code>factoryFor</code></a>
API. It contains a <code>class</code> property, which gives you the the raw class (the
<code>default</code> export from <code>app/components/foo-bar.js</code>) and a <code>create</code> function that
can be used to instantiate the class with any registered injections, merging
them with any additional properties that are passed.</p>
<p>The second argument is a snapshot of the arguments passed to the component in
the template invocation, given in the following format:</p>
<pre><code class="language-js">{
  positional: [ ... ],
  named: { ... }
}
</code></pre>
<p>For example, given the following invocation:</p>
<pre><code class="language-hbs">{{blog-post (titleize post.title) post.body author=post.author excerpt=true}}
</code></pre>
<p>You will get the following as the second argument:</p>
<pre><code class="language-js">{
  positional: [
    &quot;Rails Is Omakase&quot;,
    &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit...&quot;
  ],
  named: {
    &quot;author&quot;: #&lt;User name=&quot;David Heinemeier Hansson&quot;, ...&gt;,
    &quot;excerpt&quot;: true
  }
}
</code></pre>
<p>The arguments object should not be mutated (e.g. <code>args.positional.pop()</code> is no
good). In development mode, it might be sealed/frozen to help prevent these
kind of mistakes.</p>
<a class="header" href="print.html#getcontext" id="getcontext"><h3><code>getContext</code></h3></a>
<p>Once the component instance has been created, the next step is for Ember to
determine the <code>this</code> context to use when rendering the component's template by
calling the component manager's <code>getContext</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  // ...
});
</code></pre>
<p>The <code>getContext</code> method gets passed the component instance returned from
<code>createComponent</code> and should return the object that <code>{{this}}</code> should refer to
in the component's template, as well as for any &quot;fallback&quot; property lookups
such as <code>{{foo}}</code> where <code>foo</code> is neither a local variable or a helper (which
resolves to <code>{{this.foo}}</code> where <code>this</code> is here is the object returned by
<code>getContext</code>).</p>
<p>Typically, this method can simpliy return the component instance, as shown in
the example above. The reason this exists as a separate method is to enable the
so-called &quot;state bucket&quot; pattern which allows addon authors to attach extra
book-keeping metadata to the component:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    let metadata = { ... };
    let instance = factory.create(args.named);
    return { metadata, instance, ... };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  // ...
});
</code></pre>
<p>Since the &quot;state bucket&quot;, not the &quot;context&quot;, is passed back to other hooks on
the component manager, this allows the component manager to access the extra
metadata but otherwise hide them from the app developers.</p>
<p>We will see an example that uses this pattern in a later section.</p>
<p>At this point, Ember will have gathered all the information it needs to render
the component's template, which will be rendered with <a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">&quot;Outer HTML&quot; semantics</a>.</p>
<p>In other words, the content of the template will be rendered as-is, without a
wrapper element (e.g. <code>&lt;div id=&quot;ember1234&quot; class=&quot;ember-view&quot;&gt;...&lt;/div&gt;</code>),
except for subclasses of <code>Ember.Component</code>, which will retain the current
legacy behavior (the internal <code>classic</code> manager uses private capabilities to
achieve that).</p>
<p>This API does not currently provide any way to fine-tune the rendering behavior
(such as dynamically changing the component's template) besides <code>getContext</code>,
but future iterations may introduce extra capabilities.</p>
<a class="header" href="print.html#updatecomponent" id="updatecomponent"><h3><code>updateComponent</code></h3></a>
<p>When it comes time to re-render a component's template (usually because an
argument has changed), Ember will call the manager's <code>updateComponent</code> method
to give the manager an opportunity to reflect those changes on the component
instance, before performing the re-render:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  },

  // ...
});
</code></pre>
<p>The first argument passed to this method is the component instance returned by
<code>createComponent</code>. As mentioned above, using the &quot;state bucket&quot; pattern will
allow this hook to access the extra metadata:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    let metadata = { ... };
    let instance = factory.create(args.named);
    return { metadata, instance, ... };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  updateComponent(bucket, args) {
    let { metadata, instance } = bucket;
    // do things with metadata
    instance.setProperties(args.named);
  },

  // ...
});
</code></pre>
<p>The second argument is a snapshot of the updated arguments, passed with the
same format as in <code>createComponent</code>. Note that there is no guarentee that
anything in the arguments object has <em>actually</em> changed when this method is
called. For example, given:</p>
<pre><code class="language-hbs">{{blog-post title=(uppercase post.title) ...}}
</code></pre>
<p>Imagine if <code>post.title</code> changed from <code>fOo BaR</code> to <code>FoO bAr</code>. Since the value
is passed through the <code>uppercase</code> helper, the component will see <code>FOO BAR</code> in
both cases.</p>
<p>Generally speaking, Ember does not provide any guarentee on how it determines
whether components need to be re-rendered, and the semantics may vary between
releases – i.e. this method may be called more or less often as the internals
changes. The <em>only</em> guarentee is that if something <em>has</em> changed, this method
will definitely be called.</p>
<p>If it is important to your component's programming model to <em>only</em> notify the
component when there are actual changes, the manager is responsible for doing
the extra book-keeping.</p>
<p>For example:</p>
<pre><code class="language-js">// ember-basic-component/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

function NOOP() {}

export default setComponentManager('basic', EmberObject.extend({
  // Users of BasicComponent can override this hook to be notified when an
  // argument will change
  argumentWillChange: NOOP,

  // Users of BasicComponent can override this hook to be notified when an
  // argument will change
  argumentDidChange: NOOP,

  // ...
}));
</code></pre>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return {
      args: args.named,
      instance: factory.create(args.named)
    };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  updateComponent(bucket, args) {
    let instance = bucket.instance;
    let oldArgs = bucket.args;
    let newArgs = args.named;
    let changed = false;

    // Since the arguments are coming from the template invocation, you can
    // generally assume that they have exactly the same keys. However, future
    // additions such as &quot;splat arguments&quot; in the template layer might change
    // that assumption.
    for (let key in oldArgs) {
      let oldValue = oldArgs[key];
      let newValue = newArgs[key];

      if (oldValue !== newValue) {
        instance.argumentWillChange(key, oldValue, newValue);
        instance.set(key, newValue);
        instance.argumentDidChange(key, oldValue, newValue);
      }
    }

    bucket.args = newArgs;
  },

  // ...
});
</code></pre>
<p>This example also shows when the &quot;state bucket&quot; pattern could be useful.</p>
<p>The return value of the <code>updateComponent</code> is ignored.</p>
<p>After calling the <code>updateComponent</code> method, Ember will update the component's
template to reflect any changes.</p>
<a class="header" href="print.html#capabilities" id="capabilities"><h2>Capabilities</h2></a>
<p>In addition to the methods specified above, component managers are required to
have a <code>capabilities</code> property.  This property must be set to the result of
calling the <code>capabilities</code> function provided by Ember.</p>
<a class="header" href="print.html#versioning-1" id="versioning-1"><h3>Versioning</h3></a>
<p>The first, mandatory, argument to the <code>capabilities</code> function is the component
manager API, which is denoted in the <code>${major}.${minor}</code> format, matching the
minimum Ember version this manager is targeting. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  }
});
</code></pre>
<p>This allows Ember to introduce new capabilities and make improvements to this
API without breaking existing code.</p>
<p>Here is a hypothical scenario for such a change:</p>
<ol>
<li>
<p>Ember 3.2 implemented and shipped the component manager API as described in
this RFC.</p>
</li>
<li>
<p>The <code>ember-basic-component</code> addon released version 1.0 with the component
manager shown above (notably, it declared <code>capabilities('3.2')</code>).</p>
</li>
<li>
<p>In Ember 3.5, we determined that constructing the arguments object passed to
the hooks is a major performance bottleneck, and changes the API to pass a
&quot;proxy&quot; object with getter methods instead (e.g. <code>args.getPositional(0)</code> and
<code>args.getNamed('foo')</code>).</p>
<p>However, since Ember sees that the <code>basic</code> component manager is written to
target the <code>3.2</code> API version, it will retain the old behavior and passes the
old (more expensive) &quot;reified&quot; arguments object instead, to avoid breakage.</p>
</li>
<li>
<p>The <code>ember-basic-component</code> addon author would like to take advantage of
this performance optimization, so it updates its component manager code to
work with the arguments proxy and changes its capabilities declaration to
<code>capabilities('3.5')</code> in version 2.0.</p>
</li>
</ol>
<p>This system allows us to rapidly improve the API and take advantage of
underlying rendering engine features as soon as they become available.</p>
<p>Note that addon authors are not <em>required</em> to update to the newer API.
Concretely, component manager APIs have the following support policy:</p>
<ul>
<li>
<p>API versions will continue to be supported in the same major release of
Ember. As shown in the example above, <code>ember-basic-component</code> 1.0 (which
targets component manager API version 3.2), will continue to work on
Ember 3.5. However, the reverse is not true – component manager API version
3.5 will (somewhat obviously) not work in Ember 3.2.</p>
</li>
<li>
<p>In addition, to ensure a smooth transition path for addon authors and app
developers across major releases, each Ember version will support (at least)
the previous LTS version as of the release was made. For example, if 3.16 is
the last LTS release of the 3.x series, the component manager API version
3.16 will be supported by Ember 4.0 through 4.4, at minimum.</p>
</li>
</ul>
<p>Addon authors can also choose to target multiple versions of the component
manager API using <a href="https://github.com/pzuraq/ember-compatibility-helpers/">ember-compatibility-helpers</a>:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { gte } from 'ember-compatibility-helpers';

let ComponentManager;

if (gte('3.5')) {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.5'),

    // ...
  });
} else {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.2'),

    // ...
  });
}

export default ComponentManager;
</code></pre>
<p>Since the conditionals are resolved at build time, the irrevelant code will be
stripped from production builds, avoiding any deprecation warnings.</p>
<a class="header" href="print.html#optional-features" id="optional-features"><h3>Optional Features</h3></a>
<p>The second, optional, argument to the <code>capabilities</code> function is an object
enumerating the optional features requested by the component manager.</p>
<p>In the hypothical example above, while the &quot;reified&quot; arguments objects may be
a little slower, they are certainly easier to work with, and the performance
may not matter to but the most performance critical components. A component
manager written for Ember 3.5 (again, only hypothically) and above would be
able to explicitly opt back into the old behavior like so:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.5', {
    reifyArguments: true
  }),

  // ...
});
</code></pre>
<p>In general, we will aim to have the defaults set to as bare-bone as possible,
and allow the component managers to opt into the features they need in a PAYGO
(pay-as-you-go) manner, which aligns with the Glimmer VM philosophy. As the
rendering engine evolves, more and more feature will become optional.</p>
<a class="header" href="print.html#optional-capabilities" id="optional-capabilities"><h2>Optional Capabilities</h2></a>
<p>The following optionally capabilities will be available with the first version
of the component manager API. We expect future RFCs to propose additional
capabilities within the framework provided by this initial RFC.</p>
<a class="header" href="print.html#async-lifecycle-callbacks" id="async-lifecycle-callbacks"><h3>Async Lifecycle Callbacks</h3></a>
<p>When the <code>asyncLifecycleCallbacks</code> capability is set to <code>true</code>, the component
manager is expected to implement two additional methods: <code>didCreateComponent</code>
and <code>didUpdateComponent</code>.</p>
<p><code>didCreateComponent</code> will be called after the component has been rendered the
first time, after the whole top-down rendering process is completed. Similarly,
<code>didUpdateComponent</code> will be called after the component has been updated, after
the whole top-down rendering process is completed. This would be the right time
to invoke any user callbacks, such as <code>didInsertElement</code> and <code>didRender</code> in the
classic components API.</p>
<p>These methods will be called with the component instance (the &quot;state bucket&quot;
returned by <code>createComponent</code>) as the only argument. The return value is
ignored.</p>
<p>These callbacks are called if and only if their synchronous APIs were invoked
during rendering. For example, if <code>updateComponent</code> was called on during
rendering (and it completed without errors), <code>didUpdateComponent</code> will always
be called. Conversely, if <code>didUpdateComponent</code> is called, you can infer that
the <code>updateComponent</code> was called on the same component instance during
rendering.</p>
<p>This API provides no guarentee about ordering with respect to siblings or
parent-child relationships.</p>
<a class="header" href="print.html#destructors" id="destructors"><h3>Destructors</h3></a>
<p>When the <code>destructor</code> capability is set to <code>true</code>, the component manager is
expected to implement an additional method: <code>destroyComponent</code>.</p>
<p><code>destroyComponent</code> will be called when the component is no longer needed. This
is intended for performing object-model level cleanup.</p>
<p>Because this RFC does not provide ways to access or observe the component's DOM
tree, the timing relative to DOM teardown is undefined (i.e. whether this is
called before or after the component's DOM tree is removed from the document).</p>
<p>Therefore, this hook is not suitable for invoking user callbacks intended for
performing DOM cleanup, such as <code>willDestroyElement</code> in the classic components
API. We expect a subsequent RFC addressing DOM-related functionalities to
clarify this issues or provide another specialized method for that purpose.</p>
<p>Similar to the other async lifecycle callbacks, this API provides no guarentee
about ordering with respect to siblings or parent-child relationships. Further,
the exact timing of the calls are also undefined. For example, the calls from
several render loops might be batched together and deferred into a browser idle
callback.</p>
<a class="header" href="print.html#examples-4" id="examples-4"><h1>Examples</h1></a>
<a class="header" href="print.html#basic-component-manager" id="basic-component-manager"><h2>Basic Component Manager</h2></a>
<p>Here is the simpliest end-to-end component manager example that uses a plain
<code>Ember.Object</code> super-class (as opposed to <code>Ember.Component</code>) with &quot;Outer HTML&quot;
semantics:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2', {
    destructor: true
  }),

  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  },

  destroyComponent(component) {
    component.destroy();
  }
});
</code></pre>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend());
</code></pre>
<a class="header" href="print.html#usage" id="usage"><h3>Usage</h3></a>
<pre><code class="language-js">// my-app/app/components/x-counter.js

import BasicCompoment from 'ember-basic-component';

export default BasicCompoment.extend({
  init() {
    this.count = 0;
  },

  down() {
    this.decrementProperty('count');
  },

  up() {
    this.incrementProperty('count');
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- my-app/app/templates/components/x-counter.hbs --}}

&lt;div&gt;
  &lt;button {{action this.down}}&gt;🔽&lt;/button&gt;
  {{this.count}}
  &lt;button {{action this.up}}&gt;🔼&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#template-only-components" id="template-only-components"><h2>Template-only Components</h2></a>
<p>This example implements a kind of component similar to what was proposed in the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">template-only components</a>
RFC.</p>
<p>Since the custom components API proposed in this RFC requires a JavaScript
files, we cannot implement true &quot;template-only&quot; components. We will need to
create a component JS file to export a dummy value, for the sole purpose of
indicating the component manager we want to use.</p>
<p>In practice, there is no need for an addon to implement this API, since it is
essentially re-implementing what the &quot;template-only-glimmer-components&quot;
optional feature does. Nevertheless, this example is useful for illustrative
purposes.</p>
<pre><code class="language-js">// ember-template-only-component/app/component-managers/template-only.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent() {
    return null
  },

  getContext() {
    return null;
  },

  updateComponent() {
    return;
  }
});
</code></pre>
<pre><code class="language-js">// ember-template-only-component/addon/index.js

import { setComponentManager } from '@ember/component';

// Our `createComponent` method does not actually do anything with the factory,
// so we don't even need to export a class here, `{}` would work just fine.
export default setComponentManager('template-only', {});
</code></pre>
<a class="header" href="print.html#usage-1" id="usage-1"><h3>Usage</h3></a>
<pre><code class="language-js">// my-app/app/components/hello-world.js

import TemplateOnlyComponent from 'ember-template-only-component';

export default TemplateOnlyComponent;
</code></pre>
<pre><code class="language-hbs">Hello world! I have no backing class! {{this}} would be &lt;code&gt;null&lt;/code&gt;.
</code></pre>
<a class="header" href="print.html#recycling-components" id="recycling-components"><h2>Recycling Components</h2></a>
<p>This example implements an API which maintain a pool of recycled component
instances to avoid allocation costs.</p>
<p>This example also make use of the &quot;state bucket&quot; pattern.</p>
<pre><code class="language-js">// ember-component-pool/app/component-managers/pooled.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

// How many instances to keep (per type/factory)
const LIMIT = 10;

export default EmberObject.extend({
  capabilities: capabilities('3.2', {
    destructor: true
  }),

  init() {
    this.pool = new Map();
  },

  createComponent(factory, args) {
    let instances = this.pool.get(factory);
    let instance;

    if (instances &amp;&amp; instances.length &gt; 0) {
      instance = instances.pop();
      instance.setProperties(args.named);
    } else {
      instance = factroy.create(args.named);
    }

    // We need to remember which factory does the instance belong to so we can
    // check it back into the pool later.
    return { factory, instance };
  },

  getContext({ instance }) {
    return instance;
  },

  updateComponent({ instance }, args) {
    instance.setProperties(args.named);
  },

  destroyComponent({ factory, instance }) {
    let instances;

    if (this.pool.has(factory)) {
      instances = this.pool.get(factory);
    } else {
      this.pool.set(factory, instances = []);
    }

    if (instances.length &gt;= LIMIT) {
      instance.destroy();
    } else {
      // User hook to reset any state
      instance.willRecycle();
      instances.push(instance);
    }
  },

  // This is the `Ember.Object` lifecycle method, called when the component
  // manager instance _itself_ is being destroyed, not to be confused with
  // `destroyComponent`
  willDestroy() {
    for (let instances of this.pool.values()) {
      instances.forEach(instance =&gt; instance.destroy());
    }

    this.pool.clear();
  }
});
</code></pre>
<pre><code class="language-js">// ember-component-pool/addon/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

function NOOP() {}

export default setComponentManager('pooled', EmberObject.extend({
  // Override this to implement reset any state on the instance
  willRecycle(): NOOP,

  // ...
}));
</code></pre>
<a class="header" href="print.html#how-we-teach-this-25" id="how-we-teach-this-25"><h1>How We Teach This</h1></a>
<p>What is proposed in this RFC is a <em>low-level</em> primitive. We do not expect most
users to interact with this layer directly. Instead, most users will simply
benefit from this feature by subclassing these special components provided by
addons.</p>
<p>At present, the classic components APIs is still the primary, recommended path
for almost all use cases. This is the API that we should teach new users, so we
do not expect the guides need to be updated for this feature (at least not the
components section).</p>
<p>For documentation purposes, each Ember.js release will only document the latest
component manager API, along with the available optional capabilities for that
realease. The documentation will also include the steps needed to upgrade from
the previous version. Documentation for a specific version of the component
manager API can be viewed from the versioned documentation site.</p>
<a class="header" href="print.html#drawbacks-49" id="drawbacks-49"><h1>Drawbacks</h1></a>
<p>In the long term, there is a risk of fragmentating the Ember ecosystem with
many competing component APIs. However, given the Ember community's strong
desire for conventions, this seems unlikely. We expect this to play out similar
to the data-persistence story – there will be a primary way to do things (Ember
Data), but there are also plenty of other alternatives catering to niche use
cases that are underserved by Ember Data.</p>
<p>Also, because apps can mix and match component styles, it's possible for a
library like smoke-and-mirrors or Liquid Fire to take advantage of the
enhanced functionality internally without leaking those implementation
details to applications.</p>
<a class="header" href="print.html#alternatives-50" id="alternatives-50"><h1>Alternatives</h1></a>
<p>Instead of focusing on exposing enough low-level primitives to build the new
components API, we could just focus on building out the user-facing APIs
without rationalizing or exposing the underlying primitives.</p>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="print.html#follow-up-rfcs" id="follow-up-rfcs"><h2>Follow-up RFCs</h2></a>
<p>We expect to rapidly iterate and improve the component manager API through the
RFC process and in-the-field usage/implementation experience. Here are a few
examples of additional capabilities that we hope to see proposed after this
initial (and intentionally minimal) proposal is finalized:</p>
<ol>
<li>
<p>Expose a way to access to the component's DOM structure, such as its bounds.
This RFC would also need to introduce a hook for DOM teardown and address
how event handling/delegation would work.</p>
</li>
<li>
<p>Expose a way to access to the <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>-based APIs. This could include
the ability to customize the component's &quot;tag&quot; (<a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/05-validators.md">validator</a>).</p>
</li>
<li>
<p>Expose additional features that are used to implement classic components,
<code>{{outlet}}</code> and other built-in components, such as layout customizations,
and dynamic scope access.</p>
</li>
<li>
<p>Angle bracket invocation.</p>
</li>
</ol>
<a class="header" href="print.html#using-es6-classes" id="using-es6-classes"><h2>Using ES6 Classes</h2></a>
<p>Although this RFC uses <code>Ember.Object</code> in the examples, it is not a &quot;hard&quot;
dependency.</p>
<a class="header" href="print.html#using-es6-classes-for-components" id="using-es6-classes-for-components"><h3>Using ES6 Classes For Components</h3></a>
<p>The main interaction between the Ember object model and the component class
is through the DI system. Specifically, the factory function returned by
<code>factoryFor</code> (<code>factoryFor('component:foo-bar').create(...)</code>), which is passed
to the <code>createComponent</code> method on the component manager, assumes a static
<code>create</code> method on the class that takes the &quot;property bag&quot; and returns the
created instance.</p>
<p>Therefore, as long as your ES6 super-class provides such a function, it will
work with the rest of the system:</p>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import { setComponentManager } from '@ember/component';

class BasicComponent {
  static create(props) {
    return new this(props);
  }

  constructor(props) {
    // Do things with props, such as:
    Object.assign(this, props);
  }

  // ...
}

export default setComponentManager('basic', BasicComponent);
</code></pre>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    // This Just Works™ since we have a static create method on the class
    return factory.create(args.named);
  },

  // ...
});
</code></pre>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import BasicCompoment from 'ember-basic-component';

export default class extends BasicCompoment {
  // ...
};
</code></pre>
<p>Alternatively, if you prefer not to add a static create method to your
super-class, you can also instantiate them in the component manager without
going through the DI system:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    // This does not use the factory function, thus no longer require a static
    // create method on the class
    return new factory.class(args.named);
  },

  // ...
});
</code></pre>
<p>However, doing do will prevent your components from receiving injections (as
well as setting the appropiate owner, etc). Therefore, when possible, it is
better to go through the DI system's factory function.</p>
<a class="header" href="print.html#using-es6-classes-for-component-managers" id="using-es6-classes-for-component-managers"><h3>Using ES6 Classes For Component Managers</h3></a>
<p>It is also possible to use ES6 classes for the component managers themselves.
The main interaction here is that they are automatically instantiated by the DI
system on-demand, which again assumes a static <code>create</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';

export default class BasicComponentManager {
  static create(props) {
    return new this(props);
  }

  constructor(props) {
    // Do things with props, such as:
    Object.assign(this, props);
  }

  capabilities = capabilities('3.2');

  // ...
};
</code></pre>
<p>Alternatively, as shown above, you can also register the component manager
with <code>{ instantiate: false }</code>:</p>
<pre><code class="language-js">// ember-basic-component/app/initializers/register-basic-component-manager.js

import BasicComponentManager from 'ember-basic-component';

export function initialize(application) {
  application.register('component-manager:basic', new BasicComponentManager(), { instantiate: false });
}

export default {
  name: 'register-basic-component-manager',
  initialize
};
</code></pre>
<p>Note that this behaves a bit differently as the component manager instance is
shared across all application instances and is never destroyed, which might
affect stateful component managers such as the one shown in the &quot;Recycling
Components&quot; example above.</p>
<ul>
<li>Start Date: 2017-04-26</li>
<li>RFC PR: <a href="https://github.com/emberjs/ember.js/pull/15174">#15174</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-51" id="summary-51"><h1>Summary</h1></a>
<p>This RFC proposes allowing parameters to be passed to the <code>{{mount}}</code> syntax.</p>
<a class="header" href="print.html#motivation-52" id="motivation-52"><h1>Motivation</h1></a>
<p>This will enable developers to pass contextual data into routeless engines at
runtime, allowing individual engines to be used multiple times through a single
application under different contexts.</p>
<p>An example could be a dashboard of charts where each chart is a routeless engine.
Each chart could be of a different type and would require different data. This
RFC would enable the following:</p>
<pre><code class="language-hbs">{{!-- app/templates/application.hbs --}}
{{#each charts as |chart|}}
  {{mount &quot;chart&quot; type=chart.type data=chart.data}}
{{/each}}
</code></pre>
<a class="header" href="print.html#detailed-design-49" id="detailed-design-49"><h1>Detailed design</h1></a>
<p>You can see the implementation for this RFC <a href="https://github.com/emberjs/ember.js/pull/15174">here</a>.</p>
<p>Implementing this functionality turns out to be relatively straight forward. With
routeless engines already supporting an application controller, we can use this
as a means of providing access to the parameters.</p>
<p>Parameters would be passed to the <code>{{mount}}</code> syntax in the same way that
they are currently passed to components and helpers.</p>
<pre><code class="language-hbs">{{mount &quot;foo&quot; bar=&quot;baz&quot;}}
</code></pre>
<p>These parameters would then be set as the <code>model</code> property on the engines
application controller; making them accessible from both a JS and HBS context.</p>
<pre><code class="language-js">// foo/controllers/application.js
import Ember from 'ember';

export default Ember.Controller.extend({

  actions: {
    exampleAction() {
      let barParam = this.get(&quot;model.bar&quot;);
    }
  }

});
</code></pre>
<pre><code class="language-hbs">{{!-- foo/templates/application.hbs --}}
The value of the bar param is: {{model.bar}}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-26" id="how-we-teach-this-26"><h1>How We Teach This</h1></a>
<p>This RFC re-uses concepts that are already heavily used throughout other areas
of the framework.</p>
<p>Updates will need to be made to the Ember API docs and <a href="http://ember-engines.com">ember-engines.com</a> guides in order to explain that
routeless engines can now accept parameters being passed via the <code>{{mount}}</code> syntax.</p>
<p>In addition, updates would need to include examples of both how to pass parameters
to <code>{{mount}}</code> as well as how any passed parameters can be accessed from within
the context of an engine.</p>
<a class="header" href="print.html#drawbacks-50" id="drawbacks-50"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#increased-risk-of-runtime-dependencies-a-hrefhttpsgithubcomember-enginesember-enginesissues98issuecomment-217347193referencea" id="increased-risk-of-runtime-dependencies-a-hrefhttpsgithubcomember-enginesember-enginesissues98issuecomment-217347193referencea"><h3>Increased risk of runtime dependencies [<a href="https://github.com/ember-engines/ember-engines/issues/98#issuecomment-217347193">reference</a>]</h3></a>
<p>This RFC does increase the risk of introducing runtime dependencies.</p>
<p>Example:</p>
<pre><code class="language-js">import Ember from 'ember';

export default Ember.Component.extend({
  geo: Ember.inject.service('geolocation')
})
</code></pre>
<pre><code class="language-hbs">{{mount &quot;blog&quot; (hash geo=geo)}}
</code></pre>
<a class="header" href="print.html#alternatives-51" id="alternatives-51"><h1>Alternatives</h1></a>
<a class="header" href="print.html#application-route-model-hook" id="application-route-model-hook"><h3>Application route <code>model</code> hook</h3></a>
<p>This solution suggested that the parameters were provided to the engines
application route via the <code>model</code> hooks <code>params</code> argument. While viable,
this solution didn't <em>feel</em> quite right as you were using a route within a <em>routeless</em>
engine.</p>
<a class="header" href="print.html#introduction-of-new-routelessengine-primitive" id="introduction-of-new-routelessengine-primitive"><h3>Introduction of new <code>routelessEngine</code> primitive</h3></a>
<p>This solution suggested that routeless engines should be given their own primitive
similar to that of a component. The primitive would follow a construct to
components and use the same hooks <code>(e.g., didReceiveAttrs)</code> for working with
parameters.</p>
<p>This solution was decided against for following main reasons:</p>
<ol>
<li>The current public API is that we use <code>application</code> controller to back the
<code>application.hbs</code> of a route-less engine.  Adding a new conceptual primitive
here would be a fairly difficult change without breakage.</li>
<li>Introducing a new primitive (e.g. not controller and not a component) is a
<em>very</em> heavy handed thing, and should not be taken lightly. We don't think this
rises to that level of need.</li>
<li>This is an ideal case for &quot;just using a component&quot;, but that would be roughly
akin to &quot;routable components&quot; and we should follow Ember's lead.  When routeable
components are introduced, we can refactor this in the same way with the same
backwards compatibility guarantees.</li>
</ol>
<a class="header" href="print.html#unresolved-questions-42" id="unresolved-questions-42"><h1>Unresolved questions</h1></a>
<a class="header" href="print.html#positional-parameters" id="positional-parameters"><h3>Positional parameters</h3></a>
<p>In addition to supporting named parameters, should the <code>{{mount}}</code> syntax also
support positional parameters? If so, should this be covered in this RFC, or
in a follow up RFC?</p>
<ul>
<li>Start Date: 2017-05-05</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/226</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-52" id="summary-52"><h1>Summary</h1></a>
<p>Introduce syntax for passing in multiple named template blocks into a component, and
unify the rendering syntaxes / semantics for
blocks/primitives/component-factories passed into a component.</p>
<p>This RFC is focused chiefly on bringing named blocks to Ember Components,
but it was necessary to define a basic roadmap of functionality for
Glimmer Components as well, but keep in mind that some of the Glimmer-centric details may
change and should hence be considered non-normative.</p>
<a class="header" href="print.html#motivation-53" id="motivation-53"><h1>Motivation</h1></a>
<p>There are limitations to composition due to the inability to pass more than one block to a component (or 2 blocks if you include the inverse block).</p>
<p>The result of this is that Ember developers have this ultra-powerful, compositional API for overriding portions of a component, but they can only use it in one place in the component invocation; any remaining overrides/configuration needs to be expressed as data and passed in as attributes to the component when it'd be vastly preferable to just pass in a chunk of DOM.</p>
<p>Example:</p>
<pre><code class="language-html">{{#x-modal headerText=page.title as |c|}}
  &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
  &lt;button onclick={{c.close}}&gt;
     Close modal
  &lt;/button&gt;
{{/x-modal}}
</code></pre>
<p>This works, but the moment you need to render a component in the header (rather than just <code>headerText</code>), you end up having to add more config/data/attrs to <code>x-modal</code> just to support every one of those overrides, when really you just should be able to pass in another block of DOM to define what the header looks like. The API in this proposal would allow you to express this use case via:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |c|&gt;
    {{page.title}}
    {{status-indicator status=status}}
    {{close-button action=c.close}}
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
    &lt;button onclick={{c.close}}&gt;
       Close modal
    &lt;/button&gt;
  &lt;/@main&gt;
{{/x-modal}}
</code></pre>
<p>and with Glimmer components:</p>
<pre><code class="language-html">&lt;x-modal&gt;
  &lt;@header as |c|&gt;
    {{page.title}}
    {{status-indicator status=status}}
    {{close-button action=c.close}}
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
    &lt;button onclick={{c.close}}&gt;
       Close modal
    &lt;/button&gt;
  &lt;/@main&gt;
&lt;/x-modal&gt;
</code></pre>
<p>Other RFCs/addons that have attempted to address this:</p>
<ul>
<li><a href="https://github.com/emberjs/rfcs/pull/72">named yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/43">multiple yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/193">yet another named yields rfc</a></li>
<li><a href="https://github.com/ciena-blueplanet/ember-block-slots">ember-block-slots</a></li>
<li><a href="https://github.com/knownasilya/ember-named-yields">ember-named-yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/199">local template blocks</a></li>
</ul>
<a class="header" href="print.html#detailed-design-50" id="detailed-design-50"><h1>Detailed design</h1></a>
<a class="header" href="print.html#invocation-syntax-is-separate-from-component-type" id="invocation-syntax-is-separate-from-component-type"><h2>Invocation Syntax is separate from Component type</h2></a>
<p>The features specified in this RFC require us to nail down
some specifics as to how Ember and
Glimmer components interop, which syntaxes can be used to render
them, and the mental/teaching model behind how it all works.</p>
<ul>
<li>Invocation Syntax (curly vs angle brackets) is conceptually separate from Component
type (Ember vs Glimmer component)</li>
<li>&quot;Curly Components&quot; is a misnomer since curly syntax can render both Ember
components AND Glimmer components</li>
<li>Angle-bracket syntax can only render Glimmer components</li>
<li><code>{{x-foo @k=v}}</code> will remain invalid curly syntax due to the <code>@k=v</code></li>
<li>The way KV pairs provided at invocation is handled depends on the
component type:
<ul>
<li>Given <code>{{x-foo k=v}}</code>, Ember Component <code>x-foo</code> will assign/bind <code>v</code>
to property <code>k</code> on the component instance, which can be rendered
within the component layout template as <code>{{k}}</code> (same behavior as always).
<code>{{@k}}</code> in an Ember component layout will remain a syntax error</li>
<li>Given <code>{{x-foo k=v}}</code>, Glimmer Component <code>x-foo</code> treats <code>k=v</code> as
assigning/binding arg <code>@k</code> to <code>v</code>; it will assign/bind <code>this.args.k</code>, and expose
the value as <code>{{@k}}</code> within the template. This example invocation
is functionally equivalent to <code>&lt;x-foo @k={{v}} /&gt;</code></li>
<li>The mental model is that with curly syntax, <code>k=v</code> is the syntax
for &quot;passing data&quot; to a component; Ember components receive/expose
this data via the properties on the component instance, and Glimmer
components receive the data as <code>@arg</code>s.</li>
</ul>
</li>
<li>Curly syntax will not be enhanced with syntax for passing HTML attrs
(at this time)</li>
<li>Angle-bracket syntax does not support passing positional params</li>
</ul>
<p>Implementation-wise, these varying semantics will be defined/implemented via
<a href="https://github.com/emberjs/rfcs/blob/custom-components/text/0000-custom-components.md#componentmanager">Component Managers</a>.</p>
<a class="header" href="print.html#multi-block-syntax" id="multi-block-syntax"><h2>Multi-block Syntax</h2></a>
<p>Both curly and angle-bracket component invocation syntax will be enhanced
with a nested syntax for passing multiple blocks into a component.</p>
<p>The syntax for curly invocation is as follows:</p>
<pre><code class="language-html">{{#x-foo}}
  &lt;@header&gt;
    Howdy.
  &lt;/@header&gt;

  &lt;@body as |foo|&gt;
    Body {{foo}}
  &lt;/@body&gt;
{{/x-foo}}
</code></pre>
<p>and for angle-bracket invocation:</p>
<pre><code class="language-html">&lt;x-foo&gt;
  &lt;@header&gt;
    Howdy.
  &lt;/@header&gt;

  &lt;@body as |foo|&gt;
    Body {{foo}}
  &lt;/@body&gt;
&lt;/x-modal&gt;
</code></pre>
<p>As demonstrated above, the <em>nested</em> syntax for both curly and
angle-bracket multi-block syntax has the format <code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code>.</p>
<p>This multi-block syntax cannot be mixed with other syntaxes; either ALL
the nested &quot;children&quot; of a component invocation need to be
<code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code> (multi-block syntax), or none of them do
(classic single-block syntax). The presence of any non-whitespace
character between or around <code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code>s is a
compile-time error.</p>
<p>Passing two blocks with the same name is a compiler error (though this
might be relaxed in a future RFC).</p>
<a class="header" href="print.html#blocks-are-just-opaque-data" id="blocks-are-just-opaque-data"><h3>Blocks are just (opaque) data</h3></a>
<p>This RFC introduces the concept that blocks are just opaque values
passed into components as data, rather than living in what is
essentially a separate namespace only accessible to <code>{{yield}}</code>.</p>
<p>In the above example (with curly syntax), Ember Component <code>x-foo</code> would
have its <code>header</code> and <code>body</code> properties set on its instance. This means,
among other things, that there's no need for a
<a href="https://github.com/emberjs/rfcs/pull/102">hasBlock API for JavaScript</a>;
you can just use normal property lookup / computed properties / etc to
determine whether a block is provided. This means that blocks can
be stashed on services and rendered elsewhere, e.g. the
<a href="https://github.com/emberjs/rfcs/pull/226#issuecomment-299949000">ember-elsewhere use case</a>.</p>
<a class="header" href="print.html#unified-renderable-syntax" id="unified-renderable-syntax"><h3>Unified Renderable Syntax</h3></a>
<p>Rather than continuing to enhance the <code>{{yield}}</code> syntax, we should take
this opportunity to unify the various syntaxes for rendering things,
from blocks to primitive values to component factories.</p>
<p>We'll use the following example component invocation to explore
what this syntax looks like: the following (curly syntax) invocation is valid syntax for
rendering either an Ember.Component or a Glimmer Component named
<code>x-modal</code> and passing it 3 named blocks: <code>header</code>, <code>body</code>, and <code>footer</code>:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |title|&gt;
    Header {{title}}
  &lt;/@header&gt;

  &lt;@body&gt;
    Body
  &lt;/@body&gt;

  &lt;@footer&gt;
    Footer
  &lt;/@footer&gt;
{{/x-modal}}
</code></pre>
<p>Given the above invocation, here's how you could render these blocks:</p>
<pre><code>{{! within ember-component layout }}
{{this.header &quot;ima title&quot;}}
{{this.body}}
{{this.footer}}

{{! within glimmer-component layout }}
{{@header &quot;ima title&quot;}}
{{@body}}
{{@footer}}
</code></pre>
<p>Both of these Ember/Glimmer layouts would render:</p>
<pre><code>Header ima title
Body
Footer
</code></pre>
<p>The mental modal here is that is that for ECs, named blocks are
set/bound as a properties on the instance, which we're rendering the
same way we always rendering properties on the instance. For GCs, blocks
are just args that we're rendering with the standard @arg syntax</p>
<a class="header" href="print.html#why-thisheader-and-not-just-header" id="why-thisheader-and-not-just-header"><h4>Why <code>{{this.header}}</code> and not just <code>{{header}}</code>?</h4></a>
<p>Unfortunately, we are constrained by the fact that <code>{{foo}}</code> means:</p>
<ul>
<li>Try and find a helper named <code>foo</code>, and render it</li>
<li>If no such helper exists, fall back to rendering property <code>foo</code>
on the template context</li>
</ul>
<p>There is a risk that still exists today that any time you introduce a
new helper to your codebase, for example, a <code>time</code> helper, you will break any
templates that try to render a <code>time</code> property via <code>{{time}}</code>. This is
an unfortunate hangover from the past, and we don't want to continue to
expand the scope of this footgun with this RFC. Hence, to render
blocks/component factories, you must use <code>{{this.time}}</code> in your Ember
Component templates.</p>
<p>This is actually an extension to behavior introduced by the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md">Contextual Component Lookup
RFC</a>;
today, the following is supported:</p>
<pre><code class="language-hbs">&lt;!-- invocation --&gt;
{{x-foo header=(component 'x-header')}}
</code></pre>
<pre><code class="language-hbs">&lt;!-- x-foo layout --&gt;
{{this.header}}
</code></pre>
<p>In the above example, <code>{{this.header}}</code> will actually render the
<code>x-header</code> component factory; this RFC merely proposes extending this
syntax so that it can render blocks as well.</p>
<p>Since the potential for forgetting this rule is somewhat high, we
should consider detecting when you use <code>{{foo}}</code> syntax when <code>foo</code> is a
component factory or a block, and provide a useful warning or error
message to use <code>{{this.foo}}</code> instead.</p>
<a class="header" href="print.html#rendering-primitives" id="rendering-primitives"><h4>Rendering primitives</h4></a>
<p>Consider the following example, which modifies above example by changing
the <code>footer</code> block to a string:</p>
<pre><code class="language-html">{{#x-modal footer=&quot;ima footer&quot;}}
  &lt;@header as |title|&gt;
    Header {{title}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>If <code>x-modal</code> renders footer via <code>{{this.footer}}</code>, then it'll just
render the &quot;ima footer&quot; string just fine; this a nice benefit of having
a Unified Renderable syntax
and supports a common workflow where string args can be promoted
to full-on blocks without having to rework the component code
to support an alternative/parallel API.</p>
<a class="header" href="print.html#call-syntax-with-primitives-or-undefined" id="call-syntax-with-primitives-or-undefined"><h4>Call syntax with primitives (or undefined)</h4></a>
<p>If you try to render a block/component with args, e.g. <code>{{this.foo 1 2 3}}</code>,
then <code>foo</code> MUST be a block or a component. If <code>foo</code> is any kind of
non-callable primitive, including undefined, it will be an error.</p>
<a class="header" href="print.html#unified-renderable-syntax-component-factories" id="unified-renderable-syntax-component-factories"><h4>Unified Renderable Syntax: component factories</h4></a>
<p>The following invocation using component factories is also supported:</p>
<pre><code class="language-html">{{#x-modal
     header=(component 'my-modal-header')
     footer=(component 'my-modal-footer')}}
  &lt;@main&gt;
    Main
  &lt;/@main&gt;
{{/x-modal}}
</code></pre>
<p>(It's worth mentioning that since we're only defining the <code>main</code> block
here, this could also be expressed simply as:)</p>
<pre><code class="language-html">{{#x-modal
     header=(component 'my-modal-header')
     footer=(component 'my-modal-footer')}}
  Main
{{/x-modal}}
</code></pre>
<p>This demonstrates that the unified renderable syntax is also capable of
rendering component factories (previously only renderable via
<code>{{component header}}</code>).</p>
<p>Note since we're passing a positional param <code>&quot;ima title&quot;</code> to <code>header</code>,
the <code>my-modal-header</code> component would only be able to access that param if it were
using the <code>positionalParams</code> API with (<code>reopenClass</code>), which is a bit of
a clunky / pro-user API.</p>
<p>As a component author, if you want to write your components to support
passing data to both blocks (which accept positional params) and
components (which accept KV pairs), you can pass in both formats
of the same data, e.g.:</p>
<pre><code>// Ember.component layout
{{this.header headerTitle title=headerTitle}}

// Glimmer Component layout
{{@header headerTitle title=headerTitle}}
</code></pre>
<a class="header" href="print.html#named-block-params" id="named-block-params"><h4>Named block params</h4></a>
<p>Prior to this RFC, there were only two ways to pass in overridable
chunks of DOM to a component:</p>
<ul>
<li>Passing in a block, which only accepts positional block params
(or a <code>(hash)</code> object of named params)</li>
<li>Passing in a component factory, which only accepts KV args (unless
you use the <code>reopenClass-positionalParams</code> api)</li>
</ul>
<p>Given that we're introducing a Unified Renderable syntax, it would be
unfortunate if we did nothing to address this impedance mismatch between
named and positional params. The goal is for component consumers/invokers to
be able to pass the most &quot;convenient&quot; kind of Renderable for their use
case, be it a simple primitive string value, a block if they want the
lexical scope + block params, or a component factory for rendering
a shared component that might be used in many places throughout the app.
Unfortunately, the component author will have to choose whether they
want to pass positional params (which would push consumers towards
only using  blocks) or named params (which are presently only supported
by component factories).</p>
<p>Hence, for this reason (among others), it makes sense to introduce a
syntax for named block params; with this syntax, there will be an
organic shift towards component authors using named KV pairs for passing
data in most cases (while still allowing positional params in certain
simpler cases were it only really makes sense to use a block, e.g.
control flow components that wrap <code>if</code> or <code>each</code>, etc.)</p>
<p>Here is the syntax for named block params:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |@title @data|&gt;
    The title: {{@title}}
    The data: {{@data}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>There is also a &quot;soaking&quot; syntax which is useful in cases where nested
blocks might introduce new named block params that clobber preexisting
identifiers in the scope, as well as cases where spelling out each
named block param consumes too much rightward space. The above example
can be expressed using the soaking syntax as follows:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |@...d|&gt;
    The title: {{d.title}}
    The data: {{d.data}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>(The <code>@</code> is not included as part of the identifier as that would
suggest it was a KV arg rather than essentially a hash of args.)</p>
<a class="header" href="print.html#block-form-of-unified-renderable-syntax" id="block-form-of-unified-renderable-syntax"><h4>Block form of Unified Renderable syntax</h4></a>
<p>It should be possible to pass a block TO the
block/component-factory that's been passed into a component.
The common use cases for this are:</p>
<a class="header" href="print.html#passing-a-block-to-a-component-factory" id="passing-a-block-to-a-component-factory"><h5>Passing a block to a component factory</h5></a>
<p>Given the following invocation:</p>
<pre><code>{{x-modal header=(component 'my-header')}}
</code></pre>
<p>It should be possible for <code>x-modal</code> to pass a block to the <code>header</code>
renderable:</p>
<pre><code>// ember-component x-modal layout
{{#this.header title=&quot;ima title&quot;}}
  I'm a block provided by the component layout template.
{{/this.header}}
</code></pre>
<p>Assuming <code>my-header</code> had a layout of:</p>
<pre><code>&lt;div class=&quot;my-header-inner&quot;&gt;
  title is {{title}}
  {{yield}}
&lt;/div&gt;
</code></pre>
<p>This would render the following (assuming <code>x-modal</code> and <code>my-header</code> are
Ember components with <code>tagName: 'div'</code> with <code>classNames</code> set):</p>
<pre><code>&lt;div class=&quot;x-modal&quot;&gt;
  &lt;div class=&quot;my-header&quot;&gt;
    &lt;div class=&quot;my-header-inner&quot;&gt;
      title is ima title
      I'm a block provided by the component layout template.
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#passing-a-block-to-a-block-aka-contextual-components" id="passing-a-block-to-a-block-aka-contextual-components"><h5>Passing a block to a block (aka contextual components)</h5></a>
<p>Given the following invocation:</p>
<pre><code>{{#x-modal}}
  &lt;@header as |@title @main|&gt;
    &lt;div class=&quot;header-block-content&quot;&gt;
      title is {{@title}}
      {{@main}}
    &lt;/div&gt;
  &lt;/header&gt;
{{/x-modal}}
</code></pre>
<p>This would render the following (assuming the same <code>x-modal</code> layout
as the previous example:</p>
<pre><code>&lt;div class=&quot;x-modal&quot;&gt;
  &lt;div class=&quot;header-block-content&quot;&gt;
    title is ima title
    I'm a block provided by the component layout template.
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>It would also be possible to pass a component factory to the header
block from <code>x-modal</code>'s layout:</p>
<pre><code>// ember-component x-modal layout
{{this.header title=&quot;ima title&quot;
         main=(component 'x-modal-inner-content')}}
</code></pre>
<p>The multi-block syntax can be used as well with Unified Renderable
syntax:</p>
<pre><code>{{#header}}
  &lt;@main&gt;
    I'm a block provided by the component layout template.
  &lt;/@main&gt;

  &lt;@title&gt;
    ima title
  &lt;/@title&gt;
{{/header}}
</code></pre>
<a class="header" href="print.html#block-form-of--prefixed-identifiers" id="block-form-of--prefixed-identifiers"><h5>Block form of <code>@</code>-prefixed identifiers</h5></a>
<p>The syntax for passing a block to an <code>@</code>-prefixed identifier
(named block params and Glimmer <code>@arg</code>s) will be
<code>{{#@thing}} ... {{/@thing}}</code>, e.g.:</p>
<pre><code>{{#x-layout as |@widget|}}
  {{#@widget as |a b c|}}
    Hi.
  {{/@widget}}
{{/x-layout}}
</code></pre>
<a class="header" href="print.html#classic-single-block-syntax-main-and-else-args" id="classic-single-block-syntax-main-and-else-args"><h3>Classic single-block syntax: <code>main</code> and <code>else</code> args</h3></a>
<p>It would be unfortunate if component authors had to use different
syntaxes for rendering named blocks vs the traditional &quot;default&quot;
and &quot;inverse&quot; blocks provided by the classic single-block syntax.</p>
<p>Hence, the blocks provided in classic single-block syntax should also
be exposed as properties (Ember) and args (Glimmer), and should have
conventional, meaningful names: instead of &quot;default&quot; (which is a
bit misleading) and &quot;inverse&quot;, we standardize on <code>main</code> and <code>else</code>.</p>
<a class="header" href="print.html#glimmer-components-main-and-else" id="glimmer-components-main-and-else"><h4>Glimmer Components: <code>@main</code> and <code>@else</code></h4></a>
<p>Given Glimmer component invocation:</p>
<pre><code>{{#fancy-if cond=trueOrFalse}}
  True
{{else}}
  False
{{/fancy-component}}
</code></pre>
<p>The component layout could be:</p>
<pre><code>{{#if cond}}
  {{@main}}
{{else}}
  {{@else}}
{{/if}}
</code></pre>
<p>Note that angle-bracket syntax doesn't support passing in an
inverse/else block, but the block provided to angle-bracket invocation
would be passed in as <code>@main</code>.</p>
<a class="header" href="print.html#ember-components-main-and-else" id="ember-components-main-and-else"><h4>Ember Components: <code>main</code> and <code>else</code></h4></a>
<p>For Ember, we can't suddenly start setting <code>main</code> and <code>else</code> properties
on the component instances as this would be a breaking change, and
<code>main</code> in particular is not an uncommon property name.</p>
<p>We also shouldn't punt on this feature for Ember components for the
following reasons/use cases:</p>
<ul>
<li><a href="https://github.com/emberjs/rfcs/pull/226#issuecomment-299949000">ember-elsewhere</a>
(and other similar patterns) require having access to the opaque block
so that it can be stashed on a service and rendered elsewhere</li>
<li>wrapper components that forward args/properties/blocks to another
internal component; blocks need to be accessible as properties in order
to pass them into another component (otherwise you'd have to use a
combinatoric mess of block syntax + <code>if hasBlock</code> checks to forward
blocks through to the inner component)</li>
</ul>
<p>So we need an opt-in API; any Ember Component that wants <code>main</code>/<code>else</code>
properties to be set on the component instance need to opt into this
behavior via a mixin provided by Ember:</p>
<pre><code>import { ImplicitBlockPropertyMixin } from &quot;@ember/implicit-block-property-support&quot;;

export default Ember.Component.extend(ImplicitBlockPropertyMixin, {
  blockManager: inject.service(),
  init() {
    this._super();
    this.get('blockManager').registerBlock(this.get('main'));
  },
});
</code></pre>
<p>So if <code>fancy-if</code> were an Ember component that used this mixin, then
given the component invocation:</p>
<pre><code>{{#fancy-if cond=trueOrFalse}}
  True
{{else}}
  False
{{/fancy-if}}
</code></pre>
<p>The following ember component layout would work:</p>
<pre><code>{{#if cond}}
  {{this.main}}
{{else}}
  {{this.else}}
{{/if}}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-27" id="how-we-teach-this-27"><h1>How We Teach This</h1></a>
<p>We teach this as a followup to classic block syntax; once the user is comfortable with single-block syntax, we can introduce named block syntax for more complex use cases.</p>
<p>We teach that what <code>&lt;@blockName&gt;&lt;/@blockName&gt;</code> syntax really means is
that we're just passing in an arg named <code>@blockName</code>, which is like
any other arg we might pass into a component, but it happens to point
to a template block than, say, some simple string value.</p>
<a class="header" href="print.html#drawbacks-51" id="drawbacks-51"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#different-from-wc-slot-syntax" id="different-from-wc-slot-syntax"><h3>Different from WC slot syntax</h3></a>
<p>This isn't really anything like the
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot">WebComponents slot syntax</a>
that intends to address similar use cases, so there is some risk of
introducing an API that doesn't fit in with what the rest of the world
is doing.</p>
<a class="header" href="print.html#syntax-highlighting-changes" id="syntax-highlighting-changes"><h3>Syntax highlighting changes</h3></a>
<p>Some syntax highlighters might have trouble with this syntax; all
the editors I've tried it on look reasonable, but GitHub's Handlebars
parser isn't too kind (hence I've been using <code>html</code> snippets instead
of <code>handlebars</code> snippets):</p>
<pre><code class="language-hbs">&lt;x-modal&gt;
  &lt;@header as |c|&gt;
    ...
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    ...
  &lt;/@main&gt;
&lt;/x-modal&gt;
</code></pre>
<a class="header" href="print.html#conditionally-passing-blocks" id="conditionally-passing-blocks"><h3>Conditionally passing blocks?</h3></a>
<p>This RFC does NOT introduce any kind of facility for conditionally passing
blocks, e.g.:</p>
<pre><code class="language-html">{{! this syntax is INVALID! }}
&lt;x-layout&gt;
  &lt;@header&gt;...&lt;/@header&gt;
  &lt;@main&gt;...&lt;/@main&gt;

  {{#if userCanProceed}}
    &lt;@footer&gt;
      {{submit-button}}
    &lt;/@footer&gt;
  {{/if}}
&lt;/x-layout&gt;
</code></pre>
<p>This might be desirable in the future, particularly for use cases
involving flex-ish layouts where the component changes behavior /
appearance based on whether blocks on passed in.</p>
<a class="header" href="print.html#alternatives-52" id="alternatives-52"><h1>Alternatives</h1></a>
<p>I'd proposed a JSX-y <a href="https://github.com/emberjs/rfcs/pull/203">attr/component-centric</a> syntax for passing what are essentially DOM lambdas, rendered with <code>{{component}}</code>. Perhaps we'll add something like that feature in the future, but it's a much less natural enhancement to Ember than named blocks.</p>
<a class="header" href="print.html#considerations-for-future-rfcs" id="considerations-for-future-rfcs"><h1>Considerations for Future RFCs</h1></a>
<a class="header" href="print.html#defining-default-blocks" id="defining-default-blocks"><h2>Defining Default Blocks</h2></a>
<p>There's not really a nice way defining default blocks inside your
component layout (i.e. the block you render when known is provided at
invocation time), but then again I believe the following would be
a workable approach that is probably support by the features proposed in
this RFC?</p>
<pre><code>{{#with-blocks}}
  &lt;@mainOrDefault&gt;
    {{#if main}}
      {{main}}
    {{else}}
      I am the default main block when none is passed in.
    {{/if}}
  &lt;/@mainOrDefault&gt;

  &lt;@footerOrDefault&gt;
    {{#if footer}}
      {{footer}}
    {{else}}
      I am the default footer block when none is passed in.
    {{/if}}
  &lt;/@footerOrDefault&gt;

  &lt;@render as |@mainOrDefault @footerOrDefault|&gt;
    {{! this specially-named block gets passed all the other blocks above}}

    {{mainOrDefault}}
    {{footerOrDefault}}
  &lt;/@render&gt;
{{/with-blocks}}
</code></pre>
<p>Either way, it feels hacky and weird and I would be surprised if we'd
want/need a future RFC to define a nicer way to support default blocks.</p>
<a class="header" href="print.html#allow-passing-multiple-blocks-with-the-same-name" id="allow-passing-multiple-blocks-with-the-same-name"><h2>Allow passing multiple blocks with the same name</h2></a>
<p>e.g.</p>
<pre><code class="language-html">{{#power-select}}
  &lt;@option value=&quot;foo&quot;&gt;
    &lt;em&gt;Foo&lt;/em&gt;
  &lt;/@option&gt;
  &lt;@option value=&quot;bar&quot;&gt;
    &lt;blink&gt;Bar&lt;/blink&gt;
  &lt;/@option&gt;
{{/power-select}}
</code></pre>
<p>This RFC defines that passing multiple blocks with the same name is a
syntax error, but it's something we might want to relax in the future
for certain cases where you want to pass arrays of blocks, such as
<code>power-select</code> or use cases involving tables.</p>
<ul>
<li>Start Date: 2017-06-11</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/229">emberjs/rfcs#229</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-53" id="summary-53"><h1>Summary</h1></a>
<p>In order to largely reduce the brittleness of tests, this RFC proposes to
remove the concept of artificially restricting the resolver used under
testing.</p>
<a class="header" href="print.html#motivation-54" id="motivation-54"><h1>Motivation</h1></a>
<p>Disabling the resolver while running tests leads to extremely brittle tests.</p>
<p>It is not possible for collaborators to be added to the object (or one
of its dependencies) under test, without modifying the test itself (even if
exactly the same API is exposed).</p>
<p>The ability to restrict the resolver is <strong>not</strong> actually a feature of Ember's
container/registry/resolver system, and has posed as significant maintenance
challenge throughout the lifetime of ember-test-helpers.</p>
<p>Removing this system of restriction will make choosing what kind of test to
be used easier, simplify many of the blueprints, and enable much simpler refactoring
of an applications components/controllers/routes/etc to use collaborating utilties
and services.</p>
<a class="header" href="print.html#transition-path-3" id="transition-path-3"><h1>Transition Path</h1></a>
<a class="header" href="print.html#deprecate-functionality" id="deprecate-functionality"><h2>Deprecate Functionality</h2></a>
<p>Issue a deprecation if <code>integration: true</code> is not included in the specified
options for the APIs listed below. This specifically includes specifying
<code>unit: true</code>, <code>needs: []</code>, or specifying none of the &quot;test type options&quot;
(<code>unit</code>, <code>needs</code>, or <code>integration</code> options) to the following <code>ember-qunit</code>
and <code>ember-mocha</code> API's:</p>
<ul>
<li><code>ember-qunit</code>
<ul>
<li><code>moduleFor</code></li>
<li><code>moduleForComponent</code></li>
<li><code>moduleForModel</code></li>
</ul>
</li>
<li><code>ember-mocha</code>
<ul>
<li><code>setupTest</code></li>
<li><code>setupComponentTest</code></li>
<li><code>setupModelTest</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#non-component-test-apis" id="non-component-test-apis"><h3>Non Component Test APIs</h3></a>
<p>The migration path for <code>moduleFor</code>, <code>moduleForModel</code>, <code>setupTest</code>, and
<code>setupModelTest</code> is very simple:</p>
<pre><code class="language-js">// ember-qunit

// before
moduleFor('service:session');

moduleFor('service:session', {
  unit: true
});

moduleFor('service:session', {
  needs: ['type:thing']
});

// after
moduleFor('service:session', {
  integration: true
});
</code></pre>
<pre><code class="language-js">// ember-mocha

// before
describe('Session Service', function() {
  setupTest('service:session');
  
  // ...snip...
});

describe('Session Service', function() {
  setupTest('service:session', { unit: true });
  
  // ...snip...
});

describe('Session Service', function() {
  setupTest('service:session', { needs: [] });
  
  // ...snip...
});

// after

describe('Session Service', function() {
  setupTest('service:session', { integration: true });
  
  // ...snip...
});
</code></pre>
<p>The main change is adding <code>integration: true</code> to options (and removing <code>unit</code> or <code>needs</code>
if present).</p>
<a class="header" href="print.html#component-test-apis" id="component-test-apis"><h3>Component Test APIs</h3></a>
<p>Implicitly relying on &quot;unit test mode&quot; has been deprecated for quite some time
(<a href="https://github.com/emberjs/ember-test-helpers/pull/38">introduced 2015-04-07</a>),
so all consumers of <code>moduleForComponent</code> and <code>setupComponentTest</code> are specifying
one of the &quot;test type options&quot; (<code>unit</code>, <code>needs</code>, or <code>integration</code>).</p>
<p>This RFC proposes to deprecate completely using <code>unit</code> or <code>needs</code> options with
<code>moduleForComponent</code> and <code>setupComponentTest</code>. The vast majority of component tests
should be testing via <code>moduleForComponent</code> / <code>setupComponentTest</code> with the <code>integration: true</code>
option set, but on some rare occaisions it is easier to use the &quot;unit test&quot; style is
desired (e.g. non-rendering test) these tests should be migrated to using <code>moduleFor</code>
/ <code>setupTest</code> directly.</p>
<pre><code class="language-js">// ember-qunit

// before
moduleForComponent('display-page', {
  unit: true
});

moduleForComponent('display-page', {
  needs: ['type:thing']
});

// after

moduleFor('component:display-page', {
  integration: true
});
</code></pre>
<pre><code class="language-js">// ember-mocha
describe('DisplayPageComponent', function() {
  setupComponentTest('display-page', { unit: true });
  
  // ...snip...
});

describe('DisplayPageComponent', function() {
  setupComponentTest('display-page', { needs: [] });
  
  // ...snip...
});

// after

describe('DisplayPageComponent', function() {
  setupTest('component:display-page', { integration: true });
  
  // ...snip...
});
</code></pre>
<a class="header" href="print.html#ecosystem-updates" id="ecosystem-updates"><h2>Ecosystem Updates</h2></a>
<p>The blueprints in all official projects (and any provided by popular
addons) will need to be updated to avoid triggering a deprecation.</p>
<p>This includes:</p>
<ul>
<li><code>ember-source</code></li>
<li><code>ember-data</code></li>
<li><code>ember-cli-legacy-blueprints</code></li>
<li>Others?</li>
</ul>
<a class="header" href="print.html#remove-deprecated-unit--needs-options" id="remove-deprecated-unit--needs-options"><h2>Remove Deprecated <code>unit</code> / <code>needs</code> Options</h2></a>
<p>Once the changes from this RFC are made, we will be able to remove
support for the <code>unit</code> and <code>needs</code> options from <code>ember-test-helpers</code>,
<code>ember-qunit</code>, and <code>ember-mocha</code>. This would be a &quot;semver major&quot;
version bump for all of the related libraries to properly signal that
functionality was removed.</p>
<p>Once the underlying libraries have done a major version bump, we will
introduce a deprecation for using the <code>integration</code> option. This
deprecation would be issued once for the entire test suite (not once
per test module which has <code>integration</code> passed in). We will also update
the blueprints to remove the extraneous <code>integration</code> option.</p>
<a class="header" href="print.html#how-we-teach-this-28" id="how-we-teach-this-28"><h1>How We Teach This</h1></a>
<p>This RFC would require an audit of the main Ember.js guides to ensure
that all usages of the APIs in question continue to be non-deprecated
valid usages.</p>
<a class="header" href="print.html#drawbacks-52" id="drawbacks-52"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#churn" id="churn"><h2>Churn</h2></a>
<p>One drawback to this deprecation proposal is the churn associated with
modifying the options passed for each test. This can almost certainly
be mitigated by providing a codemod to enable automated updating.</p>
<p>There are additional changes being entertained that would require changes
for the default testing blueprints, we should ensure that these RFCs do not
conflict or cause undue churn/pain.</p>
<a class="header" href="print.html#integration-true-confusion" id="integration-true-confusion"><h2><code>integration: true</code> Confusion</h2></a>
<p>Prior to this deprecation we had essentially 4 options for testing components:</p>
<ul>
<li><code>moduleFor(..., { unit: true })</code></li>
<li><code>moduleFor(..., { integration: true })</code></li>
<li><code>moduleForComponent(..., { unit: true })</code></li>
<li><code>moduleForComponent(..., { integatrion: true })</code></li>
</ul>
<p>With this RFC the option <code>integration</code> no longer provides value (we aren't talking
about &quot;unit&quot; vs &quot;integration&quot; tests), and may be seen as confusing.</p>
<p>I believe that this concern is mitigated by the ultimate removal of the <code>integration</code>
(it is only required in order to allow us a path forward that is compatible with
todays ember-qunit/ember-mocha versions).</p>
<ul>
<li>Start Date: 2017-06-13</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/232">emberjs/rfcs#232</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-54" id="summary-54"><h1>Summary</h1></a>
<p>In order to embrace newer features being added by QUnit (our chosen default
testing framework), we need to reduce the brittle coupling between <code>ember-qunit</code>
and QUnit itself.</p>
<p>This RFC proposes a new testing syntax, that will expose QUnit API directly while
also making tests much easier to understand.</p>
<a class="header" href="print.html#motivation-55" id="motivation-55"><h1>Motivation</h1></a>
<p>QUnit feature development has been accelerating since the ramp up to QUnit 2.0.
A number of new features have been added that make testing our applications
much easier, but the current structure of <code>ember-qunit</code> impedes our ability
to take advantage of some of these features.</p>
<p>Developers are often confused by our <code>moduleFor*</code> APIs, questions like these
are very common:</p>
<ul>
<li>What &quot;magic&quot; is <code>ember-qunit</code> doing?</li>
<li>Where are the lines between QUnit and ember-qunit?</li>
<li>How can I use QUnit for plain JS objects?</li>
</ul>
<p>The way that <code>ember-qunit</code> wraps QUnit functionality makes the division
of responsiblity much harder to understand, and leads folks to believe that there
is much more going on in <code>ember-qunit</code> than there is. It should be much clearer
what <code>ember-qunit</code> is responsible for and what we rely on QUnit for.</p>
<p>This RFC also aims to remove a number of custom testing only APIs that exist today
(largely because the container/registry system was completely private when the
current tools were authored). Instead of things like <code>this.subject</code>, <code>this.register</code>,
<code>this.inject</code>, or <code>this.lookup</code> we can rely on the standard way of performing these
functions in Ember via the owner API.</p>
<p>When this RFC has been implemented and rolled out, these questions should all be
addressed and our testing system will both: embrace QUnit much more <strong>and</strong>
be much more framework agnostic, all the while dropping custom testing only APIs
in favor of public APIs that work across tests and app code.</p>
<p>Sounds like a neat trick, huh?</p>
<a class="header" href="print.html#detailed-design-51" id="detailed-design-51"><h1>Detailed design</h1></a>
<p>The primary change being proposed in this RFC is to migrate to using the QUnit
nested module syntax, and update our custom setup/teardown into a more functional
API.</p>
<p>Lets look at a basic example:</p>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('x-foo', {
  integration: true
});

test('renders', function(assert) {
  assert.expect(1);

  this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

  assert.equal(this.$('.color-name').text(), 'red');
});

// **** after ****

import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

module('x-foo', function(hooks) {
  setupRenderingTest(hooks);

  test('renders', async function(assert) {
    assert.expect(1);

    await this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

    assert.equal(this.$('.color-name').text(), 'red');
  });
});
</code></pre>
<p>As you can see, this proposal leverages QUnit's nested module API in a way that
makes it much clearer what is going on. It is quite obvious what QUnit is doing
(acting like a general testing framework) and what <code>ember-qunit</code> is doing
(setting up rendering functionality).</p>
<p>This API was heavily influenced by the work that
<a href="https://github.com/Turbo87">Tobias Bieniek</a> did in
<a href="https://github.com/emberjs/ember-mocha/pull/84">emberjs/ember-mocha#84</a>.</p>
<a class="header" href="print.html#qunit-nested-modules-api" id="qunit-nested-modules-api"><h2>QUnit Nested Modules API</h2></a>
<p>Even though it is not a proposal of this RFC, the QUnit nested module
syntax may seem foreign to some folks so lets briefly review.</p>
<p>With nested modules, a normal 1.x QUnit module setup changes from:</p>
<pre><code class="language-js">QUnit.module('some description', {
  before() {},
  beforeEach() {},
  afterEach() {},
  after() {}
});

QUnit.test('it blends', function(assert) {
  assert.ok(true, 'of course!');
});
</code></pre>
<p>Into:</p>
<pre><code class="language-js">QUnit.module('some description', function(hooks) {

  hooks.before(() =&gt; {});
  hooks.beforeEach(() =&gt; {});
  hooks.afterEach(() =&gt; {});
  hooks.after(() =&gt; {});

  QUnit.test('it blends', function(assert) {
    assert.ok(true, 'of course!');
  });
});
</code></pre>
<p>This makes it much simpler to support multiple <code>before</code>, <code>beforeEach</code>, <code>afterEach</code>,
and <code>after</code> callbacks, and it also allows for arbitrary nesting of modules.</p>
<p>You can read more about QUnit nested modules
<a href="http://api.qunitjs.com/QUnit/module#nested-module-nested-hooks-">here</a>. The new APIs
proposed in this RFC expect to be leveraging nested modules.</p>
<a class="header" href="print.html#new-apis" id="new-apis"><h2>New APIs</h2></a>
<p>The following new methods will be exposed from <code>ember-qunit</code>:</p>
<pre><code class="language-ts">interface QUnitModuleHooks {
  before(callback: Function): void;
  beforeEach(callback: Function): void;
  afterEach(callback: Function): void;
  after(callback: Function): void;
}

declare module 'ember-qunit' {
  // ...snip... 
  export function setupTest(hooks: QUnitModuleHooks): void;
  export function setupRenderingTest(hooks: QUnitModuleHooks): void;
}
</code></pre>
<a class="header" href="print.html#setuptest" id="setuptest"><h3><code>setupTest</code></h3></a>
<p>This function will:</p>
<ul>
<li>invoke <code>ember-test-helper</code>s <code>setContext</code> with the tests context</li>
<li>create an owner object and set it on the test context (e.g. <code>this.owner</code>)</li>
<li>setup <code>this.set</code>, <code>this.setProperties</code>, <code>this.get</code>, and <code>this.getProperties</code> to
the test context</li>
<li>setup <code>this.pauseTest</code> and <code>this.resumeTest</code> methods to allow easy pausing/resuming
of tests</li>
</ul>
<a class="header" href="print.html#setuprenderingtest" id="setuprenderingtest"><h3><code>setupRenderingTest</code></h3></a>
<p>This function will:</p>
<ul>
<li>run the <code>setupTest</code> implementation</li>
<li>setup <code>this.$</code> method to run jQuery selectors rooted to the testing container</li>
<li>setup a getter for <code>this.element</code> which returns the DOM element representing
the element that was rendered via <code>this.render</code></li>
<li>setup Ember's renderer and create a <code>this.render</code> method which accepts a
compiled template to render and returns a promise which resolves once rendering
is completed</li>
<li>setup <code>this.clearRender</code> method which clears any previously rendered DOM (
also used during cleanup)</li>
</ul>
<p>When invoked, <code>this.render</code> will render the provided template and return a
promise that resolves when rendering is completed.</p>
<a class="header" href="print.html#changes-from-current-system" id="changes-from-current-system"><h2>Changes from Current System</h2></a>
<p>Here is a brief list of the more important but possibly understated changes
being proposed here:</p>
<ul>
<li>the various setup methods no longer need to know the name of the object under test</li>
<li><code>this.subject</code> is removed in favor of using the standard public API for looking up
and creating instances (<code>this.owner.lookup</code> and <code>this.owner.factoryFor</code>)</li>
<li><code>this.inject</code> is removed in favor of using <code>this.owner.lookup</code> directly</li>
<li><code>this.register</code> is removed in favor of using <code>this.owner.register</code> directly</li>
<li><code>this.render</code> will begin being asynchronous to allow for further iteration in the
underlying rendering engines ability to speed up render times (by yielding back
to the browser and not blocking the main thread)</li>
<li><code>this.pauseTest</code> and <code>this.resumeTest</code> are being added</li>
<li><code>this.element</code> is being introduced as a public API for DOM assertions in a jQuery-less
environment</li>
<li>QUnit nested modules are required</li>
</ul>
<p>These changes generally do not affect our ability to write a codemod to aide in the migration.</p>
<a class="header" href="print.html#migration-examples" id="migration-examples"><h2>Migration Examples</h2></a>
<p>The migration can likely be largely automated (following the
<a href="https://github.com/Turbo87/ember-mocha-codemods">excellent codemod</a> that
<a href="https://github.com/turbo87">Tobias Bieniek</a> wrote for a similar <code>ember-mocha</code>
the transition), but it is still useful to review concrete scenarios
of tests before and after this RFC is implemented.</p>
<a class="header" href="print.html#component--helper-integration-test" id="component--helper-integration-test"><h3>Component / Helper Integration Test</h3></a>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('x-foo', {
  integration: true
});

test('renders', function(assert) {
  assert.expect(1);

  this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

  assert.equal(this.$('.color-name').text(), 'red');
});

// **** after ****

import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

module('x-foo', function(hooks) {
  setupRenderingTest(hooks);

  test('renders', async function(assert) {
    assert.expect(1);

    await this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

    assert.equal(this.$('.color-name').text(), 'red');
  });
});
</code></pre>
<a class="header" href="print.html#component-unit-test" id="component-unit-test"><h3>Component Unit Test</h3></a>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';

moduleForComponent('x-foo', {
  unit: true
});

test('computes properly', function(assert) {
  assert.expect(1);

  let subject = this.subject({
    name: 'something'
  });

  let result = subject.get('someCP');
  assert.equal(result, 'expected value');
});

// **** after ****

import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('x-foo', function(hooks) {
  setupTest(hooks);

  test('computed properly', function(assert) {
    assert.expect(1);

    let Factory = this.owner.factoryFor('component:x-foo');
    let subject = Factory.create({
      name: 'something'
    });

    let result = subject.get('someCP');
    assert.equal(result, 'expected value');
  });
});
</code></pre>
<a class="header" href="print.html#serviceroutecontroller-test" id="serviceroutecontroller-test"><h3>Service/Route/Controller Test</h3></a>
<pre><code class="language-js">// **** before ****

import { moduleFor, test } from 'ember-qunit';

moduleFor('service:flash', 'Unit | Service | Flash', {
  unit: true
});

test('should allow messages to be queued', function (assert) {
  assert.expect(4);
  
  let subject = this.subject();
  
  subject.show('some message here');
  
  let messages = subject.messages;
  
  assert.deepEqual(messages, [
    'some message here'
  ]);
});

// **** after ****

import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('Unit | Service | Flash', function(hooks) {
  setupTest(hooks);
  
  test('should allow messages to be queued', function (assert) {
    assert.expect(4);
  
    let subject = this.owner.lookup('service:flash');
  
    subject.show('some message here');
  
    let messages = subject.messages;
  
    assert.deepEqual(messages, [
      'some message here'
    ]);
  });
});

</code></pre>
<a class="header" href="print.html#ecosystem-updates-1" id="ecosystem-updates-1"><h2>Ecosystem Updates</h2></a>
<p>The blueprints in all official projects (and any provided by popular addons)
will need to be updated to detect <code>ember-qunit</code> version and emit the correct
output.</p>
<p>This includes:</p>
<ul>
<li>ember-source</li>
<li>ember-data</li>
<li>ember-cli-legacy-blueprints</li>
<li>others?</li>
</ul>
<p>This exact process was done for <code>ember-mocha</code>'s migration, making this a well
trodden path.</p>
<a class="header" href="print.html#update-guides" id="update-guides"><h2>Update Guides</h2></a>
<p>The guides includes a section for testing, this section needs to be reviewed
and revamped to match the proposal here.</p>
<a class="header" href="print.html#deprecate-older-apis" id="deprecate-older-apis"><h2>Deprecate older APIs</h2></a>
<p>Once this RFC is implemented, the older APIs will be deprecated and retained
for a full LTS cycle (assuming speedy landing, this would mean the older APIs
would be deprecated around Ember 2.20). After that timeframe, the older APIs
will be removed from <code>ember-qunit</code> and <code>ember-test-helpers</code> and they will
release with SemVer major version bumps.</p>
<p>Note that while the older <code>moduleFor</code> and <code>moduleForComponent</code> APIs will be
deprecated, they will still be possible to use since the host application can
pin to a version of <code>ember-qunit</code> / <code>ember-test-helpers</code> that support its own
usage. This is a large benefit of migrating these testing features away from
<code>Ember</code>'s internals, and into the addon space.</p>
<a class="header" href="print.html#relationship-to-grand-testing-unification" id="relationship-to-grand-testing-unification"><h2>Relationship to &quot;Grand Testing Unification&quot;</h2></a>
<p>This RFC is a small stepping stone towards the future where all types of tests
share a similar API. The API proposed here is much easier to extend to provide
the functionality that is required for <a href="https://github.com/emberjs/rfcs/pull/119">emberjs/rfcs#119</a>.</p>
<a class="header" href="print.html#how-we-teach-this-29" id="how-we-teach-this-29"><h1>How We Teach This</h1></a>
<p>This change requires updates to the API documentation of <code>ember-qunit</code> and the
main Ember guides' testing section. The changes are largely intended to reduce
confusion, making it easier to teach and understand testing in Ember.</p>
<a class="header" href="print.html#drawbacks-53" id="drawbacks-53"><h1>Drawbacks</h1></a>
<a class="header" href="print.html#churn-1" id="churn-1"><h2>Churn</h2></a>
<p>As mentioned in <a href="https://github.com/emberjs/rfcs/pull/229">emberjs/rfcs#229</a>, test
related churn is quite painful and annoying. In order to maintain the general
goodwill of folks, we must ensure that we avoid needless churn.</p>
<p>This RFC should be implemented in conjunction with
<a href="https://github.com/emberjs/rfcs/pull/229">emberjs/rfcs#229</a> so that we can avoid
multiple back to back changes in the blueprints.</p>
<a class="header" href="print.html#a-hrefhttpsgithubcomqunitjsqunitissues977qunitjsqunit977a" id="a-hrefhttpsgithubcomqunitjsqunitissues977qunitjsqunit977a"><h2><a href="https://github.com/qunitjs/qunit/issues/977">qunitjs/qunit#977</a></h2></a>
<p>Until very recently, the QUnit nested module API was only able to allow a single
callback for each of the hooks per-nesting level. This means that the proposal in
this RFC (which requires the hooks to be setup by <code>ember-qunit</code>) would disallow
user-land <code>beforeEach</code>/<code>afterEach</code> hooks to be setup.</p>
<p>The work around is &quot;simple&quot; (if somewhat annoying), which is to &quot;just nest another
level&quot;. The good news is that <a href="https://github.com/trentwillis">Trent Willis</a> fixed
the underlying problem in <a href="https://github.com/qunitjs/qunit/pull/1188">qunitjs/qunit#1188</a>,
which should be released as 2.3.4 well before this RFC is merged.</p>
<a class="header" href="print.html#alternatives-53" id="alternatives-53"><h1>Alternatives</h1></a>
<p>The simplest alternative is to do nothing. This would loose all of the positive
benefits mentioned in this RFC, but should still be considered a possibility...</p>
<a class="header" href="print.html#unanswered-questions" id="unanswered-questions"><h1>Unanswered Questions</h1></a>
<a class="header" href="print.html#hooks-argument" id="hooks-argument"><h2><code>hooks</code> argument</h2></a>
<p>A few folks (e.g. <a href="https://github.com/ebryn">@ebryn</a> and <a href="https://github.com/stefanpenner">@stefanpenner</a>)
have approached me with concerns around the <code>hooks</code> argument I have mentioned/used here. The concerns
are generally an initial reaction to the QUnit nested modules API in general and not directly related
to this RFC (other than it highlighting a new feature that they haven't used before).</p>
<p>The main concerns are:</p>
<ul>
<li>Teaching folks what <code>hooks</code> means is a bit more difficult because it does not represent the &quot;test
environment&quot;, but rather just a way to invoke the callbacks for <code>before</code> / <code>beforeEach</code> / <code>after</code> /
<code>afterEach</code>.</li>
<li>Passing only <code>hooks</code> to the helper functions proposed in the RFC means that if we ever need to thread
more information through, we either have to use <code>hooks</code> as a transport or change our API to add more
arguments.</li>
<li>It seems somewhat impossible to communicate across multiple helpers (again without using <code>hooks</code>
as a state/transport mechanism).</li>
</ul>
<p>I've kicked off a conversation over with the QUnit folks in https://github.com/qunitjs/qunit/issues/1200.
If that PR were merged this proposal would be modified to the following syntax:</p>
<pre><code class="language-js">// current proposal
module('x-foo', function(hooks) {
  setupRenderingTest(hooks);
  // ....snip....
});

// after qunitjs/qunit#1200
module('x-foo', function(hooks) {
  setupRenderingTest(this);
  // ....snip....
});
</code></pre>
<p>Another possible solution is to rename the argument (here and in the blueprints) to <code>module</code>.
This is more in line with what the QUnit folks view it as: the &quot;module context&quot; that
is being created for that specific <code>QUnit.module</code> invocation.</p>
<ul>
<li>Start Date: 2017-07-14</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/236</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/15624</li>
</ul>
<a class="header" href="print.html#summary-55" id="summary-55"><h1>Summary</h1></a>
<p>This RFC proposes to deprecate the prototype extensions done by <code>Ember.String</code>, deprecate the <code>loc</code> method, and moving <code>htmlSafe</code> and <code>isHTMLSafe</code> to <code>@ember/template</code>.</p>
<a class="header" href="print.html#motivation-56" id="motivation-56"><h1>Motivation</h1></a>
<p>Much of the public API of Ember was designed and published some time ago, when the client-side landscape looked much different. It was a time without many utilities and methods that have been introduced to JavaScript since, without the current rich npm ecosystem, and without ES6 modules. On the Ember side, Ember CLI and the subsequent addons were still to be introduced. Global mode was the way to go, and extending native prototypes like Ember does for <code>String</code>, <code>Array</code> and <code>Function</code> was a common practice.</p>
<p>With the introduction of <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md">RFC #176</a>, an opportunity to reduce and reorganize the API that is shipped by default with an Ember application appears. A lot of nice-to-have functionality that was added at that time can now be moved to optional packages and addons, where they can be maintained and evolved without being tied to the core of the framework.</p>
<p>In the specific case of <code>Ember.String</code>, our goal is that users that need these utility functions will include <code>@ember/string</code> in their dependencies, or rely on common utility packages like <a href="https://lodash.com/docs/#camelCase"><code>lodash.camelcase</code></a>.</p>
<p>To achieve the above goal we will move the <code>isHTMLSafe</code>/<code>htmlSafe</code> pair into a new package, deprecate <code>String.prototype</code> extensions, and deprecate the utility functions under the <code>Ember.String</code> namespace.</p>
<p>The <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md#organize-by-mental-model">&quot;Organize by Mental Model&quot;</a> section of RFC #176 mentions the concept of chunking. In the current setup, <code>isHTMLSafe</code>/<code>htmlSafe</code> make sense in the <code>Ember.String</code> namespace because they operate on strings, and they are available on the prototype, <code>&quot;myString&quot;.htmlSafe()</code>.
However, once prototype extensions are removed it becomes clearer that while this pair operates on strings, they don't transform them in the same way as <code>capitalize</code> or <code>dasherize</code>. They are instead a way for the user to communicate to the templating engine that this string should be safe to render. For this reason, moving to <code>@ember/template</code> seems appropriate.</p>
<p>Extending native prototypes, like we do for <code>String</code> with <code>&quot;myString&quot;.dasherize()</code> and the rest of the API, has been falling out of favour more as time goes by.
While the tradeoff might have been positive at the beginning, as it allowed users access to a richer API, prototype extensions blur the line between what is the framework and what is the language in a way that is not benefitial in the current module-driven and package-rich ecosystem.</p>
<p>Relatedly, deprecating <code>Ember.String</code> and requiring <code>@ember/string</code> as a dependency allows Ember to provide a leaner default core to all users, as well as iterate faster on the <code>@ember/string</code> package if desired.
Doing this will also open a path to extract more packages in the future.</p>
<a class="header" href="print.html#transition-path-4" id="transition-path-4"><h1>Transition Path</h1></a>
<p>It is important to understand that the transition path will be done in the context of the new modules API defined in RFC #176, which is scheduled to land in 2.16.
As this will likely be first of many packages to be extracted from the Ember source, the transition path arrived on needs to be clear and user-friendly.</p>
<a class="header" href="print.html#what-is-happening-for-framework-developers" id="what-is-happening-for-framework-developers"><h2>What is happening for framework developers?</h2></a>
<p>The order of operations will be as follows:</p>
<ol>
<li>Move <code>htmlSafe</code> and <code>isHTMLSafe</code> to <code>@ember/template</code>
<ul>
<li>Update https://github.com/ember-cli/ember-rfc176-data</li>
</ul>
</li>
<li>Create an <code>@ember/string</code> package with the remaining public API</li>
<li>Create an <code>ember-string-prototype-extensions</code> package that introduces <code>String</code> prototype extensions to aid in transitioning</li>
<li>Make <code>ember-cli-babel</code> aware of the <code>@ember/string</code> package so it tells <code>babel-plugin-ember-modules-api-polyfill</code> not to convert those imports to the global <code>Ember</code> namespace</li>
<li>Update usages in Ember and Ember Data codebases so that the projects do not trigger deprecations</li>
<li>Deprecate <code>Ember.String</code>
<ul>
<li>Write deprecation guide which mentions minimum version of <code>ember-cli-babel</code>, and how/when to use <code>@ember/string</code> and <code>ember-string-prototype-extensions</code> packages</li>
</ul>
</li>
<li>Deprecate <code>loc</code> in <code>@ember/string</code></li>
</ol>
<a class="header" href="print.html#what-is-happening-for-framework-users" id="what-is-happening-for-framework-users"><h2>What is happening for framework users?</h2></a>
<p>If you are using <code>Ember.String.loc</code>, you will be instructed to move to a dedicated localization solution, as this method will be completely deprecated.</p>
<p>If you are using <code>Ember.String.htmlSafe</code> or <code>Ember.String.isHTMLSafe</code>, you will be instructed to run the <a href="https://github.com/ember-cli/ember-modules-codemod"><code>ember-modules-codemod</code></a> and it will update to the correct imports from the <code>@ember/template</code> package.</p>
<p>If you are using one of the other <code>Ember.String</code> methods, like <code>Ember.String.dasherize</code>, you will receive a deprecation warning to inform you that you should run the <a href="https://github.com/ember-cli/ember-modules-codemod"><code>ember-modules-codemod</code></a>, update <code>ember-cli-babel</code> to a specific minor version, and add <code>@ember/string</code> to your application's or addon's dependencies.</p>
<p>If you are using the <code>String</code> prototype extensions, like <code>'myString'.dasherize()</code>, on top of the previous instructions you will be instructed to install <code>ember-string-prototype-extensions</code> in case updating the code to <code>dasherize('myString')</code> is not trivial.</p>
<a class="header" href="print.html#timeline-1" id="timeline-1"><h2>Timeline</h2></a>
<ul>
<li>Deprecations are introduced - Ember 2.x
<ul>
<li><code>String</code> protoype extensions are deprecated</li>
<li><code>Ember.String</code> functions are deprecated</li>
<li><code>loc</code> is completely deprecated</li>
<li><code>isHTMLSafe</code> and <code>htmlSafe</code> are moved to <code>@ember/template</code></li>
</ul>
</li>
<li>Transition packages are introduced - Ember 2.x
<ul>
<li><code>@ember/string</code>, which replaced <code>Ember.String</code></li>
<li><code>ember-string-prototype-extensions</code>, which brings <code>String</code> prototype extensions back</li>
</ul>
</li>
<li>Deprecations are removed - Ember 3.x, <code>@ember/string</code> 2.x
<ul>
<li>New major version of Ember is released</li>
<li>New major version of <code>@ember/string</code> is released</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-30" id="how-we-teach-this-30"><h1>How We Teach This</h1></a>
<a class="header" href="print.html#official-code-bases-and-documentation" id="official-code-bases-and-documentation"><h2>Official code bases and documentation</h2></a>
<p>The official documentation –website, Guides, API documentation– should be updated not to use <code>String</code> prototype extensions.
This documentation should already use the new modules API from an effort to update it for Ember 2.16.</p>
<p>The Guides section on <em>disabling prototype extension</em> will need to be updated when <code>String</code> prototype extensions are removed from Ember.</p>
<p>Resources owned by the Ember teams, such and Ember and Ember Data code bases, the Super Rentals repository, or the builds app for the website, will be updated accordingly.</p>
<a class="header" href="print.html#emberstringhtmlsafe-and-emberstringishtmlsafe" id="emberstringhtmlsafe-and-emberstringishtmlsafe"><h2><code>Ember.String.htmlSafe</code> and <code>Ember.String.isHTMLSafe</code></h2></a>
<p>The move of <code>htmlSafe</code> and <code>isHTMLSafe</code> from <code>Ember.String</code> to <code>@ember/template</code> should be documented as part of the <a href="https://github.com/ember-cli/ember-rfc176-data">ember-rfc176-data</a> and related codemods efforts, as that project is the source of truth for the mappings between the <code>Ember</code> global namespace and <code>@ember</code>-scoped modules.</p>
<a class="header" href="print.html#emberstringloc-and-import--loc--from-emberstring-emberstring-to-emberstring-string-prototype-extensions" id="emberstringloc-and-import--loc--from-emberstring-emberstring-to-emberstring-string-prototype-extensions"><h2><code>Ember.String.loc</code> and <code>import { loc } from '@ember/string';</code>, <code>Ember.String</code> to <code>@ember/string</code>, <code>String</code> prototype extensions</h2></a>
<p>An entry to the <a href="https://emberjs.com/deprecations/">Deprecation Guides</a> will be added outlining the different recommended transition strategies.</p>
<a class="header" href="print.html#emberstringloc-import--loc--from-emberstring" id="emberstringloc-import--loc--from-emberstring"><h3><code>Ember.String.loc</code>, <code>import { loc } from '@ember/string';</code></h3></a>
<p>As this function is deprecated, users will be recommended to use a <a href="https://emberobserver.com/categories/internationalization">dedicated localization solution</a>.</p>
<a class="header" href="print.html#emberstring-to-emberstring" id="emberstring-to-emberstring"><h3><code>Ember.String</code> to <code>@ember/string</code></h3></a>
<p>The way that <code>@ember</code>-scoped modules will work in 2.16 is that <code>ember-cli-babel</code> will convert something like <code>import { dasherize } from '@ember/string';</code> to <code>import Ember from 'Ember'; const dasherize = Ember.String.dasherize;</code>.
What this means is that <code>import { dasherize } from '@ember/string';</code> will trigger a deprecation if you do not have the <code>@ember/string</code> package in your dependencies.</p>
<p>To address the above deprecation you will need to update <code>ember-cli-babel</code> to a a specific minor version or higher, to make sure it has the logic to detect <code>@ember/string</code>. The specific minor version will be known at the time the deprecation guide is written.
You will also need to add <code>@ember/string</code> to your application's development dependencies, or your addon's dependencies.</p>
<a class="header" href="print.html#string-prototype-extensions" id="string-prototype-extensions"><h3><code>String</code> prototype extensions</h3></a>
<p>If you are using <code>'myString'.dasherize()</code> or one of the other functions added to <code>String</code>, you will be instructed to replace that usage with <code>import { dasherize } from '@ember/string'; dasherize('myString')</code>, in addition to the changes on the previous section.</p>
<p>In case your code base is complicated enough that migrating all these usages at the same time is not convenient, you will be able to add <code>ember-string-prototype-extensions</code> to your dependencies, which will bring back extensions, without deprecations.</p>
<a class="header" href="print.html#drawbacks-54" id="drawbacks-54"><h1>Drawbacks</h1></a>
<p>A lot of addons that deal with names depend on this behaviour, so they will need to install the addon. Also, Ember Data and some external serializers require these functions.</p>
<p><code>htmlSafe</code> and <code>isHTMLSafe</code> would need to change packages, thus the reason to try and provide an Ember Watson recipe.</p>
<p>Another side-effect of this change is that certain users might be shipping duplicated code between <code>Ember.String</code> and <code>@ember/string</code>, but it is a necessary stepping stone and might be able to be addressed via svelting.</p>
<a class="header" href="print.html#alternatives-54" id="alternatives-54"><h1>Alternatives</h1></a>
<p>Leave things as they are.</p>
<a class="header" href="print.html#unresolved-questions-43" id="unresolved-questions-43"><h1>Unresolved questions</h1></a>
<p>None.</p>
<ul>
<li>Start Date: 2017-07-20</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/237</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-56" id="summary-56"><h1>Summary</h1></a>
<p>This RFC proposes the deprecation of the following classes:</p>
<ul>
<li><code>Ember.OrderedSet</code></li>
<li><code>Ember.Map</code></li>
<li><code>Ember.MapWithDefault</code></li>
</ul>
<p>These classes need to be moved to an external addon given they are private classes and unused in Ember.js itself.</p>
<a class="header" href="print.html#motivation-57" id="motivation-57"><h1>Motivation</h1></a>
<p>These classes have not been used in Ember itself for a while now. They have always been private but they are used in a few addons, and in particular Ember Data is using them.</p>
<a class="header" href="print.html#transition-path-5" id="transition-path-5"><h1>Transition Path</h1></a>
<p><code>Ember.Map</code> and <code>Ember.MapWithDefault</code> will be deprecated and not extracted, but not before the fix mentioned in the following paragraph is landed in Ember Data. There is already an addon with <code>Ember.OrderedSet</code> extracted (<a href="https://github.com/emberjs/ember-ordered-set">@ember/ordered-set</a>).</p>
<p>Ember Data is quite likely the biggest project using these classes. There is already a PR that needs merging before deprecating <code>Ember.Map</code> and <code>Ember.MapWithDefault</code> https://github.com/emberjs/data/pull/5255. Ember Data still needs to migrate to <code>@ember/ordered-set</code> to its relationship logic.</p>
<p>Once Ember Data is updated to not use the classes from Ember, and that fix is released, the <code>Ember.Map</code> and <code>Ember.MapWithDefault</code> can be deprecated in Ember itself.</p>
<a class="header" href="print.html#how-we-teach-this-31" id="how-we-teach-this-31"><h1>How We Teach This</h1></a>
<p>These classes being private would make this simple than other deprecations. People were not supposed to be using a private API and the few that were, would just need to use a new addon.</p>
<p>This should not impact many codebases.</p>
<a class="header" href="print.html#drawbacks-55" id="drawbacks-55"><h1>Drawbacks</h1></a>
<p>This requires cooperation with Ember Data, the main user of these classes. It would be nice to have moved Ember Data to using the addon before releasing Ember with the deprecation so the average user does not see any deprecation warning.</p>
<a class="header" href="print.html#alternatives-55" id="alternatives-55"><h1>Alternatives</h1></a>
<p>Other option would be moving these classes to Ember Data itself or leaving things as they are now.</p>
<a class="header" href="print.html#unresolved-questions-44" id="unresolved-questions-44"><h1>Unresolved questions</h1></a>
<ul>
<li>Start Date: 2017-07-28</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/240">#240</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-57" id="summary-57"><h1>Summary</h1></a>
<p>This RFC aims to solidify the usage of ES2015 Classes as a public API of Ember so
that users can begin building on them, and projects like <code>ember-decorators</code> can
continue to push forward with experimental Javascript features. This includes:</p>
<ul>
<li>Making the class <code>constructor</code> function a public API</li>
<li>Modifying some of the internals of <code>Ember.Object</code> to support existing features
and make the usage of ES Classes cross-compatible with <code>Ember.Object</code></li>
</ul>
<p>It does <em>not</em> propose additions in the form of helpers or decorators, which should
continue to be iterated on in the community as the spec itself is finalized. It also
does not propose deprecating or removing existing functionality in <code>Ember.Object</code>.</p>
<a class="header" href="print.html#motivation-58" id="motivation-58"><h1>Motivation</h1></a>
<p>The Ember Object model has served its purpose well over the years, but now that
ES Classes are becoming prevalent throughout the wider Javascript community
it is beginning to show its age. With class properties at stage 3 and decorators at
stage 2 in the TC39 process, classes are finally at a point where we can start
integrating them into Ember.</p>
<p>The <a href="https://github.com/rwjblue/ember-decorators">ember-decorators</a> project has been
experimenting with using ES Classes and filling out the Ember feature-set,
allowing us to write Ember classes like so:</p>
<pre><code class="language-javascript">export default class MyComponent extends Ember.Component {
  didInsertElement() {
    // do stuff
  }

  @computed
  get foo() {
    // do stuff
  }

  @action
  bar() {
    // do stuff
  }
}
</code></pre>
<p>Using classes makes Ember easier to teach and understand by normalizing it with
standard Javascript coding practices, and allows us to share code and solutions
with other frameworks and libraries. It also brings with it all the benefits of
ES Class syntax:</p>
<ul>
<li>More aligned with the greater Javascript community</li>
<li>Ability to share code more easily with other libraries and frameworks</li>
<li>Easier to statically analyze</li>
<li>Cleaner and easier to read (subjective)</li>
</ul>
<p>The Ember Object model already works extremely well with ES classes, as
demonstrated above, but there several failure scenarios. Furthermore, because
they are not officially supported as a public API, there is no guarantee
that they will continue to work well. Thus, this RFC seeks to solidify the
behavior of ES Classes so that the community can continue to experiment with
new Javascript features and build on a stable API.</p>
<a class="header" href="print.html#detailed-design-52" id="detailed-design-52"><h1>Detailed Design</h1></a>
<p>Many of the standard features of Ember classes work out of the box today, either with
vanilla ES Classes or through <code>ember-decorators</code>, including:</p>
<ul>
<li>Inheritance</li>
<li>Lifecycle hooks</li>
<li>Computeds</li>
<li>Injections</li>
<li>Actions</li>
</ul>
<p>However, the following features either do not exist or do not work as a
user familiar with <code>Ember.Object</code> would expect:</p>
<ul>
<li>Extending from ES Classes using <code>extend</code></li>
<li>Class properties</li>
<li>Mixins</li>
<li>Observers and events</li>
<li>Merged and concatenated properties</li>
</ul>
<p>These features will require changes to <code>Ember.Object</code></p>
<a class="header" href="print.html#extend" id="extend"><h2>Extend</h2></a>
<p>Currently, once a class is defined using ES Classes it is not possible for users
to extend it using the previous CoreObject style of writing and extending classes.
This can limit the rate of adoption because ES Classes would become a trapdoor -
once you begin using them, you must continue to use them. It would be a particularly
thorny issue for addon developers, who may design components which their users
expect to be able to extend and modify.</p>
<p>This RFC proposes that <code>extend</code> be fixed on ES Classes to make them fully
cross-compatible with the existing syntax. There are two general approaches to
making this work:</p>
<ol>
<li>
<p>Modify CoreObject to use prototypes/ES Classes internally. This would bring
CoreObject more inline with ES Classes, but would be a significant internal change.</p>
</li>
<li>
<p>Modify CoreObject to have different behavior if it is extending an ES Class
using <code>extend</code>.</p>
</li>
</ol>
<p>Both approaches should be explored and benchmarked to determine if there are an
significant advantages to one over the other.</p>
<a class="header" href="print.html#class-properties" id="class-properties"><h2>Class Properties</h2></a>
<p>When using <code>Ember.Object.extend</code>, properties that are passed in on the object
are assigned to the prototype of the class:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({ bar: 'baz' });
const foo = Foo.create();

console.log(Foo.prototype.bar) // 'baz'
foo.hasOwnProperty('bar') // false
</code></pre>
<p>This differs from the behavior of ES Class properties, which initialize their
value on the instance of the class.</p>
<pre><code class="language-javascript">class Foo {
  bar = 'baz'
}

const foo = new Foo();

console.log(Foo.prototype.bar) // undefined
foo.hasOwnProperty('bar') // true
</code></pre>
<p>The above is essentially currently compiled down by Babel to the following:</p>
<pre><code class="language-javascript">class Foo {
  constructor() {
    this.bar = 'baz';
  }
}
</code></pre>
<p>Property assignments like this are always done at the end of the constructor,
and given the requirement that <code>super</code> must always be called before properties
are assigned it is unlikely that this will change as the spec progresses.</p>
<p>While one might intuitively expect class properties to function the same in
ES Classes as they do with Ember Objects, this difference in behavior means that
class properties will always be assigned after properties passed into <code>create</code>
are initialized on the object, and thus will always win:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({ testProp: 'default value' });

class Bar extends Ember.Object {
  testProp = 'default value'
}

const foo = Foo.create({ testProp: 'new value' });
const bar = Bar.create({ testProp: 'new value' });

console.log(foo.get('testProp')); // 'new value'
console.log(bar.get('testProp')); // 'default value'
</code></pre>
<p>This behavior makes sense when you consider that it is equivalent to assigning
values in <code>init</code> rather than on the object when it is defined. Rather than modify
<code>Ember.Object</code> to treat class properties as default values, this RFC proposes that
we accept the difference in behavior and utilize the constructor to allow users
to set default values, as in the following example:</p>
<pre><code class="language-javascript">class Foo extends Ember.Object {
  constructor(props) {
    props.testProp = props.testProp || 'default value';

    super(props);
  }
}
</code></pre>
<p>This enforces a public API rather than allowing <code>create</code> to override values as
it pleases, and is more inline with the behavior of components in Glimmer today -
args that are passed into the class are distinguished from properties that are
defined on the class.</p>
<a class="header" href="print.html#mixins" id="mixins"><h2>Mixins</h2></a>
<p>Mixins are a contentious part of both the Ember Object model and the wider
Javascript community - some swear by the pattern, and others believe it fundamentally
flawed. While Ember mixins are at the core of Ember Object, the fact is that
no standard solution for them has arisen in the wider Javascript community as
of yet.</p>
<p>Additionally, while concepts like computed properties, actions, and
service injection are either unique to Ember or highly dependent on implementation,
mixins can be implemented in a generic way which could be used across all of
Javascript, independent of one's framework or library of choice. With that in
mind, this RFC considers mixins out of scope and suggests that in the future Ember
users can choose to use a mixin library if it suits their needs.</p>
<p>It should also be noted that existing classes which have used mixins can still be
extended using ES Class syntax:</p>
<pre><code class="language-javascript">const Mix = Ember.Mixin.create({ bar: 'baz' });
const Foo = Ember.Object.extend(Mix, { /* ... */ });

class Bar extends Foo { /* ... */ }

const bar = Bar.create();

console.log(bar.get('bar')); // 'baz'
</code></pre>
<a class="header" href="print.html#observers-and-events" id="observers-and-events"><h2>Observers and Events</h2></a>
<p>Observers and events both fail to work properly when using ES Class syntax. The root
of the issue here is how <code>Ember.Object</code> works at a fundamental level, and will require
some refactoring to fix.</p>
<p>Currently, each time <code>Ember.Object.extend</code> is used, it stores the list of mixins and
objects passed in on a list which also contains the superclass's properties and mixins,
and so on. A class is then returned which has access to a closure variable, <code>wasApplied</code>:</p>
<pre><code class="language-javascript">makeCtor = function() {
  wasApplied = false;

  return class {
    constructor() {
      if (!wasApplied) {
        this.proto();
      }
    }
  }
}
</code></pre>
<p>The <code>proto</code> function walks the chain of stored mixins, collapsing them into a single object
prototype the first time the class is created. It is during this walk that observers and
events listeners are applied and finalized, as well as merged and concatenated properties
applied (this will be touched on more in the next section).</p>
<p>Unfortunately, due to the nature of how observers and event listeners work, they cannot be
applied at class definition time without a class decorator. For example:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({
  fooObserver: Ember.observer('foo', function() { /* ... */m })
});

class Bar extends Foo {
  fooObserver() { /* ... */ }
}
</code></pre>
<p>When <code>proto</code> walks the mixin chain for Foo, it will add an observer that triggers the
<code>fooObserver</code> function whenever <code>foo</code> changes. Bar, however, overloads the <code>fooObserver</code>
function with a function that is <em>not</em> observed, and thus should not trigger (this is
analagous to how Ember Object's work today). Currently there is no time at which
Bar can inspect undecorated properties to determine if the superclass has already defined
them and if they are observed and thus should have the observer removed.</p>
<p>To fix this, the <code>wasApplied</code> state should be moved to the ember meta object on the
class itself, so that both Ember Objects and ES Classes can track if they have had it
applied. Additional logic will also need to be added to allow the current &quot;squashing&quot;
behavior of <code>proto</code> to work with Prototypes instead of a list of mixins as well.</p>
<a class="header" href="print.html#merged-and-concatenated-properties" id="merged-and-concatenated-properties"><h2>Merged and Concatenated Properties</h2></a>
<p>Ember Objects currently have the ability to define special properties which are
merged or concatenated with their superclass when extended. This is most commonly
seen with <code>actions</code> and <code>classNames</code> among others.</p>
<p>As mentioned in the last section, merged and concatenated properties are also
combined during the <code>proto</code> &quot;squash&quot; phase, and so it is also broken in ES Classes
currently. This RFC proposes that their behavior also be fixed as part of the refactors
to Ember.Object.</p>
<a class="header" href="print.html#how-we-teach-this-32" id="how-we-teach-this-32"><h1>How We Teach This</h1></a>
<p>The sole purpose of this RFC is to make the behavior of ES Classes within Ember a
public API so that projects like <code>ember-decorators</code> can continue to build and experiment
with confidence that the underlying behavior will not change. The Ember Object model
will remain exactly the same as today, and will continue to be the recommended path
for Ember users. Thus, we will not need to add new documentation for the time being.</p>
<a class="header" href="print.html#drawbacks-56" id="drawbacks-56"><h1>Drawbacks</h1></a>
<ul>
<li>Making <code>constructor</code> a public API means we are solidifying the lifecycle of
objects, locking us into a particular sequence of events (<code>init</code> occurs within
the <code>super()</code> portion of the constructor).</li>
<li>Lack of mixin support may make it difficult for mixin heavy codebases to utilize
ES Classes.</li>
<li>ES Class features/usage such as getters and setters may confuse users in general
(getter functions will <em>appear</em> to work, but without a <code>computed</code> decorator will
not update, etc.)</li>
</ul>
<a class="header" href="print.html#alternatives-56" id="alternatives-56"><h1>Alternatives</h1></a>
<ul>
<li>Class property initialization can be changed such that properties are initialized
after the constructor runs entirely, allowing them to be overwritten by values
passed to <code>create</code></li>
</ul>
<a class="header" href="print.html#topics-for-future-rfcs-1" id="topics-for-future-rfcs-1"><h1>Topics for Future RFCs</h1></a>
<p>While working on this RFC, some issues were brought into focus regarding existing
features in CoreObject that are seen as problematic or unintuitive. In order to
avoid bikeshedding these have been slated for discussion in future RFCs, but the
discussion points have been included below.</p>
<a class="header" href="print.html#merged-and-concatenated-properties-1" id="merged-and-concatenated-properties-1"><h2>Merged and Concatenated Properties</h2></a>
<p>Merged and concatenated properties are pain points for new Ember developers,
specifically because they give no lexical hint that they are special in any way.
Developers must know that these particular properties will be merged with the
superclass, and there is no way to opt out of this behavior.</p>
<p>With decorators, this same behavior can be accomplished in a much clearer and
more straightforward way:</p>
<pre><code class="language-javascript">class FooComponent extends Ember.Component {
  @concatenated classNameBindings = ['foo']

  @computed
  get foo() { /* ... */ }

  @merged actions = {
    bar() { /* ... */ }
  }
}
</code></pre>
<p>They could also be accomplished more ergonomically with specialized decorators:</p>
<pre><code class="language-javascript">class FooComponent extends Ember.Component {
  @className
  @computed
  get foo() { /* ... */ }

  @action
  bar() { /* ... */ }
}
</code></pre>
<p>This approach has two distinct advantages over the existing behavior:</p>
<ol>
<li>It is less magical. The decorators indicate to new users that the properties are
special in some way, and ultimately they are just plain decorators, which are
compatible with ES Classes as a whole and can be reused anywhere.</li>
<li>It provides a way to opt out of the behavior. Currently, there is no easy
way to prevent properties which were marked to be merged from being merged,
meaning subclasses are stuck with the values that their superclass provided.</li>
</ol>
<a class="header" href="print.html#observers-and-listeners" id="observers-and-listeners"><h2>Observers and Listeners</h2></a>
<p>Observers and event listeners are a powerful pattern that saw a lot of usage in Ember 1.
However, it is now widely accepted that they are problematic when overused, and using
computed properties and lifecycle hooks are better patterns in most cases.</p>
<p>As such, rather than having events and observers turned on by default it may make
more sense to have them be opt-in APIs. This could be accomplished by making new
class decorators like so:</p>
<pre><code class="language-javascript">@evented
class Foo extends Ember.Object {
  @on('init')
  onInit() {
    // do something
  }
}
</code></pre>
<p>Or it could be accomplished with new base classes that include the functionality:</p>
<pre><code class="language-javascript">class Foo extends EventedObject {
  @on('init')
  onInit() {
    // do something
  }
}
</code></pre>
<a class="header" href="print.html#unresolved-questions-45" id="unresolved-questions-45"><h1>Unresolved questions</h1></a>
<p>None currently</p>
<a class="header" href="print.html#browser-support-changes" id="browser-support-changes"><h1>Browser Support Changes</h1></a>
<ul>
<li>Start Date: 2017-09-25</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-58" id="summary-58"><h1>Summary</h1></a>
<p>Solicit feedback on dropping support for IE9, IE10, and PhantomJS.</p>
<a class="header" href="print.html#motivation-59" id="motivation-59"><h1>Motivation</h1></a>
<p>As Ember heads towards version 3.0, it is a good time to evaluate our browser support matrix. Ember follows Semantic Versioning, and we consider browser compatibility to be under the umbrella of those guarantees. In other words, we will continue to support whatever browsers we officially support in Ember 3.0 until Ember 4.0.</p>
<p>We want to make this decision on the basis of the browsers that our community still needs to support, while weighing that against the costs we bear as a community to support older browsers. This RFC will lay out some of those costs, so we can decide what tradeoff is most appropriate.
Members of the core team maintain many different kinds of apps across many different kinds of companies. Some of us work on applications with small, agile teams, while others work inside of large corporations with many engineers. When this topic came up amongst the team, we discovered that, across all these different companies and Ember apps, we did not generally support IE9, IE10, and PhantomJS.</p>
<p>Because of this, the core team's impression is that the costs support now far exceed the benefits, and we are considering dropping support for them in Ember 3.0. Before we make the decision, we want to hear from the rest of the community. Supporting IE9, IE10, and PhantomJS incurs significant cost, both in terms of features and maintenance, and we want the community to help us think through the cost-benefit analysis.</p>
<p>Ember is more than just the framework's code. When people use Ember, they expect to be able to use Ember's tooling, read Ember's documentation, find solutions to problems on Stack Overflow, and read tutorials produced by community members. <strong>All of these, including addons that follow Ember’s lead, are shackled to the limitations of these legacy browsers.</strong> By dropping support for them, people can begin to rely on the improved baseline of features.</p>
<p>Some of the features (unavailable in IE9, IE10, or PhantomJS) that addons will be able to freely take advantage of include:</p>
<ul>
<li>requestAnimationFrame (<a href="http://caniuse.com/#feat=requestanimationframe">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">MDN</a>)</li>
<li>CSS flexbox (<a href="http://caniuse.com/#search=flexbox">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes">MDN</a>)</li>
<li>Websockets (<a href="http://caniuse.com/#feat=websockets">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">MDN</a>)</li>
<li>let (<a href="http://caniuse.com/#feat=let">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">MDN</a>)</li>
<li>const (<a href="http://caniuse.com/#feat=const">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">MDN</a>)</li>
<li>TypedArray (<a href="http://caniuse.com/#feat=typedarrays">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">MDN</a>)</li>
<li>Geolocation API (<a href="https://caniuse.com/#search=Geolocation">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation">MDN</a>)</li>
<li>Online/offline API (<a href="http://caniuse.com/#feat=online-status">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Online_and_offline_events">MDN</a>)</li>
<li>XHR advanced features (<a href="https://caniuse.com/#feat=xhr2">caniuse</a>, <a href="https://www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/">specification</a>)</li>
<li>HTTP2 (<a href="http://caniuse.com/#feat=http2">caniuse</a>, <a href="https://en.wikipedia.org/wiki/HTTP/2">wikipedia</a>)</li>
<li>Web Workers (<a href="http://caniuse.com/#feat=webworkers">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">MDN</a>)</li>
<li>IndexedDB (<a href="http://caniuse.com/#feat=indexeddb">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">MDN</a>)</li>
<li>WebGL (<a href="http://caniuse.com/#feat=webgl">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">MDN</a>)</li>
<li>File API (<a href="http://caniuse.com/#feat=fileapi">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/File">MDN</a>)</li>
<li>PageTransitionEvent (<a href="http://caniuse.com/#feat=page-transition-events">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/PageTransitionEvent">MDN</a>)</li>
<li>SVG filters (<a href="http://caniuse.com/#feat=svg-filters">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/SVG_Filters_Tutorial">MDN</a>)</li>
<li>MutationObserver (<a href="http://caniuse.com/#feat=mutationobserver">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MDN</a>)</li>
</ul>
<p>Below, we’ve outlined several specific features we’re interested in using to improve the Ember framework itself. We’ve also included some other supporting arguments for this decision.</p>
<a class="header" href="print.html#vendor-support" id="vendor-support"><h2>Vendor Support</h2></a>
<p>Microsoft dropped most support and maintenance for IE9 and IE10 on 2016-01-16 (IE9 on Vista SP2 <a href="http://www.allyncs.com/docs/lifecyclesupport.html">expired in April 2017</a>).</p>
<p>With the advent of headless Chrome and Firefox, PhantomJS is now <a href="https://groups.google.com/forum/#!topic/phantomjs/9aI5d-LDuNE">effectively unmaintained</a>. The default testing boilerplate for Ember CLI-generated applications was changed to headless Chrome in Ember CLI 2.15.</p>
<a class="header" href="print.html#weakmap-map-set" id="weakmap-map-set"><h2>WeakMap, Map, Set</h2></a>
<p>From a framework perspective, being able to rely on native <code>WeakMap</code> support will allow us to remove a significant number of fallback paths that are used in browsers without <code>WeakMap</code>. Using <code>WeakMap</code> results in better developer ergonomics as it allows us to remove many of the random properties that we currently have to assign to an object which makes interacting with your objects in the devtools much less noisy. Minimal support for WeakMap was <a href="http://kangax.github.io/compat-table/es6/#test-WeakMap">introduced in IE11</a>.</p>
<a class="header" href="print.html#better-es-class-support" id="better-es-class-support"><h2>Better ES Class Support</h2></a>
<p>In order to support static class methods (with inheritance) transpilers (e.g. Babel) need to leverage the <code>Object.setPrototypeOf</code> / <code>Object.getPrototypeOf</code> APIs. Without the ability to rely on <code>Object.setPrototypeOf</code> we will not be able to continue iterating slowly towards leveraging ES classes as a replacement for the custom object model functionality that we have known and loved for so many years. Specifically, there is no replacement / capability to support proper inheritance with <code>.reopenClass</code>. There are several lower-fidelity hacks you might opt into, but none that we think satisfy the needs of the Ember community.</p>
<p>Generally this means IE11 is the oldest browser we can reliably transpile ES classes for reliably.</p>
<a class="header" href="print.html#typed-arrays" id="typed-arrays"><h2>Typed Arrays</h2></a>
<p>Typed arrays are not currently used in Ember, but experimentation is underway deep in the internals of Glimmer VM to be able to further reduce template size <em>and</em> the costs associated with expanding the wire format (currently a JSON structure) into a runnable program. Leveraging typed arrays would allow Ember and Glimmer apps to completely avoid the wire format to opcode compilation that currently happens before initial render. It also significantly reduces the resulting memory footprint for the same runnable program.</p>
<a class="header" href="print.html#dom-api-improvements" id="dom-api-improvements"><h2>DOM API Improvements</h2></a>
<p>Although IE9 introduced JavaScript engine with support for much of ES5, it was not until IE10 that the browser began to support much of what developers consider modern web platform APIs. Littered throughout the Ember and Glimmer VM codebase are <a href="https://github.com/glimmerjs/glimmer-vm/blob/1759c16defc546b034b97e37141187652ed93859/packages/%40glimmer/runtime/lib/dom/props.ts#L54">many</a> <a href="https://github.com/glimmerjs/glimmer-vm/blob/9ecc88504c81469ba20dba3ed3f37d373a998355/packages/%40glimmer/test-helpers/lib/helpers.ts#L170">examples</a> <a href="https://github.com/glimmerjs/glimmer-vm/blob/bfed16af6a5ecce4fbe9f27783245fe0f8b03480/build/broccoli/transpile-to-es5.js#L25">of</a> IE9 workarounds (and <a href="https://github.com/glimmerjs/glimmer-vm/blob/1759c16defc546b034b97e37141187652ed93859/packages/%40glimmer/runtime/lib/dom/props.ts#L49">PhantomJS workarounds</a>, in fact). We’ve worked hard to make these fixes free at runtime for modern browsers, but some cost is unavoidable.</p>
<p>PhantomJS in particular is a weird environment. Users must often fix Phantom-specific browser bugs, which is wasted effort since real users never run your app in Phantom. And &quot;how to debug in Phantom&quot; is an entire extra skill people are forced to learn. Testing your app in PhantomJS is generally a form of “testing theater”, since it fails to execute your code in a realistic environment.</p>
<a class="header" href="print.html#requestanimationframe" id="requestanimationframe"><h2><code>requestAnimationFrame</code></h2></a>
<p>IE10 introduced support for <code>requestAnimationFrame</code>, an efficient way to schedule work in the browser environment. We’re interested in using this API to explore incremental rendering strategies, and as a way to improve Ember’s coordination with the browser when native promises are used in application code.</p>
<a class="header" href="print.html#detailed-design-53" id="detailed-design-53"><h1>Detailed Design</h1></a>
<p>When using Ember applications in IE9, IE10, or PhantomJS, Ember will cause an appropriate deprecation to be issued. The deprecation will be “until 3.0” and will reference an entry in the deprecation guide. The guide entry will describe For example:</p>
<blockquote>
<p>Using Ember.js in IE9, IE10, or PhantomJS is deprecated and will be unsupported in Ember.js 3.0. We recommend using Ember’s 2.x LTS releases if your applications must support those browsers.</p>
<p>PhantomJS is often used for continuous integration testing. We strongly suggest adopting headless Chrome or Firefox to run CI tests.</p>
</blockquote>
<a class="header" href="print.html#drawbacks-57" id="drawbacks-57"><h1>Drawbacks</h1></a>
<p>Many users have told us that they chose Ember because of the community's commitment to backwards compatibility. There will always be organizations using Ember that exist on the tail-end of browser adoption patterns. We risk alienating or upsetting those users by dropping support for a browser that, while on the way out, is not yet completely gone.</p>
<p>However, in many cases, the requirement for supporting these legacy browsers is driven by non-technical management who do not have a strong sense of the experience of using apps in IE9/IE10. In practice, many applications are not rigorously tested in older browsers, and the performance is so bad that applications written using any framework perform poorly. Techniques that framework and application developers use to make Chrome fast quite often have pathological characteristics on browsers with legacy DOM and JavaScript engines.</p>
<p>Still, some people make it work, and dropping support may prevent those teams from staying with the community as it migrates to Ember 3.0.</p>
<p>As a mitigation for these concerns, the final release of Ember 2.x will itself be made an LTS release. This will ensure a 2.x platform supporting IE9+ with critical bugfix for roughly 8 months following the 3.0 release and security fixes for roughly 14 months after 3.0 release.</p>
<a class="header" href="print.html#alternatives-57" id="alternatives-57"><h1>Alternatives</h1></a>
<a class="header" href="print.html#bring-your-own-compatibility-1" id="bring-your-own-compatibility-1"><h2>Bring Your Own Compatibility</h2></a>
<p>Some libraries attempt to thread the needle of compatibility by asking users to bring their own compatibility libraries. They write the internals of their framework as if these older browsers did not exist, and require end users to use polyfills to make the environment look equivalent to newer browsers.</p>
<p>We have spent considerable effort on first-class support in Ember 2.x, and we feel that users who require IE9 and IE10 support will have a better experience using Ember 2.x. (with the subset of the ecosystem that supports 2.x) than trying to cobble together a solution that works reliably in a version of Ember with second-class, bring-your-own-compatibility support.</p>
<ul>
<li>Start Date: 2017-11-05</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/268">emberjs/rfcs#268</a></li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-59" id="summary-59"><h1>Summary</h1></a>
<p>The testing story in Ember today is better than it ever has been. It is now
possible to test individual component/template combos, register your own mock
components/services/etc, build complex acceptance tests, and almost anything else
you would like.</p>
<p>Unfortunately, there is a massive disparity between different types of tests.
In acceptance tests, you use well designed global helpers to deal with async
related interactions; whereas in integration and unit tests you are forced to
manually deal with this asynchrony.
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
introduced us to QUnit's nested modules API, made integration and unit testing
modular, and greatly simplified the concepts needed to learn how to write unit
and integration tests. The goal of this RFC is to leverage what we have learned
in prior RFCs and apply that knowledge to acceptance testing. Once this RFC has
been implemented all test types in Ember will have a unified cohesive structure.</p>
<a class="header" href="print.html#motivation-60" id="motivation-60"><h1>Motivation</h1></a>
<p>Usage of rendering tests is becoming more and more common, but these tests
often include manual event delegation (<code>this.$('.foo').click()</code> for
example), and assumes most (if not all) interactions are synchronous.  This is
a major issue due to the fact that the vast majority of interactions will
actually be asynchronous. There have been a few recent additions to
<code>@ember/test-helpers</code> that have made dealing with asynchrony better (namely
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>)
but forcing users to manually manage all interaction based async is a recipe
for disaster.</p>
<p>Acceptance tests allow users to handle asynchrony with ease, but they rely on
global helpers that automatically wrap a single global promise which makes
testing of interleaved asynchronous things more difficult. There are a number
of limitations in acceptance tests as compared to integration tests (cannot
mock and/or stub services, cannot look up services to setup test context, etc).</p>
<p>We need a single unified way to teach and understand testing in Ember that
leverages all the things we learned with the original acceptance testing
helpers that were introduced in Ember 1.0.0.  Instead of inventing our own
syntax for dealing with the async (<code>andThen</code>) we should use new language
features such as <code>async</code> / <code>await</code>.</p>
<a class="header" href="print.html#detailed-design-54" id="detailed-design-54"><h1>Detailed design</h1></a>
<p>The goal of this RFC is to introduce new system for acceptance tests that follows in the footsteps of
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
and continues to enhance the system created in that RFC to share the same structure and helper system.</p>
<p>This new system for acceptance tests will be implemented in the
<a href="https://github.com/emberjs/ember-test-helpers/">@ember/test-helpers</a> library so
that we can iterate faster while supporting multiple Ember versions
independently and easily support multiple testing frameworks build on top of
the primitives in <code>@ember/test-helpers</code>. Ultimately, the existing <a href="https://github.com/emberjs/ember.js/tree/master/packages/ember-testing">ember-testing</a> system
will be deprecated but that deprecation will be added well after the new system has been
released and adopted by the community.</p>
<p>Lets take a look at a basic example (lifted from <a href="https://guides.emberjs.com/v2.16.0/testing/acceptance/">the guides</a>):</p>
<pre><code class="language-js">// **** before ****
import { test } from 'qunit';
import moduleForAcceptance from '../helpers/module-for-acceptance';

moduleForAcceptance('Acceptance | posts');

test('should add new post', function(assert) {
  visit('/posts/new');
  fillIn('input.title', 'My new post');
  click('button.submit');
  andThen(() =&gt; assert.equal(find('ul.posts li:first').text(), 'My new post'));
});

// **** after ****
import { module, test } from 'qunit';
import { setupApplicationTest } from 'ember-qunit';
import { visit, fillIn, click } from '@ember/test-helpers';

module('Acceptance | login', function(hooks) {
  setupApplicationTest(hooks);

  test('should add new post', async function(assert) {
    await visit('/posts/new');
    await fillIn('input.title', 'My new post');
    await click('button.submit');

    assert.equal(this.element.querySelectorAll('ul.posts li')[0].textContent, 'My new post');
  });
});
</code></pre>
<p>As you can see, this proposal unifies on Qunit's nested module syntax following
in emberjs/rfcs#232's footsteps.</p>
<a class="header" href="print.html#new-apis-proposed" id="new-apis-proposed"><h2>New APIs Proposed</h2></a>
<p>The following new methods will be exposed from <code>ember-qunit</code>:</p>
<pre><code class="language-ts">declare module 'ember-qunit' {
  // ...snip... 
  export function setupApplicationTest(hooks: QUnitModuleHooks): void;
}
</code></pre>
<a class="header" href="print.html#dom-interaction-helpers" id="dom-interaction-helpers"><h3>DOM Interaction Helpers</h3></a>
<p>New native DOM interaction helpers will be added to both <code>setupRenderingTest</code>
and (proposed below) <code>setupApplicationTest</code>. The implementation for these
helpers has been iterated on and is quite stable in the
<a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>
addon.</p>
<p>The helpers will be migrated to <code>@ember/test-helpers</code> and eventually
(once &quot;the dust settles&quot;) <code>ember-native-dom-helpers</code> will be able to reexport
the versions from <code>@ember/test-helpers</code> directly (which means apps that have
already adopted will have very minimal changes to make).</p>
<p>The specific DOM helpers to be added to the <code>@ember/test-helpers</code> module are:</p>
<pre><code class="language-ts">/**
  Clicks on the specified selector.
*/
export function click(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Taps on the specified selector.
*/
export function tap(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Triggers a keyboad event on the specified selector.
*/
export function triggerKeyEvent(
  selector: string | HTMLElement,
  eventType: 'keydown' | 'keypress' | 'keyup',
  keyCode: string,
  modifiers?: {
    ctrlKey: false,
    altKey: false,
    shiftKey: false,
    metaKey: false
  }
): Promise&lt;void&gt;;

/**
  Triggers an event on the specified selector.
*/
export function triggerEvent(
  selector: string | HTMLElement,
  eventType: string,
  eventOptions: any
): Promise&lt;void&gt;;

/**
  Fill in the specified selector's `value` property with the provided text.
*/
export function fillIn(selector: string | HTMLElement, text: string): Promise&lt;void&gt;;

/**
  Focus the specified selector.
*/
export function focus(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Unfocus the specified selector.
*/
export function blur(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Returns a promise which resolves when the provided callback returns a truthy value.
*/
export function waitUntil&lt;T&gt;(Function: Promise&lt;T&gt;, { timeout = 1000 }): Promise&lt;T&gt;;

/**
  Returns a promise which resolves when the provided selector (and count) becomes present.
*/
export function waitFor(selector: string, { count?: number, timeout = 1000 }): Promise&lt;HTMLElement | HTMLElement[]&gt;;
</code></pre>
<a class="header" href="print.html#setupapplicationtest" id="setupapplicationtest"><h3><code>setupApplicationTest</code></h3></a>
<p>This function will:</p>
<ul>
<li>invoke <code>ember-test-helper</code>s <code>setupContext</code> with the tests context (which does the following):
<ul>
<li>create an owner object and set it on the test context (e.g. <code>this.owner</code>)</li>
<li>setup <code>this.pauseTest</code> and <code>this.resumeTest</code> methods to allow easy pausing/resuming
of tests</li>
</ul>
</li>
<li>add routing related helpers
<ul>
<li>setup importable <code>visit</code> method to visit the given url</li>
<li>setup importable <code>currentRouteName</code> method which returns the current route name</li>
<li>setup importable <code>currentURL</code> method which returns the current URL</li>
</ul>
</li>
<li>add DOM interaction helpers (heavily influenced by @cibernox's lovely addon <a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>)
<ul>
<li>setup a getter for <code>this.element</code> which returns the DOM element representing
the applications root element</li>
<li>setup importable <code>click</code> helper method</li>
<li>setup importable <code>tap</code> helper method</li>
<li>setup importable <code>triggerKeyEvent</code> helper method</li>
<li>setup importable <code>triggerEvent</code> helper method</li>
<li>setup importable <code>fillIn</code> helper method</li>
<li>setup importable <code>focus</code> helper method</li>
<li>setup importable <code>blur</code> helper method</li>
<li>setup importable <code>waitUntil</code> helper method</li>
<li>setup importable <code>waitFor</code> helper method</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#setuprenderingtest-1" id="setuprenderingtest-1"><h3><code>setupRenderingTest</code></h3></a>
<p>The <code>setupRenderingTest</code> function proposed in
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
(and implemented in
<a href="https://github.com/emberjs/ember-qunit">ember-qunit</a>@3.0.0) will be modified to add the same DOM interaction helpers mentioned above:</p>
<ul>
<li>setup importable <code>click</code> helper method</li>
<li>setup importable <code>tap</code> helper method</li>
<li>setup importable <code>triggerKeyEvent</code> helper method</li>
<li>setup importable <code>triggerEvent</code> helper method</li>
<li>setup importable <code>fillIn</code> helper method</li>
<li>setup importable <code>focus</code> helper method</li>
<li>setup importable <code>blur</code> helper method</li>
<li>setup importable <code>waitUntil</code> helper method</li>
<li>setup importable <code>waitFor</code> helper method</li>
</ul>
<p>Once implemented, <code>setupRenderingTest</code> and <code>setupApplicationTest</code> will diverge from each other in very few ways.</p>
<a class="header" href="print.html#changes-from-current-system-1" id="changes-from-current-system-1"><h2>Changes from Current System</h2></a>
<p>Here is a brief list of the more important but possibly understated changes
being proposed here:</p>
<ul>
<li>The global test helpers that exist now, will no longer be present (e.g.
<code>click</code>, <code>visit</code>, etc) and instead will be available on the test context as
well as importable helpers.</li>
<li><code>this.owner</code> will now be present and allow (for the first time 🎉) overriding
items in the container/registry.</li>
<li>The new system will leverage the <code>Ember.Application</code> /
<code>Ember.ApplicationInstance</code> split so that we can avoid creating an
<code>Ember.Application</code> instance per-test, and instead leverage the same system
that FastBoot itself uses to avoid running initializers for each acceptance
test.</li>
<li>Implicit promise chaining will no longer be present. If your test needs to
wait for a given promise, it should use <code>await</code> (which will wait for the
system to &quot;settle&quot; in similar semantics to today's <code>wait()</code> helper).</li>
<li>The test helpers that are included by a new default ember-cli app will be no
longer needed and will be removed from the new application blueprint. This
includes:
<ul>
<li><code>tests/helpers/resolver.js</code></li>
<li><code>tests/helpers/start-app.js</code></li>
<li><code>tests/helpers/destroy-app.js</code></li>
<li><code>tests/helpers/module-for-acceptance.js</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#examples-5" id="examples-5"><h2>Examples</h2></a>
<a class="header" href="print.html#test-helper" id="test-helper"><h3>Test Helper</h3></a>
<p>Assuming the following input:</p>
<pre><code class="language-js">import Ember from 'ember';

export function withFeature(app, featureName) {
  let featuresService = app.__container__.lookup('service:features');
  featuresService.enable(featureName);
}

Ember.Test.registerHelper('withFeature', withFeature);
</code></pre>
<p>In order for an addon to support both the existing acceptance testing system, and the new system it could replace that helper with the following:</p>
<pre><code class="language-js">import { registerAsyncHelper } from '@ember/test';

export function enableFeature(owner, featureName) {
  let featuresService = owner.lookup('service:features');
  featuresService.enable(featureName);
}

registerAsyncHelper('withFeature', function(app, featureName) {
  enableFeature(app.__container__, featureName);
});
</code></pre>
<p>This allows both the prior API (without modification) and the following:</p>
<pre><code class="language-js">// Option 2:
import { module, test } from 'qunit';
import { setupApplicationTest } from 'ember-qunit';
import { enableFeature } from 'addon-name-here/test-support';

module('asdf', function(hooks) {
  setupApplicationTest(hooks);

  test('awesome test title here', function(assert) {
    enableFeature(this.owner, 'feature-name-here');

    // ...snip...
  });
});
</code></pre>
<a class="header" href="print.html#registering-factory-overrides" id="registering-factory-overrides"><h3>Registering Factory Overrides</h3></a>
<p>Overriding a factory is generally done to allow the test to have more control
over the thing being tested. This is sometimes used to prevent side effects
that are not related to the test (i.e. to prevent network calls), other times
it is used to allow the test to inject some known state to make asserting the
results much easier.</p>
<p>It is currently possible to register custom factories in integration and unit
tests, but not in acceptance tests (without using private API's that is).</p>
<p>As of <a href="https://github.com/emberjs/rfcs/pull/232">emberjs/rfcs#232</a> the
integration/unit test API for this registration is:</p>
<pre><code class="language-js">this.owner.register('service:stripe', MockService);
</code></pre>
<p>This RFC will allow this invocation syntax to work in all test types
(acceptance, integration, and unit).</p>
<a class="header" href="print.html#migration-2" id="migration-2"><h2>Migration</h2></a>
<p>It is important that both the existing acceptance testing system, and the
newly proposed system can co-exist together. This means that new tests can be generated
in the new style while existing tests remain untouched.</p>
<p>However, it is likely that
<a href="https://github.com/rwjblue/ember-qunit-codemod">ember-qunit-codemod</a> will be
able to accurately rewrite acceptance tests into the new format.</p>
<a class="header" href="print.html#how-we-teach-this-33" id="how-we-teach-this-33"><h1>How We Teach This</h1></a>
<p>This change requires updates to the API documentation of <code>ember-qunit</code> and the
main Ember guides' testing section. The changes are largely intended to reduce
confusion, making it easier to teach and understand testing in Ember.</p>
<a class="header" href="print.html#drawbacks-58" id="drawbacks-58"><h1>Drawbacks</h1></a>
<ul>
<li>This is a relatively large set of changes that are arguably not needed (things mostly work today).</li>
<li>One of the major hurdles in upgrading larger applications to newer Ember versions, is updating their tests to follow &quot;new&quot; patterns.  This RFC introduces yet another &quot;new&quot; thing (and proposes to deprecate the old thing), and could therefore be considered &quot;just more churn&quot;.</li>
</ul>
<a class="header" href="print.html#alternatives-58" id="alternatives-58"><h1>Alternatives</h1></a>
<ul>
<li>Do nothing?</li>
<li>Make <code>ember-native-dom-helpers</code> a default addon (removing the need for DOM interaction helpers proposed here).</li>
</ul>
<ul>
<li>Start Date: 2017-11-20</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/272</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#deprecate-functionprototypeon-functionprototypeobserves-and-functionprototypeproperty" id="deprecate-functionprototypeon-functionprototypeobserves-and-functionprototypeproperty"><h1>Deprecate Function.prototype.on, Function.prototype.observes and Function.prototype.property</h1></a>
<a class="header" href="print.html#summary-60" id="summary-60"><h2>Summary</h2></a>
<p>This RFC proposes to deprecate <code>Function.prototype.on</code>,
<code>Function.prototype.observes</code> and <code>Function.prototype.property</code></p>
<a class="header" href="print.html#motivation-61" id="motivation-61"><h2>Motivation</h2></a>
<p>Ember has been moving away from extending native prototypes due to the confusion
that this causes users: is it specifically part of Ember, or JavaScript?</p>
<p>Continuing in that direction, we should consider recommending the usage of
<a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject%2Fevented/methods/on?anchor=on"><code>on</code> (<code>@ember/object/evented</code>)</a>, <a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject/methods/observer?anchor=observer"><code>observer</code> (<code>@ember/object</code>)</a> and <a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject/methods/computed?anchor=computed"><code>computed</code> (<code>@ember/object</code>)</a> as opposed to their native
prototype extension equivalents.
We go from two ways to do something, to one.</p>
<p><a href="https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-function-prototype-extensions.md"><code>eslint-plugin-ember</code> already provides this as a rule</a>.</p>
<a class="header" href="print.html#transition-path-6" id="transition-path-6"><h2>Transition Path</h2></a>
<p>The replacement functionality already exists in the form of <code>on</code>, <code>observer</code>, and <code>computed</code>.</p>
<p>We don't need to build anything new specifically, however, the bulk of the transition will be
focused on deprecating the native prototype extensions.</p>
<p>A codemod for this deprecation has to take into consideration that while <code>foo: function() { /* custom logic */ }.property('bar')</code> is a <code>Function.prototype</code> extension, <code>foo: observer(function () { /* some custom logic */ }).on('customEvent')</code> is not.</p>
<a class="header" href="print.html#how-we-teach-this-34" id="how-we-teach-this-34"><h2>How We Teach This</h2></a>
<p>On the deprecation guide, we can showcase the same example as above. We can explain why
the proposal was necessary, followed by a set of examples highlighting the deprecated
vs current style.</p>
<p>Borrowing from the <a href="https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-function-prototype-extensions.md">ESLint plugin example</a>:</p>
<pre><code class="language-js">import { computed, observer } from '@ember/object';
import { on } from '@ember/object/evented';

export default Component.extend({
  // deprecated
  abc: function() { /* custom logic */ }.property('xyz'),
  def: function() { /* custom logic */ }.observe('xyz'),
  ghi: function() { /* custom logic */ }.on('didInsertElement'),
  jkl: function() { /* custom logic */ }.on('customEvent'),

  // current
  abc: computed('xyz', function() { /* custom logic */ }),
  def: observer('xyz', function() { /* custom logic */ }),
  didInsertElement() { /* custom logic */ }),
  jkl: on('customEvent', function() { /* custom logic */ }),
});
</code></pre>
<p>The official Guides currently <a href="https://guides.emberjs.com/v2.17.0/configuring-ember/disabling-prototype-extensions/">discourage the use of <code>Function.prototype</code> extensions</a>:</p>
<blockquote>
<p>Function is extended with methods to annotate functions as computed properties,
via the property() method, and as observers, via the observes() method. Use of
these methods is now discouraged and not covered in recent versions of the Guides.</p>
</blockquote>
<p>After the deprecated code is removed from Ember, we need to remove the section
about <code>Function</code> prototypes altogether.</p>
<a class="header" href="print.html#alternatives-59" id="alternatives-59"><h2>Alternatives</h2></a>
<p>None.</p>
<ul>
<li>Start Date: 2017-12-10</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/276</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/15968</li>
</ul>
<a class="header" href="print.html#summary-61" id="summary-61"><h1>Summary</h1></a>
<p>Introduce <code>{{@foo}}</code> in as a dedicated syntax for a component's template to
refer to named arguments passed in by the caller.</p>
<p>For example, given the invocation <code>{{hello-world name=&quot;Godfrey&quot;}}</code> and this
component template in <code>app/templates/components/hello-world.hbs</code>:</p>
<pre><code class="language-hbs">Hello, {{@name}}
</code></pre>
<p>Ember will render &quot;Hello, Godfrey&quot;.</p>
<a class="header" href="print.html#motivation-62" id="motivation-62"><h1>Motivation</h1></a>
<p>Currently, the way to access named arguments passed in from the caller is to
reference <code>{{name}}</code> in the template. This works because when Ember creates
the component instance, it automatically <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">assigns</a>
all named arguments as properties on the component instance.</p>
<p>The first problem with this approach is that the <code>{{name}}</code> syntax is highly
ambigious, as it could be referring to a local variable (block param), a
helper or a named argument from the caller (which actually works by accessing
auto-reflected <code>{{this.name}}</code>) or a property on the component class (such as
a computed property).</p>
<p>This can often lead to confusion for readers of the template. Upon encountering
<code>{{foo}}</code> in a component's template, the reader has to check all of
these places: first you need to scan the surrounding lines for block
params with that name; next you check in the helpers folder to see if there
is a helper with that name (it could also be coming from an addon!); then you
check if it is an argument provided by the caller; finally, you check the
component's JavaScript class to look for a (computed) property. If you <em>still</em>
did not find it, maybe it is a named arguments that is passed only sometimes,
or perhaps it is just a leftover reference from a previous refactor?</p>
<p>Providing a dedicated syntax for referring to named arguments will resolve the
ambiguity and greatly improve clarity, especially in big projects with a lot
of files (and uses a lot of addons). (The existing <code>{{this.name}}</code> syntax can
already be used to disambiguate component properties from helpers.)</p>
<p>As an aside, the ambiguity that causes confusion for human readers is also a
problem for the compiler. While it is not the main goal of this proposal,
resolving this ambiguity also helps the rendering system. Currently, the
&quot;runtime&quot; template compiler has to perform a helper lookup for every <code>{{name}}</code>
in each template. It will be able to skip this resolution process and perform
other optimizations (such as reusing the internal <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>
object and caches) with this addition.</p>
<p>Another problem with the current approach of automatically &quot;reflecting&quot; named
arguments on the instance is that they can unexpectedly overwrite other
properties defined on the component's class. It also defeats performance
optimizations in JavaScript engines as this approach creates many different
polymorphic &quot;shapes&quot; for instances that otherwise belong to the same
component class.</p>
<p>While this proposal does not directly solve this problem (we are not proposing
that we deprecate or remove the &quot;auto-reflection&quot; on <code>Ember.Component</code>), it
paves the way for a future world where components can work without them.</p>
<p>Notably, the current iteration of the <a href="https://glimmerjs.com/guides/templates-and-helpers">Glimmer Components</a>
have adopted this design for over a year now and the experience has been very
positive. This would be one of the first pieces (admittedly, only a tiny piece)
of the Glimmer.js experiment to make its way into Ember. We think this feature
is small, self-contained but useful enough to be the ideal candidate to kick
off this process.</p>
<a class="header" href="print.html#detailed-design-55" id="detailed-design-55"><h1>Detailed design</h1></a>
<p>This feature was baked into the Glimmer VM very early on. In fact, the
only thing that is stopping them from working in Ember is <a href="https://github.com/emberjs/ember.js/blob/87be17d8e69f83b2abed8c0695f8fa5e4bcae473/packages/ember-template-compiler/lib/plugins/assert-reserved-named-arguments.js">an AST transform</a>
that specifically disallows them. Therefore, &quot;implementing&quot; this feature is
just a matter of deleting that file.</p>
<p>Additionally, the legacy <code>{{attrs.foo}}</code> syntax (which more or less tries to
accomplish the same thing) has actually been <a href="https://github.com/emberjs/ember.js/blob/87be17d8e69f83b2abed8c0695f8fa5e4bcae473/packages/ember-template-compiler/lib/plugins/transform-attrs-into-args.js">implemented using <code>{{@foo}}</code></a>
under-the-hood since Ember 2.10.</p>
<a class="header" href="print.html#reserved-names" id="reserved-names"><h2>Reserved Names</h2></a>
<p>We will reserve <code>{{@args}}</code>, <code>{{@arguments}}</code> and anything that does not
start with a lowercase letter (such as <code>@Foo</code>, <code>@0</code>, <code>@!</code> etc) in the first
version. This is purely speculative and the goal is to carve out some space
for future features. If we don't end up needing them, we can always relax
the restrictions down the road.</p>
<a class="header" href="print.html#how-we-teach-this-35" id="how-we-teach-this-35"><h1>How We Teach This</h1></a>
<p><code>{{@foo}}</code> is the way to access the named arguments passed from the caller.</p>
<p>Since the <code>{{foo}}</code> syntax still works on <code>Ember.Component</code> (which is the
only kind of components available today) via the auto-reflection mechanism,
we are not really in a rush to migrate the community (and the guides, etc)
to using the new syntax. In the meantime, this could be viewed as a tool to
improve clarity in templates, similar to how the optional &quot;explicit <code>this</code>&quot;
syntax (<code>{{this.foo}}</code>).</p>
<p>While we think writing <code>{{@foo}}</code> would be a best practice for new code
going forward, the community can migrate at its own pace one component at a
time.</p>
<p>We can also encourage the community to supplement this effort by wiring
linting tools and code mods.</p>
<a class="header" href="print.html#drawbacks-59" id="drawbacks-59"><h1>Drawbacks</h1></a>
<p>This introduces a new piece of syntax that one would need to learn in order to
understand Ember templates.</p>
<p>This mostly affects &quot;casual&quot; readers (as this should be very easy for an Ember
developer to learn, understand and remember after encounting/learning it for
the first time). However, since these casual readers are also among those
who are most acutely affected by the ambiguity, we believe this is still a
net improvement over the status-quo.</p>
<a class="header" href="print.html#alternatives-60" id="alternatives-60"><h1>Alternatives</h1></a>
<p>We have <code>{{attrs.foo}}</code> today. In React, there is <code>this.props.foo</code>.</p>
<p>Given how common this is, we think it deserves its own dedicated, succinct
syntax. The other alternatives that involve reflecting them on the component
instances also would not allow for the internal optimizations in the Glimmer
VM.</p>
<ul>
<li>Start Date: 2017-12-11</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/278</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/15974</li>
</ul>
<a class="header" href="print.html#summary-62" id="summary-62"><h1>Summary</h1></a>
<p>Introduce a low-level &quot;flag&quot; to remove the automatic wrapper <code>&lt;div&gt;</code> for
template-only components (templates in the <code>components</code> folder that do not
have a corresponding <code>.js</code> file).</p>
<p>In other words, given there is NO <code>app/components/hello-world.js</code> and there
exists <code>app/templates/components/hello-world.hbs</code> which contains the
following markup:</p>
<pre><code class="language-hbs">Hello world!
</code></pre>
<p>When this template-only component is invoked as <code>{{hello-world}}</code> with the
flag unset or disabled (i.e. today's semantics), Ember will render:</p>
<pre><code class="language-html">&lt;div id=&quot;ember123&quot; class=&quot;ember-view&quot;&gt;Hello world!&lt;/div&gt;
</code></pre>
<p>When the flag is enabled, the same invocation will render:</p>
<pre><code class="language-html">Hello world!
</code></pre>
<a class="header" href="print.html#motivation-63" id="motivation-63"><h1>Motivation</h1></a>
<p>With today's component system (i.e. <code>Ember.Component</code>), a wrapper element (a
<code>div</code> by default, along with an ID like <code>ember123</code> and the <code>ember-view</code> class)
is automatically added for every component.</p>
<p>Customizing this wrapper element (such as changing the tag name – or removing
it altogether) requires making changes to the component's JavaScript class,
such as:</p>
<pre><code class="language-js">import Component from &quot;@ember/component&quot;;

export Component.extend({
  tagName: &quot;footer&quot;,
  classNames: [&quot;legalese&quot;]
});
</code></pre>
<p>While we acknowledge this API is quite cumbersome, it is sufficient to &quot;get
things done&quot; for regular components, and Glimmer Components will address
the usability aspect once they land.</p>
<p>However, this API does not work for template-only components, as they do
not have a component JavaScript class by definition. Therefore, in practice,
template-only components always come with a <code>&lt;div&gt;</code> wrapper, along with the
default <code>id</code> and <code>class</code> attributes, with no obvious ways to customize it.</p>
<p>This is quite problematic, as it is often desirable to use a template-only
component to organize content that requires a certain markup structure. The
most common workaround for this problem is to use a partial instead, which
comes with <a href="https://github.com/emberjs/rfcs/pull/262">a host of issues</a>. I
will discuss other workarounds in the section below.</p>
<p>This RFC proposes to add a global flag to remove this wrapper element around
template-only components. This will allow the component author to specify the
wrapper element in the component template, offering direct control over the
tag name and other attributes. It would also allow the component to have more
than one top-level element, or none at all.</p>
<p>In other words, this flag changes template-only components in the app to have
&quot;Outer HTML&quot; semantics. <em>What you type is what you get.</em></p>
<p>Notably, <a href="https://glimmerjs.com/guides/templates-and-helpers">Glimmer Components</a>
have adopted the &quot;Outer HTML&quot; semantics long ago and the experience has been
very positive. This would be one of the first pieces of the Glimmer.js experiment
to make its way into Ember. We think this feature is small, self-contained but
useful enough to be integrated back into Ember at this point.</p>
<p>If accepted, this RFC will fully subsume the <a href="https://github.com/emberjs/rfcs/pull/262">Non-context-shifting partials</a>
RFC. We can therefore (at a later time, in a separate RFC) explore deprecating
partials in favor of wrapper-free template-only components.</p>
<a class="header" href="print.html#detailed-design-56" id="detailed-design-56"><h1>Detailed design</h1></a>
<a class="header" href="print.html#api-surface" id="api-surface"><h2>API Surface</h2></a>
<p>We should not expose the flag directly as a public API. Instead, we should
abstract the flag with a &quot;privileged addon&quot; whose only purpose is to enable
the flag. Applications will enable the flag by installing this addon. This
will allow for more flexibility in changing the flag's implementation (the
location, naming, value, or even the existence of it) in the future. From the
user's perspective, it is the <em>addon</em> that provides this functionality. The
flag is simply an internal implementation detail.</p>
<p>We have done this before in other cases (such as the legacy view addon during
the 2.0 transition period), and it has generally worked well.</p>
<p>When landing this feature, it will be entirely opt-in for existing apps, but
the Ember CLI application blueprint should be updated to include the addon by
default. At a later time, we should provide another addon that <em>disables</em> the
flag explicitly (installing both addons would be an install-time error). At
that time, we will issue a deprecation warning if the flag is <em>not set</em>, with
a message that directs the user to install one of the two addons.</p>
<a class="header" href="print.html#single-global-flag" id="single-global-flag"><h2>Single Global &quot;Flag&quot;</h2></a>
<p>The proposed flag will be truly global in scope. That is, setting this flag
will change the semantics of all template-only components in the entire app,
even for components that were included by addons.</p>
<p>However, we believe this would not affect any addon components in practice,
as the predominant pattern for addons to expose components currently
necessitates a JavaScript class. Addon authors would create the component
(with or without a JavaScript class) in the <code>/addon</code> folder, but exposing
it for consumption in apps requires creating a corresponding JavaScript class
in the <code>/app</code> folder to &quot;re-export&quot; the component. Therefore, in practice,
it is not actually possible for addons to have a truly template-only
component today (something to address in a future RFC).</p>
<a class="header" href="print.html#leakage-of-embercomponent-semantics" id="leakage-of-embercomponent-semantics"><h2>Leakage Of <code>Ember.Component</code> Semantics</h2></a>
<p>While the primary purpose of this flag is to remove the wrapper element from
template-only components, there are a few other observable semantics changes
that comes with it as well.</p>
<p>Currently, template-only components are &quot;backed&quot; by an instance of <code>Ember.Component</code>.
That is, Ember will create an instance of <code>Ember.Component</code> and set it as the
<code>{{this}}</code> context for the template.</p>
<p>With the flag enabled, there will be <em>no</em> component instance for the template
and <code>{{this}}</code> will be set to <code>undefined</code> (or <code>null</code>, perhaps). This would
improve performance for template-only components significantly.</p>
<p>Since there is no JavaScript file for the component, this is only observable
in a few limited ways:</p>
<ol>
<li>
<p>The most noticable artifact is the component's arguments will not be
auto-reflected on the component instance (as there is no component
instance at all). Therefore, the only way to access the component's
arguments is to use the <code>{{@foo}}</code> syntax proposed in <a href="https://github.com/emberjs/rfcs/pull/276">RFC #276</a>.</p>
</li>
<li>
<p>Because of the named arguments auto-reflection, it is actually possible
to configure the <code>tagName</code> and classes on the &quot;hidden&quot; component
instance on the invocation (e.g. <code>{{foo-bar tagName=&quot;footer&quot; class=&quot;legalese&quot;}}</code>).
This will obviously stop working, but it is also not necessary anymore
as the component author can simply include the tag in the template.
Alternatively, the component author can choose to leave out the tag
and let the caller wrap it in their template.</p>
</li>
<li>
<p>It is possible (but very rare) to configure global injections on the
component type. Since no component is being instantiated here, those
properties will not be accessible in the template.</p>
<p>More broadly, <code>{{this.foo}}</code> or the shorthand <code>{{foo}}</code> (where it
would have resolved into a <code>this</code> lookup) will always be <code>undefined</code>
(or <code>null</code>, perhaps).</p>
</li>
</ol>
<a class="header" href="print.html#migration-path" id="migration-path"><h2>Migration Path</h2></a>
<p>Given the subtle semantics differences enumerated above, it is
not necessarily safe to simply turn on the flag in bigger applications
as it is quite likely that some of the template-only components might be
relying on one or more of these features. Further, removing the wrapper
element might break the layout.</p>
<p>Therefore, the only safe, mechanical transformation is to generate a
JavaScript file for each template-only component (turning them into non-
template only components). We should supplement the change by providing
a codemod that does this for you.</p>
<p>While this would mean that apps would not be able to immediately take
advantage of the feature, it will open the door for new template-only
components to be written in the new semantics.</p>
<p>The user can also audit the components we identified and decide to
delete the JavaScript and migrate them on a case-by-case basis.</p>
<p>The codemod can also come with a more aggressive (and unsound) mode that
simply wraps each template in a <code>&lt;div&gt;</code> (to avoid breaking layout in most
cases). This might be acceptable for smaller apps.</p>
<p>For what it's worth, the Ember CLI component blueprint always generate a
JavaScript and a template file, so it might not be that common to find
existing template-only components in an average app.</p>
<a class="header" href="print.html#implementation-plan" id="implementation-plan"><h2>Implementation Plan</h2></a>
<p>Finally, for the actual implementation, this would be implemented using
the internal Component Manager API that has already been available for a long
time (and how Curly Components, outlets etc are implemented internally).</p>
<p>It should be very straightforward implementation – essentially just a
Component Manager that requires no capabilities and returns <code>null</code> in
<code>getSelf</code>.</p>
<a class="header" href="print.html#how-we-teach-this-36" id="how-we-teach-this-36"><h1>How We Teach This</h1></a>
<p>Going forward, the &quot;Outer HTML&quot; semantics will be the default for
template-only components, Glimmer Components and other custom component
types (when the Component Manager API is available), so over time it
should feel quite natural. The experience from the Glimmer experiment
has also proven that this is the more natural programming model for
components.</p>
<p>In the mean time, we still have to deal with the consequence that
existing <code>Ember.Component</code> comes with a wrapper element by default. The
mental model for users to understand this is that the <code>Ember.Component</code>
class is what is giving you the wrapper element (therefore, template-only
components, which is not an <code>Ember.Component</code> does not get one of those).</p>
<p>This should feel quite natual, as the component class is where you
configure the wrapper element (and where you would lookup the API
documentation). You could imagine that the <code>Ember.Component</code> is doing
something like this under-the-hood as a convenience feature (which turned
out to be not very convenient after all, but that's a different story):</p>
<pre><code class="language-js">export const Component = Object.extend({
  tagName: &quot;div&quot;,
  classNames: [&quot;ember-view&quot;],

  // This is not real code that exists in the implementation
  render(buffer, template) {
    buffer.append(`&lt;${this.tagName} class=&quot;${this.classNames.join(' ')}&quot;&gt;`);
    buffer.append(template(this));
    buffer.append(`&lt;/${this.tagName}&gt;`);
  }
});
</code></pre>
<a class="header" href="print.html#drawbacks-60" id="drawbacks-60"><h1>Drawbacks</h1></a>
<p>In general, we avoid flags that puts Ember into very different &quot;modes&quot; as
they causes complication across the whole addon ecosystem. However, as
mentioned above, we don't believe this would be the case here.</p>
<a class="header" href="print.html#alternatives-61" id="alternatives-61"><h1>Alternatives</h1></a>
<p>We could keep the current semantics for template-only components. However,
this is usually undesirable, and would only grow to feel more unnatural
as Glimmer Components and friends adopt the &quot;Outer HTML&quot; semantics.</p>
<p>Alternatively, we can make this opt-in per template using a pragma or magic
comment. However, this would be needed for a lot of templates and become
very noisy, and the alternative strategy proposed here (by keeping around
the <code>Ember.Component</code> JavaScript file as needed) would be able to accomplish
the same goal with less noise.</p>
<ul>
<li>Start Date: 2017-12-11</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/280</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/15981</li>
</ul>
<a class="header" href="print.html#summary-63" id="summary-63"><h1>Summary</h1></a>
<p>Introduce a low-level &quot;flag&quot; to remove the automatic wrapper <code>&lt;div&gt;</code> around
Ember apps and tests.</p>
<a class="header" href="print.html#motivation-64" id="motivation-64"><h1>Motivation</h1></a>
<p>In Ember applications today, applications are anchored to some existing HTML
element in the page. Usually, this element is the <code>&lt;body&gt;</code> of the document, but it
can be configured to be a different one when the application is defined,
passing a CSS selector to the <code>rootElement</code> property:</p>
<pre><code class="language-js">export default Ember.Application.extend({
  rootElement: '#app'
});
</code></pre>
<p>However, whatever the root is, the application adds another <code>&lt;div&gt;</code> wrapper
that is not required anymore. It's a vestigial remainder of some implementation
detail of how views worked in Ember 1.x. Some sort of wisdom tooth of the original
rendering system that serves no purpose today.</p>
<p>Furthermore, much like a wisdom tooth, it can give us problems. In the past, this element
was configurable using the <code>ApplicationView</code>, but when views were removed we lost that
ability. Right now we are stuck with a wrapper element we can't remove nor customize,
which is why some apps target the selector <code>body &gt; .ember-view</code> to style this element.</p>
<p>Similarly, in testing there is another <code>.ember-view</code> wrapper inside the
<code>#ember-testing</code> container for no good reason.</p>
<p>This RFC proposes to add a global flag to remove those wrapper elements,
effectively making the <code>application.hbs</code> template have &quot;Outer HTML&quot; semantics, which aligns
well with <a href="https://github.com/emberjs/rfcs/pull/278">the changes recently proposed</a>
for template-only components, as well as the way Glimmer apps work.</p>
<p>The same flag will also remove the unnecessary extra wrapper inside the testing
container.</p>
<a class="header" href="print.html#detailed-design-57" id="detailed-design-57"><h1>Detailed design</h1></a>
<a class="header" href="print.html#api-surface-1" id="api-surface-1"><h2>API Surface</h2></a>
<p>The proposed approach is identical to the one proposed in #278, quoted below:</p>
<blockquote>
<p>We should not expose the flag directly as a public API. Instead, we should
abstract the flag with a &quot;privileged addon&quot; whose only purpose is to enable
the flag. Applications will enable the flag by installing this addon. This
will allow for more flexibility in changing the flag's implementation (the
location, naming, value, or even the existence of it) in the future. From the
user's perspective, it is the addon that provides this functionality. The
flag is simply an internal implementation detail.</p>
</blockquote>
<blockquote>
<p>We have done this before in other cases (such as the legacy view addon during
the 2.0 transition period), and it has generally worked well.</p>
</blockquote>
<blockquote>
<p>When landing this feature, it will be entirely opt-in for existing apps, but
the Ember CLI application blueprint should be updated to include the addon by
default. At a later time, we should provide another addon that <em>disables</em> the
flag explicitly (installing both addons would be an install-time error). At
that time, we will issue a deprecation warning if the flag is <em>not set</em>, with
a message that directs the user to install one of the two addons.</p>
</blockquote>
<a class="header" href="print.html#migration-path-1" id="migration-path-1"><h2>Migration Path</h2></a>
<p>Given that this change only affects one single point in your application,
I do not believe we need any specific strategy. If the users want to bring
back the wrapper because it breaks their styles or some other reason,
they can just add it manually on the <code>application.hbs</code> template, with
any class or id they want.</p>
<a class="header" href="print.html#how-we-teach-this-37" id="how-we-teach-this-37"><h1>How We Teach This</h1></a>
<p>This addon will be opt-in, but at some point it will become part of
the default blueprint. This change, rather than introducing a new concept, <em>removes</em>
an old one. Users won't have to google what is the way to remove or customize
the implicit application wrapper of the app (to sadly discover that is not
even possible), but instead they will add a wrapper only if they want,
and in the same way they would add a wrapper in any other point of their application,
with regular Handlebars.</p>
<a class="header" href="print.html#drawbacks-61" id="drawbacks-61"><h1>Drawbacks</h1></a>
<p>There is a possibility that removing the wrapper can break styles for some apps,
but since adding the wrapper back is just editing the <code>application.hbs</code> template,
that is probably a minor drawback.</p>
<p>There is also a non-zero chance that some testing addon is relying on the <code>#ember-testing &gt; .ember-view</code>
HTML hierarchy for some reason, and those addons would have to be updated.</p>
<a class="header" href="print.html#alternatives-62" id="alternatives-62"><h1>Alternatives</h1></a>
<p>Leave things as they are today.</p>
<ul>
<li>Start Date: 2017-12-12</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/281</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-64" id="summary-64"><h1>Summary</h1></a>
<p>Install ES5 getters for computed properties on object prototypes, thus
eliminating the need to use <code>this.get()</code> or <code>Ember.get()</code> to access them.</p>
<p>Before:</p>
<pre><code class="language-js">import Object, { computed } from '@ember/object';

const Person = Object.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.get('firstName')} ${this.get('lastName')}`;
  })
});

let chancancode = Person.create({ firstName: 'Godfrey', lastName: 'Chan' });

chancancode.get('fullName'); // =&gt; 'Godfrey Chan'

chancancode.set('firstName', 'ʎǝɹɟpo⅁');

chancancode.get('fullName'); // =&gt; 'ʎǝɹɟpo⅁ Chan'

let { firstName, lastName, fullName } = chancancode.getProperties('firstName', 'lastName', 'fullName');
</code></pre>
<p>After:</p>
<pre><code class="language-js">import Object, { computed } from &quot;@ember/object&quot;;

const Person = Object.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
});

let chancancode = Person.create({ firstName: 'Godfrey', lastName: 'Chan' });

chancancode.fullName; // =&gt; 'Godfrey Chan'

chancancode.set('firstName', 'ʎǝɹɟpo⅁');

chancancode.fullName; // =&gt; 'ʎǝɹɟpo⅁ Chan'

let { firstName, lastName, fullName } = chancancode; // No problem!
</code></pre>
<a class="header" href="print.html#motivation-65" id="motivation-65"><h1>Motivation</h1></a>
<p>Ember inherited its computed properties functionality from <a href="http://guides.sproutcore.com/core_concepts_kvo.html">SproutCore</a>.
The feature was designed at a time before <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">ES5 getters</a>
were widely available. This necessitated using a special function such as
<code>this.get()</code> or <code>Ember.get()</code> to access the values of computed properties.</p>
<p>Since all of our <a href="https://github.com/emberjs/rfcs/pull/252">target browsers</a>
support ES5 getters now, we can drop the need of this special function,
improving developer ergonomics and interoperability between other libraries
and tooling (such as TypeScript).</p>
<p>Note that at present, using <code>this.set()</code> or <code>Ember.set()</code> is still mandatory
for the property to recompute properly. In the future, we might be able to
loosen this requirement, perhaps with the help of ES5 setters. However, that
would require more design and is out-of-scope for this RFC.</p>
<p><code>this.get()</code> and <code>Ember.get()</code> will still work. This RFC does not propose
removing or deprecating them in the near term. They support other use cases
that ES5 getters do not, such as &quot;safe&quot; path chaining (<code>get('foo.bar.baz')</code>)
and <code>unknownProperty</code> (and Proxies by extension), so any future plans to
deprecate them would have to take these features into account.</p>
<p>Addon authors would likely need to continue using <code>Ember.get()</code> for at least
another two LTS cycles (8 releases) to support older versions of Ember (and
possibly longer to support proxies). It is, however, very unlikely that the
everyday user would need to use this.</p>
<a class="header" href="print.html#detailed-design-58" id="detailed-design-58"><h1>Detailed design</h1></a>
<p>The computed property function, along with any caches, can be stored in the
object's &quot;meta&quot;. We will then define a getter on the object's prototype to
compute the value.</p>
<p>One caveat is that the computed property function is currently stored on the
instances for implementation reasons that are no longer relevant. However,
it is possible that some developers have observed their existance and have
accidentally relied on these private semantics (e.g. <code>chancancode.fullName.get()</code>
or <code>chancancode.fullName.isDescriptor</code>).</p>
<p>Before landing this change, we should turn the property into an assertion
so that in these unlikely scenarios, developers will at least receive
some warning.</p>
<p>Another thing to consider is that there is this Little Known Trick™ to add
Computed Properties to POJOs:</p>
<pre><code class="language-js">import { computed, get } from &quot;@ember/object&quot;;

let foo = {
  bar: computed(function() { return 'bar'; })
};

get(foo, 'bar'); // =&gt; 'bar'
</code></pre>
<p>In this case, there is no opportunity for us to install an ES5 getter, and
<code>Ember.get</code> is the only solution. This is very rare in practice and is more
or less just a party trick. We should deprecate this use case (in <code>Ember.get</code>)
and suggest the alternative:</p>
<pre><code class="language-js">import Object, { computed } from &quot;@ember/object&quot;;

let foo = Object.extend({
  bar: computed(function() { return 'bar'; })
}).create();

foo.bar; // =&gt; 'bar'
</code></pre>
<p>Or simply...</p>
<pre><code class="language-js">let foo = {
  get bar() {
    return 'bar';
  }
};

foo.bar; // =&gt; 'bar'
</code></pre>
<a class="header" href="print.html#how-we-teach-this-38" id="how-we-teach-this-38"><h1>How We Teach This</h1></a>
<p>For the most part, this RFC <em>removes</em> a thing that we need to teach new
users.</p>
<p>It might, however, come across as slightly strange that <code>set()</code> is still
required. However, many other libraries share the same model, and
empricially, this does not appear to be an issue. For example, in React,
you can freely access <code>this.state.foo</code> but must use <code>this.setState('foo', ...)</code>
to update it. Even Vue has <a href="https://vuejs.org/v2/api/#Vue-set">the same API</a>
for some cases.</p>
<p>The mental model for this is that you must use the <code>set()</code> in order for
Ember to notice your mutations, so that it can update the caches, rerender
things on the screen, etc.</p>
<p>As for users who already learned to use <code>get()</code> everywhere, that would
continue to work. Ideally, this would be a Cool Trick™ they pick up some day
(as in &quot;Oh, I don't have to do <em>that</em> anymore? Cool.&quot;), at which point the
old habit would quickly die. If this turned out to be too confusing, we
could always explore deprecating <code>this.get()</code>; we will just have to weigh
the cost-benefits of the confusion (if any) versus churn.</p>
<a class="header" href="print.html#drawbacks-62" id="drawbacks-62"><h1>Drawbacks</h1></a>
<p>As mentioned, not removing <code>set()</code> at the same time might be a source of
confusion. However, removing <code>set()</code> would require significantly more
upfront design work, and it <a href="https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats">might not even be possible</a>
to completely remove the need of <code>set()</code> (as the system is designed today)
in all cases (see <code>Vue.set()</code>).</p>
<p>Since removing <code>get()</code> would unlock so many benefits, and since there are
plenty of other libraries that uses the same model, the case for decoupling
the two seems overwhemlingly positive.</p>
<a class="header" href="print.html#alternatives-63" id="alternatives-63"><h1>Alternatives</h1></a>
<ul>
<li>Hold off until we also remove <code>set</code></li>
<li>Hold off until we transition to something like <a href="https://glimmerjs.com/guides/tracked-properties">Glimmer's <code>@tracked</code></a></li>
</ul>
<p>In my opinion, these alternatives do not make a lot of sense, as neither
of these hypothetical systems appear to require (or would benefit from)
having a user-land getter system.</p>
<ul>
<li>Start Date: 2017-12-21</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/286</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/16076</li>
</ul>
<a class="header" href="print.html#block-let-template-helper" id="block-let-template-helper"><h1>Block <code>let</code> template helper</h1></a>
<a class="header" href="print.html#summary-65" id="summary-65"><h2>Summary</h2></a>
<p>Introduce the <code>let</code> template helper in block form.</p>
<a class="header" href="print.html#motivation-66" id="motivation-66"><h2>Motivation</h2></a>
<p>The goal of this RFC is to introduce a <code>let</code> template helper that allows to create new bindings in templates.
The design of this helper is similar to <code>with</code>,
but without the conditional rendering of the block depending on the values passed into the helper.</p>
<p>While the conditional semantics of <code>with</code> are coherent with the other built-in helpers like <code>each</code> and <code>if</code>,
users often find this unexpected.
The fact that only the first positional parameter of <code>with</code> controls whether the block is rendered might also add to the confusion.</p>
<p>Taking an example from <a href="https://github.com/emberjs/rfcs/pull/200">RFC #200</a>,
let's consider we have the following template:</p>
<pre><code class="language-handlebars">Welcome back {{concat (capitalize person.firstName) ' ' (capitalize person.lastName)}}

Account Details:
First Name: {{capitalize person.firstName}}
Last Name: {{capitalize person.lastName}}
</code></pre>
<p>Because you have to know to capitalize every time you want to display a name,
errors might be introduced if we forget to do it when adding the name somewhere else in the template.
Using the <code>let</code> helper, this could be done like so:</p>
<pre><code class="language-handlebars">{{#let (capitalize person.firstName) (capitalize person.lastName)
  as |firstName lastName|
}}
  Welcome back {{concat firstName ' ' lastName}}

  Account Details:
  First Name: {{firstName}}
  Last Name: {{lastName}}
{{/let}}
</code></pre>
<p>Now you can use <code>firstName</code> and <code>lastName</code> inside the <code>let</code> block with the knowledge that that logic is in a single place.</p>
<p>With the introduction of template-only components in <a href="https://github.com/emberjs/rfcs/pull/278">RFC #278</a>,
having the capability to create additional bindings in the template would prove useful.
Another aspect to consider is related to the <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">Named Blocks RFC</a>.
In both the case of named blocks and block let, you can achieve most of the same functionality by using components.
The components approach has its own drawbacks, which are explored in Alternatives below.</p>
<a class="header" href="print.html#detailed-design-59" id="detailed-design-59"><h2>Detailed design</h2></a>
<p>The <code>let</code> helper should be implemented as a built-in helper, with the following semantics:</p>
<ul>
<li><strong>Only</strong> the block form is available</li>
<li>The block is always rendered</li>
<li>It should support however many positional arguments are passed to the helper</li>
<li>Positional arguments passed to the helper should be yielded back out in the same order</li>
<li>Inline form issues an error, linking users to documentation</li>
</ul>
<p>There already exists <a href="https://github.com/emberjs/ember.js/blob/9536e137b9e1a39411b7fd4e8ca0e7fbb341ef17/packages/ember-glimmer/tests/integration/syntax/experimental-syntax-test.js#L6-L37">an implementation in the codebase</a> that can be used as a basis.</p>
<a class="header" href="print.html#how-we-teach-this-39" id="how-we-teach-this-39"><h2>How We Teach This</h2></a>
<p>The introduction of the <code>let</code> helper brings no new concepts.
It touches on the concepts of block helpers, how to pass arguments to them,
and how to use block parameters (<code>as |foo|</code>), which should already be introduced in the literature.</p>
<p>Current Ember developers should find it familiar to use <code>let</code>, as it is very similar to <code>with</code>.</p>
<p>JavaScript developers should also be familiar with <code>let</code> bindings,
as recent specifications of the language introduced that keyword.</p>
<p>The Guides already possess a section dedicated to Templates, with multiple mentions of helpers.
<code>let</code> would likely be documented in the <a href="https://guides.emberjs.com/v2.17.0/templates/built-in-helpers/">Built-in Helpers</a> guide alongside the others.</p>
<p>If this RFC is approved, the <code>let</code> will initially only support the block form.
This means that only the following form is available for users:</p>
<pre><code class="language-handlebars">{{#let 1 2 3 as |one two three|}}
  A, B, C, easy as {{one}}, {{two}}, {{three}}
{{/let}}
</code></pre>
<p>This could also be enforced by issuing a helpful error when <code>let</code> is used in the inline form.</p>
<a class="header" href="print.html#drawbacks-63" id="drawbacks-63"><h2>Drawbacks</h2></a>
<p>As is the case when adding any sort of API, we will be increasing the cognitive load of learners and users,
as it is one more piece of information to obtain and retain.</p>
<p>The cost of learning this API is mitigated by the fact that its effects are very localized.
It is a template helper, so it will only affect templates.
It is not required for general usage of Ember, unlike something like <code>link-to</code>,
so you can learn the helper at your own pace.</p>
<p>And lastly, if you do use it or encounter it in code, only the markup inside the <code>{{#let}}{{/let}}</code> block is affected,
making it easier to reason about.</p>
<a class="header" href="print.html#alternatives-64" id="alternatives-64"><h2>Alternatives</h2></a>
<a class="header" href="print.html#inline-form" id="inline-form"><h3>Inline form</h3></a>
<p>At the moment, the only way to introduce a new binding in a template is through block params.
For example, if you are iterating over an array with <code>each</code>, you
introduce a binding named <code>item</code> for the item currently being iterated:</p>
<pre><code class="language-handlebars">{{#each myArray as |item|}}
  I am item {{item}}.
{{/each}}
</code></pre>
<p>The inline form of <code>let</code> would be an additional way of introducing bindings in templates.
Using the names example from the RFC, it would look like the following in inline form:</p>
<pre><code class="language-handlebars">{{let
  firstName=(capitalize person.firstName)
  lastName=(capitalize person.lastName)
}}

Welcome back {{concat firstName ' ' lastName}}

Account Details:
First Name: {{firstName}}
Last Name: {{lastName}}
</code></pre>
<p>This syntax raises questions about the semantics of the inline form,
such as what is the scope of the binding, that are better left to a subsequent RFC.</p>
<a class="header" href="print.html#using-components" id="using-components"><h3>Using components</h3></a>
<p>In a similar situation to <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">Named Blocks RFC</a>,
it is also possible to replicate some of the behavior of the proposed <code>let</code> helper using components.
However, using components also presents some drawbacks.</p>
<p>You can extract the template and do:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
Welcome back {{concat firstName ' ' lastName)}}

Account Details:
First Name: {{firstName}}
Last Name: {{lastName}}
</code></pre>
<pre><code class="language-handlebars">{{person-tile firstName=(capitalize person.firstName) lastName=(capitalize person.lastName)}}
</code></pre>
<p>This addresses not having to repeat <code>capitalize</code> wherever the names are used,
but splits the content into multiple files for the sake of it.
While <a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">module unification</a> mitigates the locality problem by putting related files in the same folder,
there is still the overhead of having to consult multiple files.</p>
<p>You can instead use a block version of the component as a wrapper to the content.
Some variations are possible: you can pass data into the component as either positional or named arguments;
you can export either an object with the arguments as keys, or export multiple block parameters.</p>
<p>Passing positional arguments to components is onerous,
and necessitates having a JavaScript file to define which positional arguments it accepts.</p>
<p>Passing named arguments to components would be the closest to <code>let</code>,
but it would still require a componente template file which would yield them as block parameters.</p>
<p>Yielding out the values is where it gets tricky in components,
regardless of returning a hash or multiple block parameters,
due to the lack of a &quot;splat&quot; operator in Handlebars.</p>
<p>Since you cannot do something like this at the moment:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield ...arguments}}
</code></pre>
<p>You would have to explicitly encode all of the arguments:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield firstName lastName}}
</code></pre>
<p>Or</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield args=(hash firstName=firstName lastName=lastName)}}
</code></pre>
<p>Leading to some repetition of names.</p>
<p>This makes the solution of using components brittle to changes,
as typos or ordering mistakes can introduce silent errors in your application.</p>
<a class="header" href="print.html#adding-named-arguments-to-with" id="adding-named-arguments-to-with"><h3>Adding named arguments to <code>with</code></h3></a>
<p><a href="https://github.com/emberjs/rfcs/pull/202">RFC #202</a> proposes to add named arguments to <code>with</code>.</p>
<p>I feel it is less practical to add a new mode to the helper where it always renders,
when its semantics are already confusing to users.
The RFC #202 proposal also presents the problem of bringing back context-switching helpers,
as it proposes omitting block arguments (<code>as |bar|</code> in <code>{{#with foo as |bar|}}</code>).</p>
<a class="header" href="print.html#remove-the-conditional-behavior-of-with" id="remove-the-conditional-behavior-of-with"><h3>Remove the conditional behavior of <code>with</code></h3></a>
<p>Making the <code>with</code> helper unconditionally render the block would be a major breaking change of its semantics,
and would likely affect existing applications in insidious ways.
For this reason, I reject this alternative out of the gate.</p>
<a class="header" href="print.html#support-let-via-the-ember-let-addon" id="support-let-via-the-ember-let-addon"><h3>Support <code>let</code> via the <code>ember-let</code> addon</h3></a>
<p>There is an <a href="https://github.com/thefrontside/ember-let"><code>ember-let</code></a> addon which implements both the block and the inline forms of <code>let</code>.
To implement the necessary functionality, the addon had to resort to private API usage, which is brittle and subject to breakage.</p>
<p>Having <code>let</code> available from Ember itself would make sure that it would not be subject to breakage the same way,
and the end user would not have to worry about version compatibility.</p>
<a class="header" href="print.html#unresolved-questions-46" id="unresolved-questions-46"><h2>Unresolved questions</h2></a>
<p>None.</p>
<a class="header" href="print.html#future-work" id="future-work"><h2>Future work</h2></a>
<a class="header" href="print.html#deprecating-with" id="deprecating-with"><h3>Deprecating <code>with</code></h3></a>
<p>With the introduction of the <code>let</code> helper, <code>with</code> should likely be deprecated.</p>
<a class="header" href="print.html#if-let-let-and-others" id="if-let-let-and-others"><h3><code>if-let</code>, <code>let*</code> and others</h3></a>
<p>RFC #200 also proposes the <code>if-let</code> and <code>let*</code> helpers.</p>
<p><code>if-let</code> mimics the behaviour of <code>with</code>,
enabling the user to introduce bindings and conditionally rendering the block.
The advantage of introducing <code>if-let</code> over using <code>with</code> would be to define its semantics without worrying about making breaking changes to <code>with</code>.</p>
<p><code>let*</code> would allow bindings to happen sequentially, that is,
<code>let</code> (<code>{{let* a=1 b=(sum a 5)}}</code> would be valid instead of throwing an error about <code>a</code> in <code>(sum a 5)</code>.</p>
<p>These could also be addressed in subsequent RFCs, focused on the specificities of each proposal.</p>
<ul>
<li>Start Date: 2017-12-22</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/287</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-66" id="summary-66"><h1>Summary</h1></a>
<p>Promote the private API <code>{{-in-element}}</code> to public API as <code>{{in-element}}</code>.</p>
<a class="header" href="print.html#motivation-67" id="motivation-67"><h1>Motivation</h1></a>
<p>Sometimes developers need to render content out of the regular HTML flow. This concept is often also
called &quot;portals&quot;. Some components like dropdowns and modals use this technique to render stuff close
to the root of the page to bypass CSS overflow rules. Some apps that are embedded into static pages
even use this technique to update parts of the page <strong>outside</strong> the app itself.</p>
<p>This need need has been covered by solutions developed in the user space but it was so common that
glimmer baked it into the VM in the form of <code>{{-in-element}}</code>, but it remains private (or <em>intimate</em>) API.
People is usually wary of using private APIs (and for good reason) as they may get removed at any time.</p>
<p>If the core team and the community is happy with the current behavior of <code>{{-in-element}}</code> it's
time to make it public.</p>
<a class="header" href="print.html#detailed-design-60" id="detailed-design-60"><h1>Detailed design</h1></a>
<p>The existing API of <code>{{-in-element}}</code> is very simple:</p>
<ul>
<li>It takes a single positional param <code>destinationElement</code> that is a DOM element, and a block.</li>
<li>The given block is rendered not where it is located, but inside the given <code>destination</code> element, at
the end of it if there is any other content on the destination element.</li>
<li>If <code>destinationElement</code> is null/undefined then it doesn't render anything but it doesn't error.</li>
<li>If <code>destinationElement</code> is false/0/&quot;&quot; it raises an assertion in development but fails silently in production.</li>
<li>If <code>destinationElement</code> changes the block is removed from the previous destination and added to the new one. This
process tears down the rendered content on the initial destination and renders it again on the new one, meaning
that any component withing the block will be destroyed and instantiated again (calling the appropiate lifecycle hooks),
so transient HTML state like the value of an input will be lost unless manually preserved somewhere else, like a service.</li>
<li>If the destination element is an invalid value (a string, a number ...) it throws an <code>parent.insertBefore is not a function</code> error. I think
that throwing an error is correct but the error message could be improved.</li>
<li>If the destination element has a different context (like SVG) the content will be appended normally by the glimmer VM,
which doesn't try to validate the correctness of the generated HTML. This is normal behavior in Glimmer, not
an exception, and users must be aware that rendering invalid markup might be interpreted or auto-corrected in
unexpected ways by the browser when in SSR mode.</li>
<li>Rendering into a foreign object (an element within an <code>&lt;iframe&gt;</code>) should be disallowed initially. If someone
asks for this feature it would require an RFC to explore the consequences.</li>
</ul>
<p>Example usage:</p>
<pre><code class="language-hbs">{{#-in-element destinationElement}}
  &lt;div&gt;Some content&lt;/div&gt;
{{/-in-element}}
</code></pre>
<p>The current implementation only suggests creating a new <code>{{in-element}}</code> construct that is a simple
alias of <code>{{-in-element}}</code> with the exact same params and behavior, and then, after a while, remove
the private one.</p>
<p>Although <code>{{-in-element}}</code> is technically private, there there is enough people using it to deserve
a deprecation. I suggest keeping the deprecated private API will until the first LTS release of the
3.X cycle (3.4) to be finally removed in the next one (3.5).</p>
<a class="header" href="print.html#small-proposed-changes" id="small-proposed-changes"><h3>Small proposed changes</h3></a>
<p>There is however one part of the behavior that the core team wants to make explicit before promoting
the private API to public, and that is how the content is added to the destination when there is other
content already there.</p>
<p>The desired behavior is that, by default, the rendered content will <strong>replace all the content of the destination</strong>,
effectively becoming the its <code>innerHTML</code>.
In the current behaviour the rendered content is appended as the end of any existing content. This will still
be supported by passing <code>insertBefore=null</code>, but it will not be the default anymore.
Any other value passed to <code>insertBefore</code> must produce an error.</p>
<a class="header" href="print.html#how-we-teach-this-40" id="how-we-teach-this-40"><h1>How We Teach This</h1></a>
<p>This will be a new build-in helper and must be added to the guides and the API.
For most usages, it will replace some community solution created with the same goal, like
<a href="https://github.com/yapplabs/ember-wormhole">ember-wormhole</a> or <a href="https://github.com/ef4/ember-elsewhere">ember-elsewhere</a>.
It would be for the best to let the authors of those addons know about this feature so they can
deprecate their packages if they feel there is no longer a need for them, or at least update their
Readme files to let their users know that there is a built-in solution in Ember that might cover
their needs.</p>
<a class="header" href="print.html#drawbacks-64" id="drawbacks-64"><h1>Drawbacks</h1></a>
<p>By augmenting the public API of the framework, the framework is committing to support it for the lifespan
of an entire mayor version (Ember 4.0).</p>
<a class="header" href="print.html#alternatives-65" id="alternatives-65"><h1>Alternatives</h1></a>
<p>We can decide that the framework does not want to make public and support this feature, and continue
to rely on community-built addons like we've done until today.</p>
<a class="header" href="print.html#unresolved-questions-47" id="unresolved-questions-47"><h1>Unresolved questions</h1></a>
<p>Do we want to make any improvement to <code>{{-in-element}}</code> before making it public API?</p>
<p>Some possible ideas:</p>
<ul>
<li>Allow to <em>conditionally</em> render the block in place. See https://github.com/DockYard/ember-maybe-in-element</li>
<li>Allow to receive not only DOM elements as first argument, but also strings, representing the ID of
other CSS selector.</li>
<li>Modify or improve the way it behaves during SSR using ember-fastboot.</li>
</ul>
<ul>
<li>Start Date: 2018-01-10</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-67" id="summary-67"><h3>Summary</h3></a>
<p>Currently, incrementally experimenting with Ember Data internals is hard both for addon authors
and Ember Data contributors. This RFC rationalizes the internals and establishes clear boundaries
for record data storage and manipulation allowing us to expose a public api for addon authors to experiment with.</p>
<a class="header" href="print.html#motivation-68" id="motivation-68"><h3>Motivation</h3></a>
<p>Externally, addons can customize how apps communicate with the server by implementing the Adapter/Serializer APIs but changing how ED deals with relationships, attribute buckets, rollbacks, dirtyness
and similar issues is extremely challenging and impossible without extremely internal hacks. One can look at popular addons like EmberDataModelFragments
and see how many private APIs they had to override and hack to implement their funcionality.</p>
<p>Internally, while ED is reasonably well factored between data coming into the system through
Adapter/Serializers/IdentityMap/Store and data going out through DS.Model/Snapshots/Adapters/Serializers
, internal handling of the data including relationships and attributes has extremely fuzzy and unclear boundaries.</p>
<p>Data currently lives in internalModels, relationship state objects, computed property caches, relationship
payload caches, etc.</p>
<a class="header" href="print.html#before" id="before"><h4>before</h4></a>
<p><img src="https://user-images.githubusercontent.com/715175/33340994-6380c66a-d432-11e7-9f00-ed905e78915a.png" alt="image" /></p>
<p>This RFC proposes rationalizing and extracting ED's core record data handling layer into a RecordData class.</p>
<a class="header" href="print.html#after" id="after"><h4>after</h4></a>
<p><img src="https://user-images.githubusercontent.com/715175/33341155-e5f170c2-d432-11e7-9c50-4a3e977331fe.png" alt="image" /></p>
<p>This will allow us to rationalize internal ED APIs, establish clearer internal boundaries,
allow experimentation by addon authors, and create a path for internal ED experimentation.</p>
<p>You can think of Record Data as a layer that can receive JSON api payloads for a record,
apply local changes to it, and can be queried for the current state of the data.</p>
<p>Examples of things this would enable:</p>
<ol>
<li>
<p>By shipping a custom RecordData, EmberDataModelFragments can implement a large part of their
funcionality without relying on private apis. Spike at <a href="https://github.com/igorT/ember-data.model-fragments/tree/igor/model-data">model fragments</a></p>
</li>
<li>
<p>A spike of Ember Data backed by Orbit, can be implemented as an addon, where most of the work
is in implementing a Record Data backed by Orbit. Spike at <a href="https://github.com/igorT/data-orbit/tree/orbit-model-data">data-orbit</a></p>
</li>
<li>
<p>By using an ES6 class for Record Data implementation, this brings us closer to an Emberless
Ember Data running.</p>
</li>
<li>
<p>If you needed to implement a GraphQL like projection API, Adapters and Serializers would be enough
for the loading data, but currently there is no good place to handle client side data interactions.
RecordData would make it much easier to have a GraphQL ED addon</p>
</li>
<li>
<p>Certain apps and models have a large amount of read only data, which is currently very performance heavy
to implement in ED. They could use a read only fast record data addon, which would enable a large perf win.</p>
</li>
<li>
<p>Experimenting with schemaless approaches is currently very hard in ED, because internal
models encode assumptions of how attributes and relationships work. Having a swappable RecordData would
make it easier for us to implement schemaless approaches in addons.</p>
</li>
<li>
<p>By having Record Data fully expressed in JSON API apis, the current state of the store becomes serializable.</p>
</li>
</ol>
<p>By designing a public interface for RecordData that dosen't rely on any other part of EDs current system,
we can use RecordData as the main building block around which we can refactor the rest of ED.</p>
<a class="header" href="print.html#detailed-design-61" id="detailed-design-61"><h3>Detailed design</h3></a>
<a class="header" href="print.html#high-level-design" id="high-level-design"><h4>High level design</h4></a>
<p>Ember Data would define a RecordData interface, and ship a default implementation. Addons would
be able to swap their own implementation of the RecordData interface.</p>
<p>RecordData is an interface defining the api for how the store and DS.Models
store and apply changes to data. RecordDatas hold
the backing data for each record, and act as a bridge between the Store, DS.Model, and Snapshots.
It is per record, and defines apis that respond to
store api calls like <code>pushData</code>, <code>adapterDidCommit</code> and DS.Model updates like <code>setAttribute</code>.
RecordData represents the bucket of state that is backing a particular DS.Model.</p>
<p>The store instantiates the RecordData, feeds it JSON API data coming from the server and
tells it about state changes. DS.Model queries the RecordData for the attribute
and relationship values and sends back the updates the user has made.</p>
<p>Other than the <code>storeApisWrapper</code> passed to it, RecordData does not assume existence of
any other Ember or Ember Data object. It is a fully self contained system, that might serve
as a basic building block of non Ember/ED data libraries and could be extracted into a separate
library.</p>
<a class="header" href="print.html#interface" id="interface"><h4>Interface</h4></a>
<p>The interface for RecordData is:</p>
<pre><code class="language-js">export default class RecordData {
  constructor(modelName: string, clientId?: string, id?: string, storeApisWrapper: StoreApisWrapper) {
    /*
      Exposing the entire store api to the RecordData seems very risky and would 
      limit the kind of refactors we can do in the future. We would provide a wrapper
      to the RecordData that would enable funcionality MD absolutely needs 
    */
  }


  /*
    Hooks through which the store tells the Record Data about the data
    changes. They all take JSON API and return a list of keys that the 
    record will need to update
  */

  pushData(data: JsonApi, shouldCalculateChanges: boolean/* if false, don't need to return changed keys*/) {
  }

  adapterDidCommit(data: JsonApi) {
  }

  didCreateLocally(properties) {
  }

  /*
    Hooks through which the store tells RecordData about the lifecycle of the data,
    allowing it to keep track of dirtyness
  */

  adapterWillCommit(modelName: string, id?: string, clientId?: string) {
  }

  saveWasRejected(modelName: string, id?: string, clientId?: string) {
  }

  adapterDidDelete(modelName: string, id?: string, clientId?: string) {
  }

  recordUnloaded(modelName: string, id?: string, clientId?: string) {
  }


  /*
   Rollback handling
  */

  rollbackAttributes(modelName: string, id?: string, clientId?: string) {
  }

  rollbackAttribute(modelName: string, id?: string, clientId?: string, attribute: string) {
  }

  changedAttributes(modelName: string, id?: string, clientId?: string) {
  }

  hasChangedAttributes(modelName: string, id?: string, clientId?: string) {
  }


  /*
    Methods through which DS.Model interacts with RecordData, by setting and getting local state
  */

  setAttr(modelName: string, id?: string, clientId?: string, key: string, value: string) {
  }

  getAttr(modelName: string, id?: string, clientId?: string, key: string) {
  }

  hasAttr(modelName: string, id?: string, clientId?: string, key: string) {
  }

  /*
    Relationships take and return json api resource objects
    The store takes those references and decides whether it needs to load them, or
    it can serve them from the cache
  */

  getHasMany(modelName: string, id?: string, clientId?: string, key: string) {
  }
  
  addToHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources, idx: number) {
  }

  removeFromHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources) {
  }

  setHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources) {
  }

  getBelongsTo(modelName: string, id?: string, clientId?: string, key: string) {
  }

  setBelongsTo(modelName: string, id?: string, clientId?: string, key: string, jsonApiResource) {
  }

</code></pre>
<pre><code class="language-js">
export default class StoreApiWrapper {
  /* clientId is used as a fallback in the case of client side creation */
  createRecordDataFor(modelName, id, clientId)
  notifyPropertyChanges(modelName, id, clientId, keys)
  /* 
  in order to not expose ModelClasses to RecordData, we need to supply it with
  model schema information. Because a schema design is out of scope for this RFC,
  for now we expose these two methods we intend to deprecate once we have a schema
  interpretation
   */
  attributesDefinitionFor(modelName, id)
  relationshipsDefinitionFor(modelName, id)

}
</code></pre>
<a class="header" href="print.html#eds-usage-of-recorddata" id="eds-usage-of-recorddata"><h4>ED's usage of RecordData</h4></a>
<p>We would refactor internal models, DS.Models and Snapshots to use RecordData's apis.</p>
<p>Reimplementation of ED current internals on top of RecordData apis would consist of the store
pushing the json api payload to the backing record data and the record data setting up internal
data tracking, as well as storing relationship data on any additional needed recordDatas.</p>
<pre><code class="language-js">let data = {
  data: {
    id:1,
    type: 'user',
    attributes: { name: 'Clemens' },
    relationships: { houses: { data: [{ id: 5, type: 'house' }], links: { related: '/houses' } } }
  }
};

store.push(data);

// internal store method
_internalMethod() {
  let recordData = store.recordDataFor('user', 1, this._storeWrapperApi)
  recordData.pushData(data, false)
}

-&gt;

// model-data.js
pushData(data, shouldCalculateChanges) {
  this._data = this.data.attributes;
  this._setupRelationships(data);
}
-&gt;
// model-data.js
_setupRelationships(data) {
  this.storeWrapperApi.recordDataFor('house', 1);
  ....
}
</code></pre>
<p>The DS.Model interactions would look like:</p>
<pre><code class="language-js">let user = store.peekRecord('user', 1);
user.get('name');
-&gt;
// DS.Model
get(key) {
  let recordData = _internalMethodForGettingTheCorrespondingRecordData(this);
  return recordData.getAttr('name');
}
</code></pre>
<a class="header" href="print.html#relationships" id="relationships"><h4>Relationships</h4></a>
<a class="header" href="print.html#basic-loading-of-relationships" id="basic-loading-of-relationships"><h5>Basic loading of relationships</h5></a>
<p>RecordData's relationship hooks would receive and return json api relationship objects with
additional metadata meaningful to Ember Data.</p>
<p>Lets say that we started off with the same user data as above</p>
<pre><code class="language-js">let data = {
  data: {
    id:1,
    type: 'user',
    attributes: { name: 'Clemens' },
    relationships: { houses: { data: [{ id: 5, type: 'house' }], links: { related: '/houses' } } }
  }
};
let clemens = store.push(data);
</code></pre>
<p>Getting a relationships from Clemens would trace a path from the DS.Model to backing record data,
which would then give the store a json api object, and the store would instantiate a ManyArray
with the records</p>
<pre><code class="language-js">clemens.get('houses');
// DS.Model
get() {
  let clemensRecordData = _internalApiGetsUsTheRecordDataFromIDMMAP();
  return clemens.getHasMany('houses');
}
-&gt;
// Record Data returns
{[ 
  data: { id: 5, type: 'house'},
  links: { related: '/houses' },
  meta: { realMetaFromServer: 'hi', _ED: { hasAllIds: true, needToLoadLink: false } }
}
-&gt; //store takes the above, figures out that it needs to fetch house with id 5
  // and returns a promise which resolves into a ManyArray

</code></pre>
<p>ED extends the relationship payload with a custom meta, which gives the store information
about whether we have information about the entire relationship (we couldn't be sure we
have all the ids if we loaded from the belongsTo side) and whether the link should be refetched
(we might need to refetch the link in the case it potentially changed)</p>
<a class="header" href="print.html#setting-relationship-data-locally" id="setting-relationship-data-locally"><h5>Setting relationship data locally</h5></a>
<p>Similarly to the attributes, changing relationships locally tells record data to update
the backing data store</p>
<pre><code class="language-js">let anotherHouse = store.push({data: { type: 'house', id: '5' }});
clemens.get('houses').then((houses) =&gt; {
  houses.pushObject(anotherHouse);
  -&gt; 
  // internally
  clemensRecordData.addToHasMany('houses', { data: { type: 'house', id: '5' } })
});
</code></pre>
<a class="header" href="print.html#dealing-with-newly-created-records-in-relationships" id="dealing-with-newly-created-records-in-relationships"><h5>Dealing with newly created records in relationships</h5></a>
<p>Unfortunately, because ED does not have first class clientId support, we need a special case
for handling locally created records, and pushing them to relationships.</p>
<p>We extend JSON API resource object with a <code>clientId</code> meta field.
A locally created record, will also have a ED specific internal client id, which will take preference;</p>
<pre><code class="language-js">let newHouse = store.createRecord('house');
clemens.get('houses').then((houses) =&gt; {
  houses.pushObject(newHouse);
  -&gt;
  // internally
  clemensRecordData.addToHasMany('houses', { data: { type: 'house', id: null, { meta: _ED: { clientId: 1}} } })
});
clemens.get('houses') -&gt;
{ data: 
  [ { id: 5, type: 'house'}, 
    { id: null, type: 'house', meta: { _ED: { clientId: 1 } } }],
  links: { related: '/hi' },
  meta: { realMetaFromServer: 'hi', _ED: { loaded: true, needToLoadLink: false } }
}
</code></pre>
<p>ED internals would keep a separate cache of client ID and resolve the correct record</p>
<a class="header" href="print.html#addon-usage" id="addon-usage"><h4>Addon usage</h4></a>
<p>The Store provides a public api for looking up a recordData which the store has not seen before.</p>
<pre><code>recordDataFor(modelName, id, options) {

}
</code></pre>
<p>If an Addon wanted to implement custom data handling functionality, it would subclass the store
and implement their own RecordData handler.</p>
<p>There are three main reasons to do this.</p>
<ol>
<li>Full replacement of Ember Data's data handling mechanisms</li>
</ol>
<p>Best example would be the Ember Data backed by Orbit.js experiment. EmberDataOrbit Addon replaces
Ember Data's backing data implementation with Orbit.js. Most of this work can be done by EmberDataOrbit
replacing ED's Record Data implementation</p>
<pre><code>recordDataFor(modelName, id, options, storeWrapper) {
  return new OrbitRecordData(modelName, id, storeApisWrapper) 
}
</code></pre>
<ol start="2">
<li>Per Model replacement of Ember Data's data handling</li>
</ol>
<p>If a large app was loading thousands of instances of a particular record type, which was read-only,
it could use a read only ED addon, which implemented a simplified RecordData without any change tracking.</p>
<p>The addon would implement a <code>recordDataFor</code> on the store as</p>
<pre><code>recordDataFor(modelName, id, options, storeWrapper) {
  if (addonDecidesIfReadOnly(modelName))  {
    return new ReadOnlyRecordData(modelName, id, storeApisWrapper) 
  }
  return this._super(modelName, id, options, storeWrapper);
}
</code></pre>
<ol start="3">
<li>Adding common funcionality to all ED models</li>
</ol>
<p>Ember Data Model Fragments Addon adds support for handling of embedded data fragments.
In order to manage the handling of fragments, Model Fragments would compose ED's default
RecordData with it's own for handling fragments.</p>
<pre><code class="language-js">recordDataFor(modelName, id, options, storeWrapper) {
  let EDRecordData = this._super(modelName, id, options, storeWrapper);
  return new ModelFragmentsRecordData(modelName, id, options, storeWrapper, EDRecordData);
}
</code></pre>
<p>When receiving a payload, ModelFragments would handle the fragment part and delegate the rest
to ED's implementation</p>
<pre><code class="language-js">pushData(data, shouldCalculateChanges) {
  let keysThatChanged = this.extractAndHandleFragments(data);
  return keysThatChanged.concat(this.EDRecordData.pushData(data, shouldCalculateChanges))
}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-41" id="how-we-teach-this-41"><h3>How we teach this</h3></a>
<p>These APIs are not meant to be used by most users, or app level code, and should be hidden away and
described in an api/guides section meant for ED addon authors. Currently there are a few widely used
addons which would greatly benefit from this, so we can also reach out in person. I have already implemented
a spike of ModelFragments using RecordData. Having couple addons implement different RecordDatas would be
a great way to teach new addon authors about the purpose and implementation of the API.</p>
<a class="header" href="print.html#drawbacks-65" id="drawbacks-65"><h3>Drawbacks</h3></a>
<a class="header" href="print.html#defines-a-bigger-api-surface-area" id="defines-a-bigger-api-surface-area"><h4>Defines a bigger API surface area</h4></a>
<p>This change would increase the public API surface area, in a codebase that is already pretty complex.
However, this would codify and simplifyA APIs addon authors have already had to interact with, while
creating a path for future simplification of the codebase.</p>
<a class="header" href="print.html#it-allows-people-to-do-very-non-standard-changes-that-will-complexify-their-app-needlessly" id="it-allows-people-to-do-very-non-standard-changes-that-will-complexify-their-app-needlessly"><h4>It allows people to do very non-standard changes that will complexify their app needlessly</h4></a>
<p>The main mitigation, is only giving RecordData access to a small amount of knowledge of the external world,
and keeping most APIs pull only thus discouraging trying to do innapropriate work in the RecordData layer</p>
<a class="header" href="print.html#the-new-json-api-interaction-might-preclude-performance-improvements-or-reduce-current-performance" id="the-new-json-api-interaction-might-preclude-performance-improvements-or-reduce-current-performance"><h4>The new JSON api interaction might preclude performance improvements, or reduce current performance</h4></a>
<a class="header" href="print.html#alternatives-66" id="alternatives-66"><h3>Alternatives</h3></a>
<a class="header" href="print.html#we-could-do-this-work-as-an-internal-refactor-and-not-expose-it-to-public" id="we-could-do-this-work-as-an-internal-refactor-and-not-expose-it-to-public"><h4>We could do this work as an internal refactor, and not expose it to public.</h4></a>
<p>I believe that this approach is valid as an internal architecture, so would like to do it even if
we did not expose any of it to addons/apps.</p>
<a class="header" href="print.html#make-recorddatas-looked-up-from-the-resolver" id="make-recorddatas-looked-up-from-the-resolver"><h4>Make RecordData's looked up from the resolver</h4></a>
<p>Currently RecordData is a dumb ES6 class and does not live in the Ember resolver system, for performance
and simplicity reasons. We could alternatively look it up from the resolver, allowing people
to mock it and inject into it easier.</p>
<a class="header" href="print.html#dont-expect-a-per-record-record-data" id="dont-expect-a-per-record-record-data"><h4>Don't expect a per record Record Data</h4></a>
<p>Currently, the MD layer semantics mimics current ED's data storage, where data is stored per record in
internalModels. You could alternatively do this using an app wide cache, like Orbit.js does, or
using any number of other approaches. This approach while valid, would be harder to implement and
it's apis would not map as well to ED behavior.</p>
<a class="header" href="print.html#open-questions" id="open-questions"><h3>Open Questions</h3></a>
<a class="header" href="print.html#versioning-and-stability" id="versioning-and-stability"><h4>Versioning and stability</h4></a>
<p>Our current implementation of <code>internalModel</code> is deeply monkeypatched by at least few addons. I think
we have to consider it as an semi-intimate api, even though it literally has <code>internal</code> in the name(I've been told adding couple undescores to the name would have helped).
Because the number of addons monkeypatching it is limited, we can manually migrate them onto the new
apis. However this requires us to make the new apis public from the get go, and doesn't allow for a long period of api evolution.</p>
<p>The following options are available, none of them great:</p>
<ol>
<li>
<p>Feature flag RecordData work. The scope of this refactor is large enough, that doing a full feature
flagging would be an enourmous burden to bear, and I would advise against it. We can proxy some basic
things, to allow for simpler changes and as a way of warning/deprecating</p>
</li>
<li>
<p>Move from the internals to public RecordData in a single release cycle, and hope public apis we created
make sense, and will not be performance issues in the future. I am reasonably confident having implemented
several addons using RecordData that the basic design works, but things can always come up.</p>
</li>
<li>
<p>Move from private internals to private RecordData, and then feature flag the public apis over couple
versions. In this case the addons monkeypatching the internals, would monkeypatch the new nicer apis
for a while, and then easily switch to the public api. This feel a bit like SemVer cheating.</p>
</li>
</ol>
<a class="header" href="print.html#clientid-passing-to-store-api-methods" id="clientid-passing-to-store-api-methods"><h4>ClientID passing to store api methods</h4></a>
<p>We use <code>recordDataFor(modelName, id, clientId)</code> as the api to look up recordDatas. Passing an often
null clientId seems annoying. Orbit.js uses an identity object instead, and if we did the api would look like <code>recordDataFor(identityObject)</code>, where <code>identityObject</code> would look like <code>{ type, id, meta: { _ED: { clientId }}}</code>. This seem a bit more correct, but doesn't look like any existing ED api, and could create
a lot of allocations.</p>
<a class="header" href="print.html#recorddatas-might-need-to-do-some-global-setupcommunication-how-does-that-work" id="recorddatas-might-need-to-do-some-global-setupcommunication-how-does-that-work"><h4>RecordDatas might need to do some global setup/communication, how does that work?</h4></a>
<p>Normally you would do this in an initializer, but becasue MDs aren't resolved, the only way would be
to do it in RecordDataFor or by using a singleton import. Some ceremony being required to using RecordData
isn't super bad, because it will discourage app authors from customizing it for trivial/innapropriate
things.</p>
<a class="header" href="print.html#what-do-we-do-with-the-record-state-management" id="what-do-we-do-with-the-record-state-management"><h4>What do we do with the record state management?</h4></a>
<p>Currently RecordData has no interaction with the state machine. I think we should punt on this
for now.</p>
<a class="header" href="print.html#-meta--_ed--props-here----alternatives" id="-meta--_ed--props-here----alternatives"><h4>{ meta: { _ED: { props here } } } alternatives?</h4></a>
<p>We could put the ED internal data outside of meta, and keep meta only for actual meta that comes from
the server.</p>
<a class="header" href="print.html#naming-of-everything" id="naming-of-everything"><h4>Naming of everything</h4></a>
<p>Please help with better names for things if you have ideas</p>
<a class="header" href="print.html#snapshot-interface" id="snapshot-interface"><h4>Snapshot interface</h4></a>
<p>How does a Snapshot ask Record Data for it's attributes</p>
<a class="header" href="print.html#real-life-perf-impact" id="real-life-perf-impact"><h4>Real life perf impact</h4></a>
<p>Need benchmarks</p>
<ul>
<li>Start Date: 2018-01-11</li>
<li>RFC PR: github.com/emberjs/rfcs/pull/294</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#make-jquery-optional" id="make-jquery-optional"><h1>Make jQuery optional</h1></a>
<a class="header" href="print.html#summary-68" id="summary-68"><h2>Summary</h2></a>
<p>For the past Ember has been relying and depending on jQuery. This RFC proposes making jQuery optional and having a well
defined way for users to opt-out of bundling jQuery.</p>
<a class="header" href="print.html#motivation-69" id="motivation-69"><h2>Motivation</h2></a>
<a class="header" href="print.html#why-we-dont-need-jquery-any-more" id="why-we-dont-need-jquery-any-more"><h3>Why we don't need jQuery any more</h3></a>
<p>One of the early goals of jQuery was cross-browser normalization, at a time where browser support for web standards was
incomplete and inconsistent, and Internet Explorer 6 was the dominating browser. It provided a useful and convenient
API for DOM traversal and manipulation as well as event handling, that hid the various browser differences and bugs from
the user. For example <code>document.querySelector</code> wasn't a thing at that time, and browsers were using very different event
models (<a href="https://en.wikipedia.org/wiki/DOM_events#Event_handling_models">DOM Level 0, DOM Level 2 and IE's own proprietary model</a>).</p>
<p>But this level of browser normalization is not required anymore, as today's browsers all support the basic DOM APIs well
enough. Even more so that the upcoming Ember 3.0 will drop support for all versions of Internet Explorer except 11.</p>
<p>Furthermore Ember users will need to directly traverse and modify the DOM or manually attach event listeners in very
special cases only. Most of these low level interactions are taken care of by Ember's templates and its underlying
Glimmer rendering engine, as well as action helpers or the component's event handler methods.</p>
<p>So having jQuery included by default does not provide that much value to users most of the time, and Ember itself is
expected to be fully functional and tested without jQuery, presumably for the upcoming 3.0 stable release.</p>
<a class="header" href="print.html#what-are-the-drawbacks-of-bundling-jquery" id="what-are-the-drawbacks-of-bundling-jquery"><h3>What are the drawbacks of bundling jQuery</h3></a>
<p>The major drawback is the increased bundle size, which amounts to <a href="https://mathiasbynens.be/demo/jquery-size">~29KB</a>
(minified and gzipped). This not only increases the loading time, but also parse and compile times, thus increasing the
total time to interactive. This is especially true for mobile devices, where slow connectivity and weak CPU performance
is not uncommon.</p>
<p>Having jQuery not included will improve the suitability of Ember for mobile applications considerably. Even
if the raw number is not that huge, it all adds up. And it plays together with other efforts to make leaner Ember builds
possible, like enabling tree shaking with the new <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md">Module API</a>,
moving code from core to addons (e.g. the <a href="https://github.com/emberjs/rfcs/blob/master/text/0236-deprecation-ember-string.md"><code>Ember.String</code> deprecation</a>)
or the <a href="https://github.com/emberjs/rfcs/blob/explode/text/0000-explode.md">&quot;Explode RFC&quot;</a>. In that regard removing the
dependency on jQuery is a rather low hanging fruit with an high impact.</p>
<a class="header" href="print.html#but-this-is-already-possible-why-this-rfc" id="but-this-is-already-possible-why-this-rfc"><h3>But this is already possible, why this RFC?</h3></a>
<p>There is indeed a somewhat quirky way to build an <a href="https://github.com/rwjblue/no-jquery-app">app without jQuery</a> even
today.
Although this <em>happens</em> to work, it is not sufficient to consider this officially supported for these reasons:</p>
<ul>
<li>Ember itself must be fully tested to work without jQuery</li>
<li>the public APIs that depend on and/or expose jQuery need to have some well defined behavior when jQuery is not
available</li>
<li>there should be a way to technically opt-out (other than fiddling with <a href="https://github.com/rwjblue/no-jquery-app/commit/34c40fc2cfc5e2ce0c39e5e906448c46af699d26"><code>vendorFiles</code></a>)
that is easier to use, understand and maintain</li>
<li>addons should mostly default to not use jQuery, to make removing jQuery practically possible for their consuming
apps</li>
</ul>
<a class="header" href="print.html#detailed-design-62" id="detailed-design-62"><h2>Detailed design</h2></a>
<a class="header" href="print.html#remove-internal-jquery-usage" id="remove-internal-jquery-usage"><h3>Remove internal jQuery usage</h3></a>
<p>As of writing this, there are <a href="https://github.com/emberjs/ember.js/issues/16058">major efforts</a> underway to remove and
cleanup the Ember codebase and especially its tests from jQuery usage. Having a way to fully test Ember without jQuery
is a prerequisite to officially support jQuery being optional. When this is done, it will enable a &quot;no jQuery&quot; mode,
that will make it not use jQuery anymore, but only native DOM APIs.</p>
<a class="header" href="print.html#add-an-opt-out-flag" id="add-an-opt-out-flag"><h3>Add an opt-out flag</h3></a>
<p>There should be a global flag that will toggle the optional jQuery integration (true by default). When this is disabled,
it will make Ember CLI's build process <em>not</em> include jQuery into the <code>vendor.js</code> bundle, <em>and</em> it will explicitly put
Ember itself into its &quot;no jQuery&quot; mode.</p>
<p>The flag itself will not be made a public API. Rather it will be handled by a privileged addon, that will allow to
disable the integration flag, thus to opt out from jQuery integration. This approach is in line with
<a href="https://github.com/emberjs/rfcs/pull/278">RFC 278</a> and <a href="https://github.com/emberjs/rfcs/pull/280">RFC 280</a>, to allow
for some better implementation flexibility.</p>
<a class="header" href="print.html#introduce-emberjquery-package" id="introduce-emberjquery-package"><h3>Introduce <code>@ember/jquery</code> package</h3></a>
<p>Currently Ember CLI itself is importing jQuery into the app's <code>vendor.js</code> file. To decouple it from this task, and
to allow for some better flexibility in the future, the responsibility for importing jQuery is moved to a dedicated
<code>@ember/jquery</code> addon.</p>
<p>To not create any breaking changes, Ember CLI will have to check the app's dependencies for the presence of this addon.
If it is not present, it will continue importing jQuery <em>unless</em> the jQuery integration flag is disabled.
If it is present, it will stop importing jQuery at all, and delegate this responsibility to the addon.</p>
<p>To nudge users to install <code>@ember/jquery</code> when they need jQuery, some warning/deprecation messages should be issued when
the addon is <em>not</em> installed and the integration flag is either not specified or is set to true. To ease
migration the addon should be placed in the default blueprint (until an eventual more aggressive deprecation of
jQuery). Only in the case the app is actively opting out of jQuery integration the addon is not needed.</p>
<p>The addon itself has to make sure the Ember CLI version in use is at least the one that introduced the above mentioned
logic, to prevent importing jQuery twice.</p>
<a class="header" href="print.html#assertions-for-jquery-based-apis" id="assertions-for-jquery-based-apis"><h3>Assertions for jQuery based APIs</h3></a>
<p>Apart from testing (see below), Ember features some APIs that directly expose jQuery, which naturally cannot continue
to work without it. For these APIs some assertions have to be added when running in &quot;no jQuery&quot; mode (and not in
production), that provide some useful error messages for the developer:</p>
<ul>
<li><code>Ember.$()</code>
should throw an assertion stating that jQuery is not available.</li>
<li><code>this.$()</code> in components
should throw an assertion stating that jQuery is not available and that <code>this.element</code> and native DOM APIs should be
used instead.</li>
</ul>
<a class="header" href="print.html#introducing-ember-jquery-legacy-and-deprecating-jqueryevent-usage" id="introducing-ember-jquery-legacy-and-deprecating-jqueryevent-usage"><h3>Introducing <code>ember-jquery-legacy</code> and deprecating <code>jQuery.Event</code> usage</h3></a>
<p>Event handler methods in components will usually receive an instance of <a href="http://api.jquery.com/category/events/event-object/"><code>jquery.Event</code></a> as an argument, which is very
similar to native event objects, but not exactly the same. To name a few differences, not all properties of the native
event are mapped to the jQuery event, on the other hand a jquery event has a <code>originalEvent</code> property referencing the
native event.</p>
<p>The updated event dispatcher in Ember 3.0 is capable of working without jQuery (similar to what
<code>ember-native-dom-event-dispatcher</code> provided for Ember 2.x). When jQuery is not available, it will naturally not be
able to pass a <code>jquery.Event</code> instance but a native event instead. This creates some ambiguity for addons, as they
cannot know in advance how the consuming app is built (with or without jQuery).</p>
<p>For code that does not rely on any <code>jQuery.Event</code> specific API, there is no need to change anything as it will continue
to work with native DOM events.</p>
<p>But there are cases where jQuery specific properties have to be used (when jQuery events are passed). This is especially
true for the <code>originalEvent</code> property, for example to access <code>TouchEvent</code> properties that are not exposed on the
<code>jQuery.Event</code> instance itself. So there has to be a way to make the code work with either jQuery events or native
events being passed to the event handler (especially important for addons). Moreover this should be done in a way that
uses native DOM APIs only, to support the migration away from jQuery coupled code.</p>
<p>To solve this issue another addon <code>ember-jquery-legacy</code> will be introduced, which for now will only expose a single
<code>normalizeEvent</code> function. This function will accept a native event as well as a jQuery event (possibly distinguishing
between those two modes at build time, based on the jQuery integration flag), but will always return a native event
only.</p>
<p>This will allow addon authors to work with both event types, but start to only use native DOM APIs:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { normalizeEvent } from 'ember-jquery-legacy';

export default Component.extend({
  click(event) {
    let nativeEvent = normalizeEvent(event);
    // from here on use only native DOM APIs...
  }
})
</code></pre>
<p>To encourage addon authors to refactor their jQuery coupled event code, the use of <code>jQuery.Event</code> specific APIs used for
jQuery events passed to component event handlers should be deprecated and a deprecation message be shown when accessing
them (e.g. <code>event.originalEvent</code>). Care must be taken though that this warning will not be issued when <code>normalizeEvent</code>
has to access <code>originalEvent</code>.</p>
<p>Also for apps that do not want to transition away from jQuery and would be overloaded with unnecessary warnings, the
deprecations should be silenced when the jQuery integration flag is explicitly set to true (and not just true by
default). By doing so users effectively state their desire to continue using jQuery, thus any needless churn should
be avoided for them.</p>
<a class="header" href="print.html#testing-1" id="testing-1"><h3>Testing</h3></a>
<p>Ember's test harness has been based on jQuery for a long time. Most global acceptance test helpers like <code>find</code> or
<code>click</code> rely on jQuery. For integration tests the direct use of jQuery like <code>this.$('button').click()</code> to trigger
events or assert the state of the DOM is still the standard, based on <code>this.$()</code> returning a jQuery object representing
the rendered result of the tests <code>render</code> call.</p>
<p>To be able to reliably run tests in a jQuery-less world, we need to run our tests without jQuery being included,
so our test harness has to work without jQuery as well.</p>
<p>Fortunately this is well underway already. <a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>
introduced native DOM test helpers for integration and acceptance tests as an user space addon. The recent acceptance
testing <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a> provides
similar test helpers, implemented in the <code>@ember/test-helpers</code> package, and envisages deprecating the global test
helpers.</p>
<p>However while the existing jQuery based APIs are still available, when these are used without jQuery they have to throw
an assertion with some meaningful error message:</p>
<ul>
<li>
<p>global acceptance test helpers that expect jQuery selectors (which are a potentially incompatible superset of standard
CSS selectors)</p>
</li>
<li>
<p><code>this.$()</code> in component tests, provided currently by <code>@ember/test-helpers</code> in <code>moduleForComponent</code> and
<code>setupRenderingTest</code></p>
</li>
</ul>
<p>In both cases the error message should state that jQuery is not available and that the native DOM based test helpers
of the <code>@ember/test-helpers</code> package should be used instead.</p>
<p>The transitioning to these new test helpers can be eased through a codemod. For <code>ember-native-dom-helpers</code> there already
exists  <a href="https://github.com/simonihmig/ember-native-dom-helpers-codemod">ember-native-dom-helpers-codemod</a>, which
could be adapted to the very similar RFC 268 based interaction helpers in <code>@ember/test-helpers</code>.</p>
<a class="header" href="print.html#implementation-outline" id="implementation-outline"><h3>Implementation outline</h3></a>
<p>The following outlines how a possible implementation of the jQuery integration flag <em>could</em> look like. This
is just to provide some additional context, but is <em>intentionally not</em> meant to be normative, to allow some flexibility
for the actual implementation.</p>
<p>The addon that will handle the flag is expected to be <a href="https://github.com/emberjs/ember-optional-features">ember-optional-features</a>,
which will read from and write to a <code>config/optional-features.{js,json}</code> file. This will hold the <code>jquery-integration</code>
flag (amongst others). This flag in turn will be added to the <code>EmberENV</code> hash, which will make Ember go into its
&quot;no jQuery&quot; mode when set to <code>false</code>.</p>
<p>Ember CLI and the <code>@ember/jquery</code> addon will also look for <code>jquery-integration</code> in this configuration file, and will
opt-out of importing jQuery when this file is present and the flag is set to <code>false</code>.</p>
<a class="header" href="print.html#how-we-teach-this-42" id="how-we-teach-this-42"><h2>How we teach this</h2></a>
<a class="header" href="print.html#guides" id="guides"><h3>Guides</h3></a>
<p>The existing &quot;Managing Dependencies&quot; chapters in the Ember Guides as well as on ember-cli.com provide a good place to
explain users how to set the jQuery integration flag by means of the mentioned <a href="print.html#add-an-opt-out-flag">privileged addon</a>
that handles this flag.</p>
<p>The section on components should be updated to remove any eventually remaining references to <code>this.$</code>, to not let users
fall into the trap of creating an implicit dependency on jQuery by &quot;accidental&quot; use of it. These should be changed to
refer to their native DOM counterparts like <code>this.element</code> or <code>this.element.querySelector()</code>.</p>
<p>The section on acceptance tests will have been updated as per <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a>
to use the new <code>@ember/test-helpers</code> based test helpers instead of the jQuery based global helpers.</p>
<p>The section on component tests should not use <code>this.$()</code> anymore as well, and instead also according to <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a>
use <code>this.element</code> to refer to the component's root element, and use the new DOM interaction helpers instead of jQuery
events triggered through <code>this.$()</code>.</p>
<a class="header" href="print.html#deprecation-guide" id="deprecation-guide"><h3>Deprecation guide</h3></a>
<p>The deprecation warnings introduced for using <code>jQuery.Event</code> specific APIs should explain the use of the
<code>normalizeEvent</code> helper function to migrate towards native DOM APIs on the one side, and on the other side the effect of
setting the jQuery integration flag to explicitly opt into jQuery usage thus suppressing the warnings.</p>
<a class="header" href="print.html#addon-migration" id="addon-migration"><h3>Addon migration</h3></a>
<p>One of the biggest problems to easily opt-out of jQuery is that many addons still depend on it. Many of these usages
seem to be rather &quot;accidental&quot;, in that the full power of jQuery is not really needed for the given task, and could
be fairly easily refactored to use only native DOM APIs.</p>
<p>For this reason this RFC encourages addon authors to not use jQuery anymore and to refactor existing usages whenever
possible! This certainly does not apply categorically to all addons, e.g. those that wrap jQuery plugins as
components and as such cannot drop this dependency.</p>
<a class="header" href="print.html#ember-try" id="ember-try"><h4>ember-try</h4></a>
<p><code>ember-try</code>, which is used to test addons in different scenarios with different dependencies, should provide some means
to define scenarios without jQuery, based on the jQuery integration flag introduced in this RFC.</p>
<p>Furthermore the Ember CLI blueprint for addons should be extended to include no-jQuery scenarios by default, to make
sure addons don't cause errors when jQuery is not present.</p>
<a class="header" href="print.html#emberobservercom" id="emberobservercom"><h4>emberobserver.com</h4></a>
<p>It would be very helpful to have a clear indication on <a href="https://emberobserver.com/">emberobserver.com</a> which
addons depend on jQuery and which not. This would benefit users as to know which addons they can use without
jQuery, but also serve as an incentive for authors to make their addons work without it.</p>
<p>Given the jQuery integration flag introduced in this RFC, this paves the way to automatically detect addons that are
basically declaring their independence from jQuery by having this flag set to <code>false</code>  (in their own repository).</p>
<a class="header" href="print.html#drawbacks-66" id="drawbacks-66"><h2>Drawbacks</h2></a>
<a class="header" href="print.html#churn-2" id="churn-2"><h3>Churn</h3></a>
<p>A vast amount of addons still depend on jQuery. While as far as this RFC is concerned no jQuery based APIs will be
deprecated and the default will still be to include jQuery, addons are nevertheless encouraged to remove their
dependency on jQuery, which will add some considerable churn to the addon ecosystem. As of writing this, there are:</p>
<ul>
<li><a href="https://emberobserver.com/code-search?codeQuery=Ember.%24">475 addons</a> using <code>Ember.$</code></li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=addon%2Fcomponents">479 addons</a> using <code>this.$</code> in
components</li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=tests">994 addons</a> using <code>this.$</code> in tests</li>
</ul>
<p>Among these are still some very essential addons like <code>ember-data</code>, which still relies on <code>$.ajax</code>, see
<a href="https://github.com/emberjs/data/issues/5320">#5320</a>.</p>
<p>A good amount of that churn can be mitigated by having a codemod that migrates tests (see &quot;Testing&quot; above).</p>
<a class="header" href="print.html#alternatives-67" id="alternatives-67"><h2>Alternatives</h2></a>
<p>Continue to depend on jQuery.</p>
<a class="header" href="print.html#unresolved-questions-48" id="unresolved-questions-48"><h2>Unresolved questions</h2></a>
<p>None so far.</p>
<ul>
<li>2018-01-17</li>
<li>RFC PR: 0297</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/16231</li>
</ul>
<a class="header" href="print.html#deprecation-of-emberlogger" id="deprecation-of-emberlogger"><h1>Deprecation of Ember.Logger</h1></a>
<a class="header" href="print.html#summary-69" id="summary-69"><h2>Summary</h2></a>
<p>This RFC recommends the deprecation and eventual removal of <code>Ember.Logger</code>.</p>
<a class="header" href="print.html#motivation-70" id="motivation-70"><h2>Motivation</h2></a>
<p>There are a variety of features of Ember designed to support old browsers,
features that are no longer needed. <code>Ember.Logger</code> came into being because
the browser support for the console was inconsistent. In some browsers,
like Internet Explorer 9, the console only existed when the developer tools
panel was open, which caused null references and program crashes when run
with the console closed. <code>Ember.Logger</code> provided methods that would route to
the console when it was available.</p>
<p>With Ember 3.x, Ember no longer supports these older browsers, and hence this
feature no longer serves a purpose. Removing it will make Ember smaller and
lighter.</p>
<a class="header" href="print.html#detailed-design-63" id="detailed-design-63"><h2>Detailed design</h2></a>
<p>For the most part, this is a 1:1 substitution of the global <code>console</code> object
for <code>Ember.Logger</code>.</p>
<p>Node only added support for <code>console.debug</code> in Node version 9. Where we wish
to support earlier versions of Node, we will need to use <code>console.log</code>, rather than
<code>console.debug</code>, as the replacement for <code>Logger.debug</code>. Apps and addons
which don't care about Node or are specifying Node version 9 as their minimum can
use <code>console.debug</code>.</p>
<p>Internet Explorer 11 and Edge both require console methods to be bound to the
console object when the developer tools are not showing. This diverges from the
expectations of other browsers. Direct calls to console methods will work correctly,
but constructs which involve explicitly or implicitly binding the console methods to
other objects or using them unbound will fail. This is straightforward to work around.</p>
<p>You can address the issue by binding the method to the console object:</p>
<pre><code class="language-javascript">// Before - assigning raw method to a variable for later use
var print = Logger.log; // assigning method to variable
print('Message');

// After - assigning console-bound method to variable for later use
var print = console.log.bind(console);
print('Message');
</code></pre>
<p>In some cases, you can use rest parameter syntax to avoid the issue entirely:</p>
<pre><code class="language-javascript">// Before
Logger.info.apply(undefined, arguments); // or
Logger.info.apply(null, arguments); // or
Logger.info.apply(this, arguments); // or

// After
console.info(...arguments);
</code></pre>
<a class="header" href="print.html#within-the-framework" id="within-the-framework"><h3>Within the framework</h3></a>
<p>Remove the following direct uses of <code>Ember.Logger</code> from the ember.js and
ember-data projects:</p>
<ul>
<li><code>ember-debug</code>:
<ul>
<li>deprecate (<code>ember-debug\lib\deprecate.js</code>) - <code>Logger.warn</code></li>
<li>debug (<code>ember-debug\lib\index.js</code>) - <code>Logger.info</code></li>
<li>warn (<code>ember-debug\lib\warn.js</code>) - <code>Logger.warn</code></li>
</ul>
</li>
<li><code>ember-routing</code> (<code>ember-routing\lib\system\router.js</code>):
<ul>
<li>transitioned to - <code>Logger.log</code></li>
<li>preparing to transition to - <code>Logger.log</code></li>
<li>intermediate-transitioned to - <code>Logger.log</code></li>
</ul>
</li>
<li><code>ember-testing</code>:
<ul>
<li>Testing paused (<code>ember-testing\lib\helpers\pause_test.js</code>) - <code>Logger.info</code></li>
<li>Catch-all handler (<code>ember-testing\lib\test\adapter.js</code>) - <code>Logger.error</code></li>
</ul>
</li>
<li><code>ember-data</code>:
<ul>
<li><code>tests\test-helper.js</code>- <code>Logger.log</code></li>
</ul>
</li>
</ul>
<p>Adjust all test code that redirects logging and sets it back:</p>
<ul>
<li><code>ember\tests\routing\basic_test.js</code> (adjust)</li>
<li><code>ember-application\tests\system\dependency_injection\default_resolver_test.js</code> (adjust)</li>
<li><code>ember-application\tests\system\logging_test.js</code> (remove?)</li>
<li><code>ember-glimmer\tests\integration\helpers\log-test.js</code> (remove?)</li>
</ul>
<p>Note: None of the uses of <code>Ember.Logger</code> in <code>ember.js</code> or <code>ember-data</code> involve
<code>Ember.debug</code>, so that issue doesn't affect the Ember.js code directly.</p>
<p>Add deprecation warnings to the implementation: <code>ember-console\lib\index.js</code>.
Bear in mind that <code>Ember.deprecate</code> in <code>ember-debug</code> currently calls
<code>Logger.warn</code>, so the <code>ember-debug</code> code should be changed <em>first</em> or adding
the deprecation warning will create a deep recursion.</p>
<p>The <code>Ember.assert</code>, <code>Ember.warn</code>, <code>Ember.info</code>, <code>Ember.debug</code>, and
<code>Ember.deprecate</code> methods suppress their output on production builds.
However, they are suppressing them in the <code>ember-debug</code> module, which
currently consumes <code>Ember.Logger</code>, <em>not</em> by <code>Ember.Logger</code> itself. Hence,
replacing calls to <code>Ember.Logger</code> with direct calls to the console will not
affect this behavior.</p>
<a class="header" href="print.html#add-on-developers" id="add-on-developers"><h3>Add-On Developers</h3></a>
<p>The following high-impact add-ons (9 or 10 or a * on EmberObserver) use
<code>Ember.Logger</code> and should probably be given an early heads-up to adjust
their code to use <code>console</code> before this RFC is implemented. This will limit
the level of pain that their users experience when the deprecation is released.</p>
<p>Add-ons that need to also support Ember 2.x will need to make their console
references conditional on console being &quot;truthy&quot;, of course, to support Internet
Explorer 9.</p>
<p>In the order of their number of references to <code>Ember.Logger</code>:</p>
<ul>
<li><code>ember-concurrency</code> (15)</li>
<li><code>ember-cli-deprecation-workflow</code> (9)</li>
<li><code>ember-stripe-service</code> (9)</li>
<li><code>semantic-ui-ember</code> (7)</li>
<li><code>ember-resolver</code> (6)</li>
<li><code>ember-cli-page-object</code> (4)</li>
<li><code>ember-cli-sentry</code> (3)</li>
<li><code>ember-islands</code> (3)</li>
<li><code>ember-states</code> (3)</li>
<li><code>ember-cli-pagination</code> (2)</li>
<li><code>ember-cli-clipboard</code> (1)</li>
<li><code>ember-cli-fastboot</code> (1)</li>
<li><code>ember-elsewhere</code> (1)</li>
<li><code>ember-i18n</code> (1)</li>
<li><code>ember-simple-auth-token</code> (1)</li>
<li><code>ember-svg-jar</code> (1)</li>
<li><code>liquid-fire</code> (1)</li>
</ul>
<p>For details, see https://emberobserver.com/code-search?codeQuery=Ember.Logger.</p>
<a class="header" href="print.html#how-we-teach-this-43" id="how-we-teach-this-43"><h2>How we teach this</h2></a>
<a class="header" href="print.html#communication-of-change" id="communication-of-change"><h3>Communication of change</h3></a>
<p>We need to inform users that <code>Ember.Logger</code> will be deprecated and in what
release it will occur.</p>
<a class="header" href="print.html#official-code-bases-and-documentation-1" id="official-code-bases-and-documentation-1"><h3>Official code bases and documentation</h3></a>
<p>We do not currently actively teach the use of <code>Ember.Logger</code>. We will need to
remove any passing references to <code>Ember.Logger</code> from the Ember guides
from the Super Rentals tutorial, and anywhere else it appears on the website.</p>
<p>Once it is gone from the code, we also need to verify it no longer appears in
the API listings.</p>
<p>We must provide an entry in the deprecation guide for this change:</p>
<ul>
<li>describing relevant divergences remaining in the handling of the console in
Internet Explorer 11 and Edge browsers.</li>
<li>describing the issue with using console.debug on node versions
earlier than Node 9.</li>
<li>describing alternative ways of dealing with eslint's <code>no-console</code> messages.</li>
</ul>
<a class="header" href="print.html#drawbacks-67" id="drawbacks-67"><h2>Drawbacks</h2></a>
<p>191 add-ons in Ember Inspector are using <code>Ember.Logger</code>. It has been there and
documented for a long time. So this deprecation will cause some level of change
on many projects.</p>
<p>This, of course, can be said for almost any deprecation, and Ember's
disciplined approach to deprecation has been repeatedly shown to ease things.
These particular changes are proving easy to locate and replace by hand. Also,
only twenty of those add-ons have more than six references to <code>Ember.Logger</code>.
If this is characteristic of the user base, the level of effort to make
the change, even by hand, should be very small for most users.</p>
<p>Those using <code>Logger.debug</code> as something different from <code>Logger.log</code> may have
at least a theoretical concern. Under the covers <code>Logger.debug</code> only calls
<code>console.debug</code> if it exists, calling <code>console.log</code> otherwise. The only
platform where the difference between the two is visible in the console is on
Safari. We can encourage folks with a tangible, practical concern about this to
speak up during the comment period, but I don't anticipate this will have much
impact.</p>
<a class="header" href="print.html#alternatives-68" id="alternatives-68"><h2>Alternatives</h2></a>
<ol>
<li>
<p>Leave things as they are, perhaps providing an <code>@ember/console</code> module
interface.</p>
</li>
<li>
<p>Extract <code>Ember.Logger</code> into its own (tiny) <code>@ember/console</code> package as
a shim for users.</p>
</li>
</ol>
<a class="header" href="print.html#unresolved-questions-49" id="unresolved-questions-49"><h2>Unresolved questions</h2></a>
<p>None at this point. The answers from prior drafts have been promoted into the text.</p>
<ul>
<li>Start Date: 2018-02-04</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/300</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#rfc-request-for-comments-process-update" id="rfc-request-for-comments-process-update"><h1>RFC (Request for Comments) Process Update</h1></a>
<a class="header" href="print.html#summary-70" id="summary-70"><h2>Summary</h2></a>
<p>Refine the Ember RFC process and have it apply to all Ember teams.</p>
<a class="header" href="print.html#motivation-71" id="motivation-71"><h2>Motivation</h2></a>
<p>The Ember community has been using the RFC process to great effect over the last few years.
Proposals by both Core and community members are discussed and refined
with the result coming out much stronger.</p>
<p>During this time, the community and the core teams have identified shortcomings
of the RFC process as well as new requirements, which this RFC intends to address:</p>
<a class="header" href="print.html#confusion-between-emberjsrfcs-and-ember-clirfcs" id="confusion-between-emberjsrfcs-and-ember-clirfcs"><h3>Confusion between emberjs/rfcs and ember-cli/rfcs</h3></a>
<p>The Ember project currently has two separate RFC processes for Ember.js and Ember CLI.</p>
<p>This leads to confusion because the community needs to keep track of two different repositories.
For contributors there is the overhead of having to decide where to file their RFC if the proposal involves both projects,
as well as being aware of the differences in the processes.</p>
<a class="header" href="print.html#the-process-does-not-cover-the-entire-project" id="the-process-does-not-cover-the-entire-project"><h3>The process does not cover the entire project</h3></a>
<p>RFCs to emberjs/rfcs and ember-cli/rfcs have traditionally concerned themselves with features or deprecations to Ember.js and Ember CLI respectfully, with some Ember Data proposals in emberjs/rfcs.</p>
<p>We have already begun to use emberjs/rfcs for other initiatives, such as the project-wide Ember.js 2018 Roadmap but have not codified or updated the process to make it clear that it should be used for efforts such as a website redesign,
information architecture suggestions, SEO suggestions, and the like.</p>
<a class="header" href="print.html#lingering-rfcs" id="lingering-rfcs"><h3>Lingering RFCs</h3></a>
<p>Both the emberjs/rfcs and the ember-cli/rfcs repositories have many open issues and pull-requests.
A percentage of these have not been active in the recent past.</p>
<p>We have kept PRs and issues open so people could more easily find the discussions,
but this has instead given a negative impression of staleness, as RFCs linger open without new feedback.</p>
<a class="header" href="print.html#the-process-for-an-rfc-after-it-has-been-accepted" id="the-process-for-an-rfc-after-it-has-been-accepted"><h3>The process for an RFC after it has been accepted</h3></a>
<p>At the moment the process does not specify what happens when an RFC is accepted and merged. This has led to many questions about the status of merged RFCs.</p>
<a class="header" href="print.html#detailed-design-64" id="detailed-design-64"><h2>Detailed design</h2></a>
<a class="header" href="print.html#one-rfc-process-for-all-of-ember" id="one-rfc-process-for-all-of-ember"><h3>One RFC Process for all of Ember</h3></a>
<p>Ember is <a href="https://emberjs.com/team/">organized into teams</a>, with each team being responsible for certain projects.
The RFC process will be a useful tool for all of those projects.
The header of the RFC template will be updated to include a spot to specify the relevant team(s). The header will have &quot;Ember Issue:&quot; removed.</p>
<p>A list of the teams and respective projects will be added to the instructions,
possibly with the addition of per-team instructions on specifics of the project.
Additional templates might be created as well, such a design work template.</p>
<p>Each team will be responsible for reviewing new RFCs and, if an RFC requires work from their team, ensuring that the RFC reflects that.
As it is with the wider community, the RFC process is the time for teams and team members to push back on, encourage, refine, or otherwise comment on proposals.</p>
<a class="header" href="print.html#require-a-core-champion" id="require-a-core-champion"><h3>Require a Core Champion</h3></a>
<p>To make sure that RFCs receive adequate support from the team, Ember CLI has implemented the idea of a champion associated with each RFC.
One goal is that in seeking a champion from the team,
the RFC author starts a dialogue with the team and gets some early feedback.
That champion is then responsible for representing the RFC in team meetings, and for shepherding its progress. We will import a version of this process to emberjs/rfcs:</p>
<p>Each RFC will require a champion from the primary core team to which the RFC has been marked relevant.
The champion must be found by the opener of the RFC or other community member. They are not assigned by the core teams.
The champion will assign themselves on the RFC on Github.
The champion will be responsible for:</p>
<ul>
<li>achieving consensus from the team(s) to move the RFC through the stages of the RFC process.</li>
<li>ensuring the RFC follows the RFC process.</li>
<li>shepherding the planning and implementation of the RFC.
Before the RFC is accepted, the champion may remove themselves.
The champion may find a replacement champion at any time.</li>
</ul>
<p>A section on 'Finding a champion' will be added to the instructions on proposing an RFC.</p>
<a class="header" href="print.html#introduce-the-concept-of-fcp-to-close" id="introduce-the-concept-of-fcp-to-close"><h3>Introduce the concept of &quot;FCP to close&quot;</h3></a>
<p>To address the problem of RFC triage and inactivity, this RFC introduces the concept of FCP to close.</p>
<p>Closing an RFC should be viewed as another triage tool, not as a rejection of the RFC.
Sometimes a rewrite of an RFC would be so fundamental that it would benefit of a fresh discussion in a new thread.
Sometimes the original author is no longer active (Champions should help here as well),
and someone else might want to take over the work in a new RFC.
Sometimes the timing might not be right, or the feature might have been addressed some other way, and yes,
sometimes it might be something that is not aligned with the team's values for the project.</p>
<p>A good example of this is the <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md#motivation">Named Blocks RFC</a>,
which lists in the motivation section previous attempts at similar ideas.</p>
<p>Like the FCP to merge process, once an RFC is marked as FCP to close there will be a period of one week where people can raise new concerns.
After that period of one week, the respective team will review and close the RFC or extend the period for another week.</p>
<a class="header" href="print.html#merge-ember-clirfcs-into-emberjsrfcs" id="merge-ember-clirfcs-into-emberjsrfcs"><h3>Merge ember-cli/rfcs into emberjs/rfcs</h3></a>
<p>We will have a single repository for all Ember Project RFCs.</p>
<p>To achieve merging ember-cli/rfcs into emberjs/rfcs the following will be done:</p>
<ul>
<li>Add to the RFC header to indicate it applies to ember-cli</li>
<li>Copy both active and completed RFC files into <code>text</code> of emberjs/rfcs</li>
<li>Transfer active PRs and Issues to emberjs/rfcs</li>
<li>Archive ember-cli/rfcs</li>
</ul>
<p>There are some concerns about links breaking when we move the files to emberjs/rfcs,
but given the fact that ember-cli/rfcs had the concept of active/completed by moving the files into different folders,
links were already being broken.</p>
<p>The ember-cli/rfcs do not need name or numbering changes, as there is currently no duplicated name.
Going forward, the numbering should be unified by virtue of having a single repository.</p>
<a class="header" href="print.html#track-rfcs-after-they-are-accepted" id="track-rfcs-after-they-are-accepted"><h3>Track RFCs after they are accepted</h3></a>
<p>At the moment it is not clear what happens to an RFC after it has been merged.</p>
<p>This RFC proposes that after an RFC is merged, the relevant teams, guided by the champion,
will plan implementation by creating tracking issues in the relevant projects.</p>
<p>This RFC proposes having a single place to track the implementation of each RFC.
Each RFC will have a header <code>Tracking:</code> that will be filled out with a link. At that link all issues related to that RFC, across all projects and organizations, will be enumerated.</p>
<a class="header" href="print.html#how-we-teach-this-44" id="how-we-teach-this-44"><h2>How We Teach This</h2></a>
<p>To ensure that contributors are updated on the RFC process and the process is clear,
the documentation should be improved in a couple of ways.</p>
<p>The README will be updated to reflect process changes described in this RFC.
We will add checklists to the instructions for each stage of the RFC process to make it very clear what needs to happen.</p>
<a class="header" href="print.html#drawbacks-68" id="drawbacks-68"><h2>Drawbacks</h2></a>
<a class="header" href="print.html#adjustment-period" id="adjustment-period"><h3>Adjustment period</h3></a>
<p>There are active RFCs in ember-cli/rfcs. Moving these discussions would be onerous, so they should be kept there until completion, and no new RFCs accepted.</p>
<a class="header" href="print.html#permalinks-to-ember-clirfcs-proposals" id="permalinks-to-ember-clirfcs-proposals"><h3>Permalinks to ember-cli/rfcs proposals</h3></a>
<p>Moving the RFC files from ember-cli/rfcs (active or completed) to emberjs/rfcs can be seen as a breaking change, and could lead to someone linking to ember-cli/rfcs and then the RFC being updated in emberjs/rfcs. However, ember-cli/rfcs already suffers from a linking problem due to the active/completed folders, as RFCs need to be moved from one to the other even after being accepted.
This could be mitigated by introducing a warning in the RFC text directing people to the new source.</p>
<a class="header" href="print.html#alternatives-69" id="alternatives-69"><h2>Alternatives</h2></a>
<p>None at the moment.</p>
<a class="header" href="print.html#unresolved-questions-50" id="unresolved-questions-50"><h2>Unresolved questions</h2></a>
<p>None at the moment.</p>
<hr />
<a class="header" href="print.html#glossary" id="glossary"><h2>Glossary</h2></a>
<ul>
<li><strong>RFC</strong>: Request For Comments. The process by which a proposal is discussed by the community and then approved by an Ember team.</li>
<li><strong>FCP</strong>: Final Comment Period. Period of one week at the end of which an RFC is to be accepted or rejected by an Ember team. Extended in periods of one week if new concerns are raised.</li>
</ul>
<ul>
<li>Start Date: 2018-02-15</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/308</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#summary-71" id="summary-71"><h1>Summary</h1></a>
<p>Beginning the transition to deprecate the fallback behavior of resolving <code>{{foo}}</code> by requiring the usage of <code>{{this.foo}}</code> as syntax to refer to properties of the templates' backing component. This would be the default behavior in Glimmer Components.</p>
<p>For example, given the following component class:</p>
<pre><code class="language-js">import Component from '@ember/component';
export default Component.extends({
  init() {
    super(...arguments);
    this.set('greeting', 'Hello');
  }
});
</code></pre>
<p>One would refer to the <code>greeting</code> property as such:</p>
<pre><code class="language-hbs">&lt;h1&gt;{{this.greeting}}, Chad&lt;/h1&gt;
</code></pre>
<p>Ember will render &quot;Hello, Chad&quot;.</p>
<p>To make this deprecation tractable, we will provide a codemod for migrating templates.</p>
<a class="header" href="print.html#motivation-72" id="motivation-72"><h1>Motivation</h1></a>
<p>Currently, the way to access properties on a components class is <code>{{greeting}}</code> from a template. This works because the component class is one of the objects we resolve against during the evaluation of the expression.</p>
<p>The first problem with this approach is that the <code>{{greeting}}</code> syntax is ambiguous, as it could be referring to a local variable (block param), a helper with no arguments, a closed over component, or a property on the component class.</p>
<a class="header" href="print.html#exemplar" id="exemplar"><h2>Exemplar</h2></a>
<p>Consider the following example where the ambiguity can cause issues:</p>
<p>You have a component class that looks like the following component and template:</p>
<pre><code class="language-js">import Component from '@ember/component';
import computed from '@ember/computed';

export default Component.extend({
  formatName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  });
});
</code></pre>
<pre><code class="language-hbs">&lt;h1&gt;Hello {{formatName}}!&lt;/h1&gt;
</code></pre>
<p>Given <code>{ firstName: 'Chad', lastName: 'Hietala' }</code>, Ember will render the following:</p>
<pre><code class="language-html">&lt;h1&gt;Hello Chad Hietala!&lt;/h1&gt;
</code></pre>
<p>Now some time goes on and someone adds a <code>formatName</code> helper at <code>app/helpers/fortmatName.js</code> that looks like the following:</p>
<pre><code class="language-js">export default function formatName([firstName, lastName]) {
  return `${firstName} ${lastName}`;
}
</code></pre>
<p>Due to the fact that helpers take precedence over property lookups, our <code>{{formatName}}</code> now resolves to a helper. When the helper runs it doesn't have any arguments so our template now renders the following:</p>
<pre><code class="language-html">&lt;h1&gt;Hello !&lt;/h1&gt;
</code></pre>
<p>This can be a refactoring hazard and can often lead to confusion for readers of the template. Upon encountering <code>{{greeting}}</code> in a component's template, the reader has to check all of these places: first, you need to scan the surrounding lines for block params with that name; next, you check in the helpers folder to see if there is a helper with that name (it could also be coming from an addon!); finally, you check the component's JavaScript class to look for a (computed) property.</p>
<p>Like <a href="https://github.com/emberjs/rfcs/blob/68812bf2d439c6bb77ad491e0159b371b68c5c35/text/0276-named-args.md">RFC#0276</a> made argument usage explicit through the <code>@</code> prefix, the <code>this</code> prefix will resolve the ambiguity and greatly improve clarity, especially in big projects with a lot of files (and uses a lot of addons).</p>
<p>As an aside, the ambiguity that causes confusion for human readers is also a problem for the compiler. While it is not the main goal of this proposal, resolving this ambiguity also helps the rendering system. Currently, the &quot;runtime&quot; template compiler has to perform a helper lookup for every <code>{{greeting}}</code> in each template. It will be able to skip this resolution process and perform other optimizations (such as reusing the internal <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>
object and caches) with this addition.</p>
<p>Furthermore, by enforcing the <code>this</code> prefix, tooling like the <a href="https://github.com/emberwatch/ember-language-server">Ember Language Server</a> does not need to know about fallback resolution rules. This makes common features like <a href="https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition">&quot;Go To Definition&quot;</a> much easier to implement since we have semantics that mean &quot;property on class&quot;.</p>
<a class="header" href="print.html#transition-path-7" id="transition-path-7"><h1>Transition Path</h1></a>
<p>We intend this to be a <em>very slow</em> process as we understand it is a large change. Because of this we will be doing a phased rollout to help guide people in transtion. Below is an outline of how we plan to roll this change out.</p>
<p><strong>Phase 1:</strong></p>
<ul>
<li>Add <a href="https://github.com/ember-template-lint/ember-template-lint/pull/392">template lint rule</a> to <a href="https://github.com/ember-template-lint/ember-template-lint">ember-template-lint</a> as an <strong>opt-in</strong> rule</li>
<li>Document the <a href="https://github.com/dyfactor/dyfactor">codemod infrastructure</a> and <a href="https://github.com/dyfactor/dyfactor-plugin-disambiguate-locals">codemod</a>. Make it available for early adopters</li>
<li>Start updating docs to use <code>this.</code></li>
</ul>
<p><strong>Phase 2:</strong></p>
<ul>
<li>Add the lint rule by default <em>in the apps</em> <code>.template-lintrc.js</code></li>
<li>Complete doc migration to use <code>this.</code></li>
</ul>
<p><strong>Phase 3:</strong></p>
<ul>
<li>Enable the lint rule by default in the <code>recommended</code> config</li>
</ul>
<p><strong>Phase 4:</strong></p>
<ul>
<li>Introduce deprecation <strong>app only</strong> fallbacks</li>
</ul>
<p><strong>Phase 5:</strong></p>
<ul>
<li>Introduce deprecation for <strong>any</strong> fallbacks</li>
</ul>
<p><strong>Phase 6:</strong></p>
<ul>
<li>Rev major to 4.0.0</li>
<li>Add assert for fallback behavior</li>
</ul>
<p><strong>Phase 7:</strong></p>
<ul>
<li>Remove fallback functionality in 4.5, post 4.4.0 LTS</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-45" id="how-we-teach-this-45"><h1>How We Teach This</h1></a>
<p><code>{{this.foo}}</code> is the way to access the properties on the component class. This also aligns with property access in JavaScript.</p>
<p>Since the <code>{{this.foo}}</code> syntax has worked in Ember.Component (which is the only kind of component available today) since the 1.0 series, we are not really in a rush to migrate the community (and the guides, etc) to using the new syntax. In the meantime, this could be viewed as a tool to improve clarity in templates.</p>
<p>While we think writing <code>{{this.foo}}</code> would be a best practice for new code going forward, the community can migrate at its own pace one component at a time. However, once the fallback functionality is eventually removed this will result in a &quot;Helper not found&quot; error.</p>
<a class="header" href="print.html#syntax-breakdown" id="syntax-breakdown"><h2>Syntax Breakdown</h2></a>
<p>The follow is a breakdown of the different forms and what they mean:</p>
<ul>
<li><code>{{@foo}}</code> is an argument passed to the component</li>
<li><code>{{this.foo}}</code> is a property on the component class</li>
<li><code>{{#with this.foo as |foo|}} {{foo}} {{/with}}</code> the <code>{{foo}}</code> is a local</li>
<li><code>{{foo}}</code> is a helper</li>
</ul>
<a class="header" href="print.html#drawbacks-69" id="drawbacks-69"><h1>Drawbacks</h1></a>
<p>The largest downside of this proposal is that it makes templates more verbose, causing developers to type a bit more. This will also create a decent amount of deprecation noise, although we feel like tools like <a href="https://github.com/mixonic/ember-cli-deprecation-workflow">ember-cli-deprecation-workflow</a> can help mitigate this.</p>
<a class="header" href="print.html#alternatives-70" id="alternatives-70"><h1>Alternatives</h1></a>
<p>This pattern of having programming model constructs to distinguish between the backing class and arguments passed to the component is not unique to Ember.</p>
<a class="header" href="print.html#what-other-frameworks-do" id="what-other-frameworks-do"><h2>What Other Frameworks Do</h2></a>
<p>React has used <code>this.props</code> to talk about values passed to you and <code>this.state</code> to mean data owned by the backing component class since it was released. However, this approach of creating a specific object on the component class to mean &quot;properties available to the template&quot;, would likely be even more an invasive change and goes against the mental model that the context for the template is the class.</p>
<p>Vue requires enumeration of <code>props</code> passed to a component, but the values in the template suffer from the ambiguity that we are trying to solve.</p>
<p>Angular relies heavily on the dependency injection e.g. <code>@Input</code> to enumerate the bindings that were passed to the component and relies heavily on TypeScript to hide or expose values to templating layer with <code>public</code> and <code>private</code> fields. Like Vue, Angular does not disambiguate.</p>
<a class="header" href="print.html#introduce-yet-another-sigil" id="introduce-yet-another-sigil"><h2>Introduce Yet Another Sigil</h2></a>
<p>We could introduce another sigil to remove ambiguity. This would address the concern about verbosity, however it is now another thing we would have to teach.</p>
<a class="header" href="print.html#change-resolution-order" id="change-resolution-order"><h2>Change Resolution Order</h2></a>
<p>The other option is to reverse the resolution order to prefer properties over helpers. However this has the reverse problem as described in the exemplar.</p>
<a class="header" href="print.html#do-nothing" id="do-nothing"><h2>Do Nothing</h2></a>
<p>I personally don't think this is an option, since the goal is to provide clarity for applications as they evolve over time and to provide a more concise mental model.</p>
<a class="header" href="print.html#unresolved-questions-51" id="unresolved-questions-51"><h1>Unresolved questions</h1></a>
<p>TBD</p>
<ul>
<li>Start Date: 2018-03-09</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/311</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#angle-bracket-invocation" id="angle-bracket-invocation"><h1>Angle Bracket Invocation</h1></a>
<a class="header" href="print.html#summary-72" id="summary-72"><h2>Summary</h2></a>
<p>This RFC introduces an alternative syntax to invoke components in templates.</p>
<p>Examples using the classic invocation syntax:</p>
<pre><code class="language-hbs">{{site-header user=this.user class=(if this.user.isAdmin &quot;admin&quot;)}}

{{#super-select selected=this.user.country as |s|}}
  {{#each this.availableCountries as |country|}}
    {{#s.option value=country}}{{country.name}}{{/s.option}}
  {{/each}}
{{/super-select}}
</code></pre>
<p>Examples using the angle bracket invocation syntax:</p>
<pre><code class="language-hbs">&lt;SiteHeader @user={{this.user}} class={{if this.user.isAdmin &quot;admin&quot;}} /&gt;

&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<a class="header" href="print.html#motivation-73" id="motivation-73"><h2>Motivation</h2></a>
<p>The original <a href="https://github.com/emberjs/rfcs/pull/60">angle bracket components</a>
RFC focused on capitalizing on the opportunity of switching to the new syntax
as an opt-in to the &quot;new-world&quot; components programming model.</p>
<p>Since then, we have switched to a more iterative approach, favoring smaller
RFCs focusing on one area of improvment at a time. Collectively, these RFCs
have largely accomplished the goals in the original RFC without the angle
bracket opt-in.</p>
<p>Still, separate from other programming model improvements, there is still a
strong desire from the Ember community for the previously proposed angle
bracket invocation syntax.</p>
<p>The main advantage of the angle bracket syntax is clarity. Because component
invocation are often encapsulating important pieces of UI, a dedicated syntax
would help visually distinguish them from other handlebars constructs, such as
control flow and dynamic values. This can be seen in the example shown above –
the angle bracket syntax made it very easy to see the component invocations as
well as the <code>{{#each}}</code> loop, especially with syntax highlight:</p>
<pre><code class="language-hbs">&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<p>This RFC proposes that we adopt the angle bracket invocation syntax to Ember as
an alternative to the classic (&quot;curlies&quot;) invocation syntax.</p>
<p>Unlike the original RFC, the angle bracket invocation syntax proposed here is
purely syntatical and does not affect the semantics. The invocation style is
largely transparent to the invokee and can be used to invoke both classic
components as well as <a href="https://github.com/emberjs/rfcs/pull/213">custom components</a>.</p>
<p>Since the original angle bracket RFC, we have worked on a few experimental
implementation of the feature, both and in Ember and Glimmer. These experiments
allowed us to attempt using the feature in real apps, and we have learned some
valuable insights throught these usage.</p>
<p>The original RFC proposed using the <code>&lt;foo-bar ...&gt;</code> syntax, which is the same
syntax used by web components (custom elements). While Ember components and web
components share a few similarities, in practice, we find that there are enough
differences that causes the overload to be quite confusing for developers.</p>
<p>In addition, the code needed to render Ember components is quite different
from what is needed to render web components. If they share the same syntax,
the Glimmer template compiler will not be able to differentiate between the two
at build time, thus requiring a lot of extra runtime code to support the
&quot;fallback&quot; scenario.</p>
<p>In conclusion, the ideal syntax should be similar to HTML syntax so it doesn't
feel out of place, but different enough that developers and the compiler can
easier tell that they are not just regular HTML elements at a glance.</p>
<a class="header" href="print.html#detailed-design-65" id="detailed-design-65"><h2>Detailed design</h2></a>
<a class="header" href="print.html#tag-name" id="tag-name"><h3>Tag Name</h3></a>
<p>The first part of the angle bracket invocation syntax is the tag name. While
web components use the &quot;dash rule&quot; to distinguish from regular HTML elements,
we propose to use capital letters to distinguish Ember components from regular
HTML elements and web components.</p>
<p>The invocation <code>&lt;FooBar /&gt;</code> is equivalent to <code>{{foo-bar}}</code>. The tag name will
be normalized using the <code>dasherize</code> function, which is the same rules used by
existing use cases, such as service injections. This allows existing components
to be invoked by the new syntax.</p>
<p>Another benefit of the capital letter rule is that we can now support component
names with a single word, such as <code>&lt;Button&gt;</code>, <code>&lt;Modal&gt;</code> and <code>&lt;Tab&gt;</code>.</p>
<blockquote>
<p>Note: Some day, we may want to explore a file system migration to remove the
need for the normalization rule (i.e. also use capital case in filenames).
However, that is out-of-scope for this RFC, as it would require taking into
consideration existing code (like services), transition paths and codemods.</p>
</blockquote>
<a class="header" href="print.html#arguments" id="arguments"><h3>Arguments</h3></a>
<p>The next part of the invocation is passing arguments to the invoked component.
We propose to use the <code>@</code> syntax for this purpose. For example, the invocation
<code>&lt;FooBar @foo=... @bar=... /&gt;</code> is equivilant to <code>{{foo-bar foo=... bar=...}}</code>.
This matches the <a href="https://github.com/emberjs/rfcs/pull/276">named arguments syntax</a>
in the component template.</p>
<p>If the argument value is a constant string, it can appear verbatim after the
equal sign, i.e. <code>&lt;FooBar @foo=&quot;some constant string&quot; /&gt;</code>. Other values should
be enclosed in curlies, i.e. <code>&lt;FooBar @foo={{123}} @bar={{this.bar}} /&gt;</code>.
Helpers can also be used, as in <code>&lt;FooBar @foo={{capitalize this.bar}} /&gt;</code>.</p>
<a class="header" href="print.html#reserved-names-1" id="reserved-names-1"><h4>Reserved Names</h4></a>
<p><code>@args</code>, <code>@arguments</code> and anything that does not start with a lowercase letter
(such as <code>@Foo</code>, <code>@0</code>, <code>@!</code> etc) are reserved names and cannot be used. These
restrictions may be relaxed in the future.</p>
<a class="header" href="print.html#positional-arguments" id="positional-arguments"><h4>Positional Arguments</h4></a>
<p>Positional arguments (<code>{{foo-bar &quot;first&quot; &quot;second&quot;}}</code>) are not supported.</p>
<a class="header" href="print.html#html-attributes" id="html-attributes"><h3>HTML Attributes</h3></a>
<p>HTML attributes can be passed to the component using the regular HTML syntax.
For example, <code>&lt;FooBar class=&quot;btn btn-large&quot; role=&quot;button&quot; /&gt;</code>. HTML attributes
can be interleaved with named arguments (it does not make any difference). This
is a new feature that is not available in the classic invocation style.</p>
<p>These attributes can be accessed from the component template with the new
<code>...attributes</code> syntax, which is available only in element positions, e.g.
<code>&lt;div ...attributes /&gt;</code>. Using <code>...attributes</code> in any other positions, e.g.
<code>&lt;div&gt;{{...attributes}}&lt;/div&gt;</code>, would be a syntax error. It can also be used on
multiple elements in the same template. If attributes are passed but the
component template does not contain <code>...attributes</code> (i.e. the invoker passed
some attributes, but the invokee does not take them), it will be a development
mode error.</p>
<p>It could be thought of that the attributes in the invocation side is stored in
an internal block, and <code>...attributes</code> is the syntax for yielding to this
internal block. Since the <code>yield</code> keyword is not available in element position,
a dedicated syntax is needed.</p>
<p>Classic components (<code>Ember.Component</code>) will implicitly have an <code>...attributes</code>
added to the end of the wrapper element (if <code>tagName</code> is not an empty string),
after any attributes added by the component itself (using <code>attributeBindings</code>,
<code>classNames</code> etc). This means that attributes provided by the caller will
override (replace) those added by the component (except for <code>class</code>, which is
merged).</p>
<a class="header" href="print.html#block" id="block"><h3>Block</h3></a>
<p>A block can be passed to the invokee using the angle bracket invocation syntax.
For example, the invocation <code>&lt;FooBar&gt;some content&lt;/FooBar&gt;</code> is equivalent to
<code>{{#foo-bar}}some content{{/foo-bar}}</code>. As with the classic invocation style,
this block will be accessible using the <code>{{yield}}</code> keyword, or the <code>@main</code>
named argument per the <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">named blocks RFC</a>.</p>
<p>Block params are supported as well, i.e. <code>&lt;FooBar as |foo bar|&gt;...&lt;/FooBar&gt;</code>.</p>
<p>There is no dedicated syntax for passing an &quot;else&quot; block directly. If needed,
that can be passed using the named blocks syntax.</p>
<a class="header" href="print.html#closing-tag" id="closing-tag"><h3>Closing Tag</h3></a>
<p>The last piece of the angle bracket invocation syntax is the closing tag, which
is mandatory. The closing tag should match the tag name portion of the opening
tag exactly. If no block is passed, the self-closing tag syntax <code>&lt;FooBar /&gt;</code>
can also be used (in which case <code>{{has-block}}</code> will be false).</p>
<a class="header" href="print.html#dynamic-invocations" id="dynamic-invocations"><h3>Dynamic Invocations</h3></a>
<p>In additional to the static invocation described above (where the tag name is a
statically known component name), it is also possible to use the angle bracket
invocation syntax for dynamic invocations.</p>
<p>The most common use case is for invoking &quot;contextual components&quot;, as shown in
the first example:</p>
<pre><code class="language-hbs">&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<p>Because <code>Option</code> is the name of a local variable (block param), the <code>&lt;Option&gt;</code>
invocation will invoke the yielded value instead of looking for a component
named &quot;option&quot;.</p>
<p>Similar to curly invocations, most valid Handlebars path expressions are
invokable in this manner:</p>
<pre><code class="language-hbs">{{!-- LOCAL VARIABLES --}}

{{#form-for model=user as |f|}}
  {{f.fieldset}}
    {{f.input name=&quot;username&quot; type=&quot;text&quot;}}
    {{f.input name=&quot;password&quot; type=&quot;password&quot; }}
  {{/f.fieldset}}

  {{!-- is equivilant to --}}

  &lt;f.fieldset&gt;
    &lt;f.input @name=&quot;username&quot; @type=&quot;text&quot; /&gt;
    &lt;f.input @name=&quot;password&quot; @type=&quot;text&quot; /&gt;
  &lt;/f.fieldset&gt;
{{/form-for}}

{{!-- NAMED BLOCKS OR CURRIED COMPONENTS --}}

{{@content}}

{{!-- is equivilant to --}}

&lt;@content /&gt;

{{!-- THIS LOOKUP --}}

{{#this.container}}
  {{this.child}}
{{/this.container}}

&lt;this.container&gt;
  &lt;this.child /&gt;
&lt;/this.container&gt;
</code></pre>
<blockquote>
<p>Note: The <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">named blocks RFC</a>
proposed to use the <code>&lt;@foo&gt;...&lt;/@foo&gt;</code> syntax on the invocation side to mean
providing a block named <code>@foo</code>, which creates a conflict with this proposal.
<a href="https://github.com/emberjs/rfcs/pull/317">RFC #317</a> propose to change the
block-passing syntax to <code>&lt;@foo=&gt;...&lt;/@foo&gt;</code> to avoid this conflict.</p>
</blockquote>
<p>Notably, based on the rules laied out above, the following is perfectly legal:</p>
<pre><code class="language-hbs">{{!-- DON'T DO THIS --}}

{{#let (component &quot;my-div&quot;) as |div|}}
  {{!-- here, &lt;div /&gt; referes to the local variable, not the HTML tag! --}}
  &lt;div id=&quot;my-div&quot; class=&quot;lol&quot; /&gt;
{{/let}}
</code></pre>
<p>From a programming language's perspective, the semantics here is quite clear. A
local variable is allowed to override (&quot;shadow&quot;) another varible on the outer
scope (the &quot;global&quot; scope, in this case), similar to what is possible in
JavaScript:</p>
<pre><code class="language-js">let console = {
  log() {
    alert(&quot;I win!&quot;);
  }
};

console.log(&quot;Hello!&quot;); // shows alert dialog instead of logging to the console
</code></pre>
<p>While this is semantically unambigious, it is obviously very confusing to the
human reader, and we don't recommend anyone actually doing this.</p>
<p>A previous version of this RFC recommended statically disallowing these cases.
However, after giving it more thoughts, we realized it should not be the
programming language's job to dictate what are considered &quot;good&quot; programming
patterns. By statically disallowing arbitrary expressions, it actually makes it
more difficult to learn and understand the underlying programming model.</p>
<p>Instead, we recommend <a href="https://github.com/ember-cli/rfcs/pull/114">including a template linter</a>
in the default stack and defer to the linter to make such recommendations. At
minimum, we recommend liniting against invoking local variables with lowercase
names without a path segment, regarless of whether the name actually collide
with a known HTML tag – human readers of an Ember template should be able to
safely assume lowercase tags refer to HTML.</p>
<p>Eventually, we might want to provide stronger guidance with via the linter. For
example, we may want to recommend capitalizing invokable local variables, as in
<code>&lt;F.Input /&gt;</code>. We will let the community experiment and coalesce around these
conventions before recommending them by default.</p>
<p>Finally, there are two exceptions to the general rule where certain technically
valid Handlebars path expressions are not supported for dynamic invocations:</p>
<ul>
<li>Implicit <code>this</code> lookups (a.k.a. &quot;property fallback&quot; in <a href="https://github.com/emberjs/rfcs/pull/308">RFC #308</a></li>
<li>Slash lookups</li>
</ul>
<p>First, while <code>{{foo}}</code> or <code>{{Foo}}</code> can normally refer to <code>{{this.foo}}</code> or
<code>{{this.Foo}}</code> normally, allowing this implicitly lookup will mean <em>any</em> tag
in the template (i.e. <code>&lt;foo /&gt;</code> or <code>&lt;Foo /&gt;</code>) can possibly refer to a property
on the current <code>this</code> context.</p>
<p>This ambiguity is highly undesirable for both human readers and the compiler,
therefore implicitly <code>this</code> lookup is not allowed in angle bracket invocations.
This explicit form, <code>&lt;this.foo /&gt;</code> and <code>&lt;this.Foo /&gt;</code> is required.</p>
<p>This requirement aligns well with <a href="https://github.com/emberjs/rfcs/pull/308">RFC #308</a>
and the current curly invocation semantics, due to the <a href="https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md#component-helper-shorthand">&quot;dot rule&quot;</a>
that requires a dot in the path. Note that this is actually more restrictive
than the proposed angle bracket invocation semantics, since it is not possible
to invoke a local variable without a dot:</p>
<pre><code class="language-hbs">{{#super-select selected={{this.user.country}} as |option|&gt;
  {{#each this.availableCountries as |country|}}
    {{!-- this is not legal today, since `option` does not contain a dot --}}
    {{#option value=country}}{{country.name}}{{/option}}
  {{/each}}
{{/super-select}}
</code></pre>
<p>We propose to relax that rule to match the proposed angle bracket invocation
semantics (i.e. allowing local variables without a dot, as well as <code>@names</code>,
but disallowing implicit <code>this</code> lookup).</p>
<p>Second, while Handlebars technically allows <code>{{foo/bar}}</code> as an equivilant
alternative to the <code>{{foo.bar}}</code> path lookup (and therefore <code>foo/bar</code> is
technically a valid Handlebars path expression), it will not be supported in
angle bracket invocation. This is both because the <code>/</code> conflicts with the HTML
closing tag syntax, and the fact that Ember overrides that syntax with a
different semantic.</p>
<p>In today's semantics, <code>{{foo/bar}}</code> does not try to lookup <code>this.foo.bar</code> and
invoke it as a component. Instead, it is used as a filesystem scoping syntax.
Since this feature will be rendered unnecessary with <a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">Module Unification</a>,
we recommend apps using &quot;slash components&quot; to migrate to alternatives provided
by Module Unification (or, alternatively, keep using curly invocations for this
purpose).</p>
<a class="header" href="print.html#how-we-teach-this-46" id="how-we-teach-this-46"><h2>How we teach this</h2></a>
<p>Over time, we will switch to teaching angle bracket invocation as the primary
invocation style for components. The HTML-like syntax should make them feel
more familiar for new developers.</p>
<p>Classic invocation is here to stay – the ability to accept positional arguments
and &quot;else&quot; blocks makes them ideal for control-flow like components such as
<code>{{liquid-if}}</code>.</p>
<a class="header" href="print.html#drawbacks-70" id="drawbacks-70"><h2>Drawbacks</h2></a>
<p>Because angle bracket invocation is designed for the future in mind, allowing
angle bracket invocations on classic components might introduce some temporary
incoherence (such as the interaction between the attributes passing feature and
the &quot;inner HTML&quot; semantics). However, in our opinion, the upside of allowing
incremental migration outweighs the cons.</p>
<a class="header" href="print.html#alternatives-71" id="alternatives-71"><h2>Alternatives</h2></a>
<p>We could just stick with the classic invocation syntax.</p>
<ul>
<li>Start Date: 2018-03-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/318</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#array-helper" id="array-helper"><h1><code>array</code> helper</h1></a>
<a class="header" href="print.html#summary-73" id="summary-73"><h2>Summary</h2></a>
<p>This RFC proposes to add an <code>array</code> template helper for creating arrays in templates.</p>
<p>The helper would be invoked as <code>(array arg1 ... argN)</code> and return the value <code>[arg1, ..., argN]</code>. For example, <code>(array 'a' 'b' 'c')</code> would return the value <code>['a', 'b', 'c']</code>.</p>
<a class="header" href="print.html#motivation-74" id="motivation-74"><h2>Motivation</h2></a>
<p>Objects (or hashes) and arrays are the two main data structures in JavaScript. Ember already has a <code>hash</code> helper for building objects, so it makes sense to also include an <code>array</code> helper for building arrays.</p>
<a class="header" href="print.html#detailed-design-66" id="detailed-design-66"><h2>Detailed design</h2></a>
<p>The design is straightforward and mirrors the design of the <code>hash</code> helper. In particular, the important thing to note is that if any of the arguments to the <code>array</code> helper change then an entirely new array will be returned, rather than updating the existing array in place.</p>
<p>The implementation would also mirror the <a href="https://github.com/emberjs/ember.js/blob/ec9f4e5e5f4099a77a73bc5a9aa41916f0d15d6d/packages/ember-glimmer/lib/helpers/hash.ts#L49-L51">implementation of the <code>hash</code> helper</a> and would simply capture the positional arguments instead.</p>
<a class="header" href="print.html#how-we-teach-this-47" id="how-we-teach-this-47"><h2>How we teach this</h2></a>
<p>This helper is not an important part of the programming model and can just be mentioned in the <a href="https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers">API docs</a> like its sibling the <code>hash</code> helper.</p>
<a class="header" href="print.html#drawbacks-71" id="drawbacks-71"><h2>Drawbacks</h2></a>
<p>As usual, adding new helpers increases the surface area of the API and file size but in this case it is justified because the file size change is extremely small and its actually filling an existing hole in the API.</p>
<a class="header" href="print.html#alternatives-72" id="alternatives-72"><h2>Alternatives</h2></a>
<p>This helper could be left to addons, and indeed there are addons that include this helper. It's also trivial to generate
your own <code>array</code> helper with <code>ember generate helper array</code>. Humorously, the default helper blueprint generates a helper that already acts like the <code>array</code> helper ;)</p>
<p>Nevertheless, I believe it's preferable to include this helper in Ember to fill the hole in Ember's API.</p>
<ul>
<li>2018-03-24</li>
<li>RFC PR: 322</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecation-of-embercopy-and-embercopyable" id="deprecation-of-embercopy-and-embercopyable"><h1>Deprecation of Ember.copy and Ember.Copyable</h1></a>
<a class="header" href="print.html#summary-74" id="summary-74"><h2>Summary</h2></a>
<p>This RFC recommends the deprecation and eventual removal of <code>Ember.copy</code> and the <code>Ember.Copyable</code> mixin.</p>
<a class="header" href="print.html#motivation-75" id="motivation-75"><h2>Motivation</h2></a>
<p>A deep-copy mechanism is certainly useful, but it is a general JavaScript problem. Ember itself doesn't need to offer one, especially one that Ember itself isn't using internally. This function and its accompanying mixin arrived with SproutCore, a long time ago, and are not used by Ember itself, even though they currently reside in <code>@ember/object/internals</code>.</p>
<p><code>ember-data</code> uses <code>Ember.copy</code> to do deep-copies. However, the <code>ember-data</code> team finds its needs would be better served by a private deep-copy mechanism that doesn't flow inadvertently through external interfaces into the <code>Ember.copy</code> methods of user-supplied objects. These interfaces are not designed to support deep copies of user-supplied data, and it can raise havoc in the form of hard-to-diagnose bugs, especially in test scenarios.</p>
<p>Since <code>ember</code> and <code>ember-data</code> do not intend to use this mechanism going forward, it would be better to remove it from the Ember codebase and extract it into an add-on for those who wish to continue to use it.</p>
<a class="header" href="print.html#detailed-design-67" id="detailed-design-67"><h2>Detailed design</h2></a>
<p>There are four steps to deprecating any function:</p>
<ul>
<li>logging the deprecation in the call</li>
<li>removal of calls to the function from ember and any add-ons that ship with ember-cli</li>
<li>extraction to an add-on</li>
<li>eventual removal of the feature in the stated release (in this case 4.0.0).</li>
</ul>
<p>This RFC deprecates the <code>copy</code> function and <code>Copyable</code> mixin of <code>@ember/object/internals</code>.</p>
<p>Shallow copies of the form  <code>copy(x)</code>  or <code>copy(x, false)</code> can be replaced mechanically with <code>Object.assign({}, x)</code>. The simplest way to deal with deep copies in any situation depends upon the nature of the data involved.</p>
<a class="header" href="print.html#current-internal-uses" id="current-internal-uses"><h3>Current internal uses</h3></a>
<a class="header" href="print.html#ember-source" id="ember-source"><h4><code>ember-source</code></h4></a>
<p>This following modules in <code>packages/ember-runtime/lib</code> implement the code being deprecated:</p>
<ul>
<li><code>copy.js</code> contains the <code>copy()</code> function that will log the deprecation before executing,</li>
<li><code>mixins/copyable.js</code> provides the <code>Copyable</code> mixin, but it contains no executable code to deprecate.</li>
<li><code>mixins/array.js</code> - The <code>NativeArray</code> mixin extends the <code>Copyable</code> mixin and implements <code>copy()</code>.</li>
</ul>
<p>The following tests in <code>packages/ember-runtime/tests</code> use the implementation above:</p>
<ul>
<li><code>core/copy_test.js</code> tests the <code>copy()</code> method itself.</li>
<li><code>copyable-array/copy-test.js</code> tests the <code>copy()</code> method of a <code>NativeArray</code> for identical results.</li>
<li><code>helpers/array.js</code> provides the arrays used by the <code>NativeArray</code> test above.</li>
<li><code>system/native_array/copyable_suite_test.js</code> tests the independence of the results of deep copying a <code>NativeArray</code></li>
</ul>
<p>The route  <code>packages/ember-routing/lib/system/route.js</code> has one shallow copy, but the test  <code>packages/ember/tests/routing/decoupled_basic_test</code> is using deep copy.</p>
<p>The <code>copy()</code> methods in <code>packages/ember-metal/lib/map.js</code> and  <code>chains.js</code> and their use in <code>meta.js</code>, and  <code>map_test.js</code> are unrelated.</p>
<p>At present, the handling of arrays in <code>Ember.copy</code> is inconsistent. <code>NativeArray</code> uses the <code>Copyable</code> mixin and implements a <code>copy</code> method. When calling <code>Ember.copy</code>, passing a <code>NativeArray</code>, it will note that the passed parameter uses <code>Copyable</code> and call the copy method inside  <code>NativeArray</code>. However, the recursive <code>_copy</code> method that <code>Ember.copy</code> calls for other objects has its own generic mechanism for copying arrays. If <code>copy</code> is passed a non-<code>Copyable</code> object that contains a <code>NativeArray</code> as a member, when the recursion gets to that member, it will use the generic mechanism rather than delegating to the <code>copy</code> method within the  <code>NativeArray</code>.</p>
<p>The recursive  <code>_copy</code> method also has an assertion that will fail if it is called with any <code>EmberObject</code> that is not also <code>Copyable</code>. This assertion occurs before (and hence affects) the code which handles arrays, even though, for arrays, the object's <code>copy</code> method isn't then used.</p>
<p>During the deprecation period, the <code>Ember.copy</code> method and the <code>NativeArray.copy</code> methods will carry a deprecation warning. We will remove <code>Copyable</code> from <code>NativeArray</code> and change  <code>Ember.copy</code> to consistently use the common array copy mechanism to copy arrays rather than sometimes delegating. We will move the assertion that an <code>EmberObject</code> must be  <code>Copyable</code> to the clause that handles non-array objects.</p>
<p>We need a way to deprecate use of the <code>Copyable</code> mixin. If the penalty for adding code in such a common place isn't too high, we could have <code>core_object.extend()</code>  check for <code>Copyable</code> and deprecate accordingly. We will also supply a new eslint warning that flags the deprecated use of <code>Copyable</code>. (This may be our first eslint check for deprecations. We may want to consider adding others at the same time.)</p>
<p>Those using the add-on will need to mechanically adjust any uses of  <code>myArray.copy(deep)</code> to  <code>copy(myArray, deep)</code> in order to avoid the deprecation message.</p>
<p>At the end of this period, we will remove the deprecated copy() method, the Copyable mixin, and the deprecated NativeArray.copy() method.</p>
<a class="header" href="print.html#ember-data" id="ember-data"><h4><code>ember-data</code></h4></a>
<p>The following code in <code>ember-data</code> uses <code>copy()</code>, but only for shallow copies:</p>
<ul>
<li><code>addon/-private/system/model/internal-model.js</code> - one use</li>
<li><code>addon/-private/system/snapshot.js</code> - two uses</li>
<li><code>addon/-private/system/store.js</code> - one use</li>
</ul>
<p>All of the following uses in tests perform deep copies:</p>
<ul>
<li><code>tests/integration/adapter/build-url-mixin-test.js</code> - two uses</li>
<li><code>tests/integration/adapter/rest-adapter-test.js</code> - two uses</li>
<li><code>tests/integration/store-test.js</code> - two uses</li>
<li><code>tests/unit/system/relationships/polymorphic-relationship-payloads-test.js</code> - four uses</li>
</ul>
<p>The <code>copy()</code> methods referenced in <code>addon/-private/system.map.js</code> and  <code>addon/-private/system/relationships/state/relationship.js</code> are unrelated.</p>
<p>It would appear that deep copy is used within these packages only during testing, and generally to ensure fresh test data without side-effects.</p>
<a class="header" href="print.html#current-external-uses" id="current-external-uses"><h3>Current external uses</h3></a>
<p>The key considerations for add-ons or apps looking for an alternative to copy() and Copyable are:</p>
<ul>
<li>Do they call <code>copy()</code> to do shallow copies or deep copies?</li>
<li>If deep copies are being performed, are the objects involved POJOs or are they derived from <code>EmberObject</code>?</li>
<li>Do they provide objects that use the <code>Copyable</code> mixin with <code>copy()</code> methods intended for use in deep copies by other classes?</li>
<li>Is the data you are copying the sort of thing where you can do the copy in its behalf, or does it require collaboration from the object itself? Or are the contents so open-ended that you can't possibly know?</li>
</ul>
<p>Shallow copies are directly supported by ES6. It's easy to perform recursive deep copies for most simple POJOs without delegating work to the object you are copying. For more complex data, you may need some kind of recursive delegation. <code>Copyable</code> is a delegation mechanism, and apps and add-ons that require delegation will probably want to use the proposed add-on.</p>
<p>The Code Search capabilities of emberobserver are a wonderful way to get a glimpse of how code in the wild is using particular features.</p>
<p>A quick search of the top-scoring add-on packages revealed that most, but by no means all, of the uses of <code>copy()</code> in the modules were for shallow copies that can be accomplished using Object.assign, so a lot of the code affected by this deprecation can rely on a simple substitution.</p>
<p>Very few packages used <code>Copyable</code> - only 9 across the whole set - and most used the feature for only one class.   <code>ember-data-copyable</code> is probably most wedded to the mechanism: it delivers a  <code>Copyable</code>-based mixin for asynchronous copying.  <code>ember-data-model-fragments</code> has pretty open-ended properties. These add-ons would be likely to use the proposed add-on moving forward.   <code>ember-restless</code>, and <code>ember-calendar</code> appear more bounded. Any deep copy mechanism for POJOs may meet their needs.</p>
<a class="header" href="print.html#add-on" id="add-on"><h3>Add-on</h3></a>
<p>The add-on will supply the <code>copy()</code> function and the <code>Copyable</code> mixin based on the existing code, modified as indicated above for handling of arrays.</p>
<p>We could treat the add-on as the extraction of a feature from the monolithic <code>ember-source</code>, as was recently done for strings. If we choose to frame it in that way, the naming should follow the conventions set out for extracting elements of Ember into their own packages. If we choose not to frame it that way, then naming is one of the things this section should specify clearly.</p>
<a class="header" href="print.html#how-we-teach-this-48" id="how-we-teach-this-48"><h2>How we teach this</h2></a>
<a class="header" href="print.html#communication-of-change-1" id="communication-of-change-1"><h3>Communication of change</h3></a>
<p>We need to inform users that <code>Ember.copy</code> and <code>Ember.Copyable</code> will be dprecated and in what release it will occur. This notification should also point them to the add-on for those who need it.</p>
<a class="header" href="print.html#official-code-bases-and-documentation-2" id="official-code-bases-and-documentation-2"><h3>Official code bases and documentation</h3></a>
<p>We do not actively teach the use of <code>Ember.copy</code>. It doesn't appear anywhere in our guides, website, or tutorial. Once it is gone from the code, we also need to verify it no longer appears in the API listings.</p>
<p>We must provide an entry in the deprecation guide for this change:</p>
<ul>
<li>describing the use of <code>to = Object.assign({},from)</code> for shallow copies.</li>
<li>pointing out viable alternatives for deep copies.</li>
<li>directing heavy users of deep copies to the addon.</li>
</ul>
<a class="header" href="print.html#drawbacks-72" id="drawbacks-72"><h2>Drawbacks</h2></a>
<p>The primary drawback is the API churn of people pulling it out of their code. However, for most uses, the change will be straightforward, and the add-on will be available for the foreseeable future for those who want to continue with the implementation.</p>
<a class="header" href="print.html#alternatives-73" id="alternatives-73"><h2>Alternatives</h2></a>
<p>We could simply leave it in place as a utility for others to use. Even then, it would make sense to split it out into its own module, as has already been done for strings, so the work would be much the same.</p>
<a class="header" href="print.html#unresolved-questions-52" id="unresolved-questions-52"><h2>Unresolved questions</h2></a>
<p>None at the moment...</p>
<ul>
<li>Start Date: 2018-03-28</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/324</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#summary-75" id="summary-75"><h1>Summary</h1></a>
<p>The aim of this RFC is to deprecate the component's <code>isVisible</code> property.
It is not used by Ember internally and left undefined unless manually set.
It's poorly documented and component visibility it better managed in
template space rather than JS.</p>
<a class="header" href="print.html#motivation-76" id="motivation-76"><h1>Motivation</h1></a>
<p>Setting the isVisible property on a component instance as a way to toggle
the visibility of the component is confusing. The majority of its usage
predates even Ember 1.0.0, and modern Ember applications already completely
avoid using isVisible in favor of simpler conditionals in the template
space.</p>
<p>In addition, when <code>isVisible</code> is used today it often introduces subtle (and
difficult to track down) bugs due to its interaction with the <code>style</code>
attribute (toggling <code>isVisible</code> clobbers any existing content in <code>style</code>).</p>
<p>Simply put, removing <code>isVisible</code> will reduce confusion amongst users.</p>
<a class="header" href="print.html#transition-path-8" id="transition-path-8"><h1>Transition Path</h1></a>
<p>Whenever <code>isVisible</code> is used a deprecation will be issued with a link to
the deprecation guide explaining the deprecation and how to refactor in order
to avoid it.</p>
<p>Given that <code>Component#isVisible</code> is a public API, deprecating now would
schedule for removal in the next major version release (4.0).</p>
<p>There are several options available to hiding elements
such as <code>&lt;div hidden={{boolean}}&gt;&lt;/div&gt;</code>(hidden is valid for all elements
and is semantically correct) or wrapping the component in a template
conditional <code>{{#if}}</code> statement. Components <code>classNames</code> and <code>classNameBindings</code>
could also be used to add hidden classes.</p>
<a class="header" href="print.html#how-we-teach-this-49" id="how-we-teach-this-49"><h1>How We Teach This</h1></a>
<p>The <code>isVisible</code> property is rarely used, the deprecation along with a mention
in a future blog post would be sufficient.</p>
<p>We should consider adding documentation on hiding components to the Ember
guides with the conditional handlebar helper or via the widely supported <code>hidden</code>
attribute.</p>
<pre><code class="language-hbs">{{#if showComponent}}
  {{component}}
{{/if}}

{{! or }}
&lt;div hidden={{isHidden}}&gt;&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#alternatives-74" id="alternatives-74"><h1>Alternatives</h1></a>
<p>An alternative option would be to to keep <code>isVisible</code>.</p>
<ul>
<li>Start Date: (fill me in with today's date, 2018-04-18)</li>
<li>RFC PR: #326</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#ember-data-filter-deprecation" id="ember-data-filter-deprecation"><h1>Ember Data Filter Deprecation</h1></a>
<a class="header" href="print.html#summary-76" id="summary-76"><h2>Summary</h2></a>
<p>Deprecate the <code>store.filter</code> API. This API was previously gated
behind a private <code>ENV</code> variable that was enabled by the addon
<a href="https://github.com/ember-data/ember-data-filter/tree/b62c992186c00dce8cc81f1fb0cf5e2e6fee0f6b#ember-data-filter"><code>ember-data-filter</code></a>.</p>
<a class="header" href="print.html#motivation-77" id="motivation-77"><h2>Motivation</h2></a>
<p>The <code>filter</code> API was a &quot;memory leak by design&quot;. <a href="https://github.com/ember-data/ember-data-filter#recommended-refactor-guide">Patterns exist</a>
with no-worse ergonomics that have better performance and do not incur memory leak penalties.</p>
<p>While the change in ergonomics for end consumers in minimal, the change to <code>ember-data</code> is substantial.
The code for this feature required significant amounts of confusing internal plumbing to ensure that
filters were rerun every time any form of mutation (update, addition, deletion) occurred to any record.</p>
<p>In addition to maintenance costs, this plumbing negatively affects the performance of all <code>RecordArray</code>s,
and slow any operations that count as mutations (such as pushing new records into the store).</p>
<p>By removing this feature, we significantly simplify and streamline the core of <code>Ember Data</code>.</p>
<a class="header" href="print.html#detailed-design-68" id="detailed-design-68"><h2>Detailed design</h2></a>
<p>We will provide 3 new deprecations with links to a <a href="https://github.com/ember-data/ember-data-filter#recommended-refactor-guide">guide on how to refactor</a>.
These deprecations will target <code>3.5</code>, meaning that the <code>ember-data-filter</code> addon will continue to
work and be supported through the release of ember-data <code>3.4</code>.</p>
<p><strong>Deprecation: ember-data-filter:filter</strong></p>
<p>Deprecate the primary case (<code>store.filter('posts', filterFn)</code>).
Instead, users can combine <code>store.peekAll</code> with a computed property.</p>
<p><strong>Deprecation: ember-data-filter:query-for-filter</strong></p>
<p>This deprecation is specific to folks providing a <code>query</code> to be requested the
first time a filter is run. To do this better, users can separate their usage
of <code>filter</code> from their usage of <code>query</code>.</p>
<p><strong>Deprecation: ember-data-filter:empty-filter</strong></p>
<p>In the case that users were creating a <code>filter</code> with no method for filtering by,
a deprecation is printed letting them know that the easiest path forward is to
use <code>peekAll</code>, which would return the same record result set.</p>
<a class="header" href="print.html#how-we-teach-this-50" id="how-we-teach-this-50"><h2>How we teach this</h2></a>
<p>The <code>filter</code> API is rarely used, having been discouraged for many years. A simple post
alerting users to it's deprecation should be sufficient. The refactoring guide is
sufficiently simple that teaching folks a better way should not be much of a hurdle.</p>
<a class="header" href="print.html#drawbacks-73" id="drawbacks-73"><h2>Drawbacks</h2></a>
<p>Minor churn for folks that did use this API; however, the end result will improve the
performance of apps using filters more so than anyone else.</p>
<a class="header" href="print.html#alternatives-75" id="alternatives-75"><h2>Alternatives</h2></a>
<p>There's been some talk of an API for local querying; however, said alternative RFC
would only result in deprecating this API as well.</p>
<a class="header" href="print.html#unresolved-questions-53" id="unresolved-questions-53"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2018-05-01</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecate-usage-of-ember-evented-in-ember-data" id="deprecate-usage-of-ember-evented-in-ember-data"><h1>Deprecate Usage of Ember Evented in Ember Data</h1></a>
<a class="header" href="print.html#summary-77" id="summary-77"><h2>Summary</h2></a>
<p><code>Ember.Evented</code> functionality on <code>DS.Model</code>, <code>DS.ManyArray</code>,
<code>DS.Errors</code>, <code>DS.RecordArray</code>, and <code>DS.PromiseManyArray</code> will be
deprecated and eventually removed in a future release. This includes
the following methods from the
<a href="https://www.emberjs.com/api/ember/2.15/classes/Ember.Evented/methods/on?anchor=off">Ember.Evented</a>
class: <code>has</code>, <code>off</code>, <code>on</code>, <code>one</code>, and <code>trigger</code>. Additionally the
following lifecycle methods on <code>DS.Model</code> will also be deprecated:
<code>becameError</code>, <code>becameInvalid</code>, <code>didCreate</code>, <code>didDelete</code>, <code>didLoad</code>,
<code>didUpdate</code>, <code>ready</code>, <code>rolledBack</code>.</p>
<a class="header" href="print.html#motivation-78" id="motivation-78"><h2>Motivation</h2></a>
<p>The use of <code>Ember.Evented</code> is mostly a legacy from the pre 1.0 days of
Ember Data when events were a core part of the Ember Data programming
model. Today there are better ways to do everything that once needed
events. Removing the usage of the <code>Ember.Evented</code> mixin will make it
easier for Ember Data to eventually transition to using native ES2015
JavaScript classes and will reduce the surface area of APIs that Ember
Data must support in the long term.</p>
<a class="header" href="print.html#detailed-design-69" id="detailed-design-69"><h2>Detailed design</h2></a>
<p><code>Ember.Evented</code> mixin will be scheduled to be removed from the
following classes in a future Ember Data release: <code>DS.Model</code>,
<code>DS.ManyArray</code>, <code>DS.Errors</code>, <code>DS.RecordArray</code>, and
<code>DS.PromiseManyArray</code>.</p>
<p>The <code>has</code>, <code>off</code>, <code>on</code>, <code>one</code>, and <code>trigger</code> methods will be trigger a
deprecation warning when called and will be completly in a future
Ember Data release.</p>
<p>A special deprecation will be logged when users of a
<code>DS.adapterPopulatedRecordArray</code> attempt to listen to the <code>didLoad</code>
event. This depecations will prompt users to use a computed property
instead of the <code>didLoad</code> event.</p>
<p><code>DS.Model</code> will also recieve deprecation warnings when a model is
defined with the following methods: <code>becameError</code>, <code>becameInvalid</code>,
<code>didCreate</code>, <code>didDelete</code>, <code>didLoad</code>, <code>didUpdate</code>, <code>ready</code>,
<code>rolledBack</code>.</p>
<p>When a model is instantiated for the first time with any of these
methods a deprecation warning will be logged notifiying the user that
this method will be deprecated and the user should use an computed or
overide the model's init method instead.</p>
<a class="header" href="print.html#how-we-teach-this-51" id="how-we-teach-this-51"><h2>How we teach this</h2></a>
<p>Today we do not teach the use of any of the Ember Data lifecycle
events in the guides. They are referenced in the API docs but they
will be updated to mark the APIs as deprecated and show alternative
examples of how to achieve the same functionality using a non event
pattern.</p>
<p>The deprecation guide app will be updated with examples showing how to
migrate away from an evented pattern to using a computed or imperative
method to achieve the same results.</p>
<a class="header" href="print.html#drawbacks-74" id="drawbacks-74"><h2>Drawbacks</h2></a>
<p>The drawback to making this change is existing code that takes
advantage of the Ember Data lifecycle events will need to be updated
to use a different pattern.</p>
<a class="header" href="print.html#alternatives-76" id="alternatives-76"><h2>Alternatives</h2></a>
<p>We could leave the <code>Ember.Evented</code> mixin on all of the Ember Data
objects that currently support it and continue to support this
interface for the foreseeable future. However, Ember Data itself
doesn't require these events internally. There is only one place in
the <code>DS.Error</code> code that takes advantage of the <code>Ember.Evented</code> system
and that code can be easilly re-written to avoid <code>Ember.Evented</code> APIs.</p>
<a class="header" href="print.html#unresolved-questions-54" id="unresolved-questions-54"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2018-05-08</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/331</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-78" id="summary-78"><h1>Summary</h1></a>
<p>Deprecate all use of:</p>
<ul>
<li>Ember Globals Resolver (looks up a class via a global namespace such as &quot;App&quot;)</li>
<li>Creation of a Global Namespace (<code>var App = Ember.Namespace.create();</code>)</li>
<li>Ember.TEMPLATES array</li>
<li>&lt;script type=&quot;text/handlebars&quot; data-template-name=&quot;path/to/template&quot;&gt;</li>
</ul>
<p>Use of any of the above should trigger a deprecation warning, with a target
of version 4.0</p>
<a class="header" href="print.html#motivation-79" id="motivation-79"><h1>Motivation</h1></a>
<p>Over the past years we have transitioned to using Ember-CLI as the main way
to compile Ember apps. The globals resolver is a holdover and primarily
facilitates use of Ember without Ember-CLI.</p>
<a class="header" href="print.html#the-globals-resolver" id="the-globals-resolver"><h1>The Globals Resolver</h1></a>
<p>For those who are not aware, the globals resolver is available via <code>@ember/globals-resolver</code> or
<code>Ember.DefaultResolver</code>. For more information, see the
<a href="https://www.emberjs.com/api/ember/release/classes/GlobalsResolver/properties">api</a>.
Using it looks like the following:</p>
<pre><code class="language-js">// app.js
var App = Ember.Application.create();

App.Router.map(function() {
  this.route('about');
});

App.AboutRoute = Ember.Route.extend({
  model: function() {
    return ['red', 'yellow', 'blue'];
  }
});
</code></pre>
<pre><code class="language-html">// index.html
&lt;script type=&quot;text/x-handlebars&quot; data-template-name=&quot;about&quot;&gt;
  &lt;ul&gt;
    {{#each model as |item|}}
      &lt;li&gt;{{item}}&lt;/li&gt;
    {{/each}}
  &lt;/ul&gt;
&lt;/script&gt;
</code></pre>
<a class="header" href="print.html#implementation-details-2" id="implementation-details-2"><h1>Implementation Details</h1></a>
<p>One small detail required to implement this RFC: ember-cli's own default resolver,
<a href="https://github.com/ember-cli/ember-resolver">ember-resolver</a>
currently still extends from the globals resolver.
In order to implement this RFC, the ember-cli resolver will need to be changed
so that it does <em>not</em> extend from the globals resolver, or otherwise ember-cli users
will get a deprecation warning as well.
However, changing the base class of the ember cli classic resolver is a breaking change,
so prior to ember/ember-cli version 4.0 we need to take another step.
In the ember-cli classic resolver, deprecate any runtime calls where there is fallback to the globals mode resolver. This would be a deprecation in ember-cli's resolver. We could bump a major version of ember-cli-resolver removing the base class and release it in ember-cli after an LTS of ember-cli.</p>
<a class="header" href="print.html#transition-path-9" id="transition-path-9"><h1>Transition Path</h1></a>
<p>Primarily, the transition path is to recommend using Ember-CLI.</p>
<p>During the 3.x timeframe, it MAY become increasingly difficult to use this old functionality.
For example, with the release of 3.0, we already stopped publishing builds that support
globals mode. Here are some of the changes that have impacted or may soon impact users of globals mode:</p>
<a class="header" href="print.html#impact-of-es6-modules" id="impact-of-es6-modules"><h2>Impact of ES6 modules</h2></a>
<p>Users of ES6 modules must use their own build tooling to convert them to named AMD modules via Babel.
No support is provided for &lt;script type=&quot;module&quot;&gt; at this time, although that may change.</p>
<a class="header" href="print.html#impact-of-new-module-imports" id="impact-of-new-module-imports"><h2>Impact of New Module Imports</h2></a>
<p>Globals based apps are only able to use new module imports via the polyfill available at
https://github.com/ember-cli/babel-plugin-ember-modules-api-polyfill No build support for this is provided.</p>
<a class="header" href="print.html#impact-of-not-publishing-globals-builds" id="impact-of-not-publishing-globals-builds"><h2>Impact of not publishing globals builds</h2></a>
<p>It is necessary to get a globals build of Ember.js from the npm package now that globals builds
are no longer published to S3, builds.emberjs.com, and CDNs.</p>
<a class="header" href="print.html#impact-of-not-generating-a-globals-build-in-emberjs-package" id="impact-of-not-generating-a-globals-build-in-emberjs-package"><h2>Impact of not Generating a Globals Build in Ember.js Package</h2></a>
<p>At some point during the 3.x cycle, it may be that we no longer publish a globals build in the
npm package. At that point, it may become necessary to use Ember-CLI to generate a globals build
of Ember.js</p>
<a class="header" href="print.html#impact-of-package-splitting" id="impact-of-package-splitting"><h2>Impact of Package Splitting</h2></a>
<p>Work has started on package splitting. It is likely that the globals resolver may not be included
in a default partial build of Ember.js and may be moved to its own package for easy removal.</p>
<a class="header" href="print.html#impact-of-tree-shaking" id="impact-of-tree-shaking"><h2>Impact of Tree Shaking</h2></a>
<p>If the globals resolver is moved to a separate package, it will likely not be included in a build
of Ember.js by default unless tree shaking is turned off.</p>
<a class="header" href="print.html#how-we-teach-this-52" id="how-we-teach-this-52"><h1>How We Teach This</h1></a>
<p>We already do teach this and don't teach the globals resolver. No changes required here.</p>
<a class="header" href="print.html#deprecation-guide-1" id="deprecation-guide-1"><h2>Deprecation Guide</h2></a>
<p>A draft deprecation guide has been pull requested at https://github.com/ember-learn/deprecation-app/pull/155</p>
<a class="header" href="print.html#drawbacks-75" id="drawbacks-75"><h1>Drawbacks</h1></a>
<p>A drawback is that people may want alternate build tooling to Ember-CLI.
We have mitigated this by openly publishing the ember-cli resolver and all parts of the
ember-cli ecosystem under the MIT license.
Alternate build tooling may simply use this open source code to build a competing
infrastructure to ember-cli.</p>
<a class="header" href="print.html#alternatives-77" id="alternatives-77"><h1>Alternatives</h1></a>
<p>Without doing this, we will have to continue to ship and maintain this rarely used functionality.
We don't believe this is a reasonable alternative.</p>
<a class="header" href="print.html#unresolved-questions-55" id="unresolved-questions-55"><h1>Unresolved questions</h1></a>
<p>There has never been a transition guide for transitioning an old codebase to Ember-CLI.
Do we want to create one at this late date?</p>
<ul>
<li>Start Date: 2018-10-24</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/332</li>
<li>Ember Issue:</li>
</ul>
<a class="header" href="print.html#ember-data-record-links--meta" id="ember-data-record-links--meta"><h1>Ember Data Record Links &amp; Meta</h1></a>
<a class="header" href="print.html#summary-79" id="summary-79"><h2>Summary</h2></a>
<p>Enable users to associate <code>links</code> and <code>meta</code> information with individual records
in a manner accessible via the template.</p>
<a class="header" href="print.html#motivation-80" id="motivation-80"><h2>Motivation</h2></a>
<p>Sometimes users have meta or links information to associate with a specific record.
Users of the <code>json-api</code> specification will commonly understand this information as
belonging to an individual <code>resource</code>.</p>
<p>While <code>ember-data</code> allows for this information to exist on relationships, it does
not allow for it to exist on records, which has to this point been a glaring omission
for users of <code>json-api</code> and similar specifications.</p>
<a class="header" href="print.html#detailed-design-70" id="detailed-design-70"><h2>Detailed design</h2></a>
<p>In keeping with the current design of the <code>store.push</code> API which expects the <code>json-api</code> format,
users would include optional <code>meta</code> and <code>links</code> information as member properties of a resource.</p>
<pre><code class="language-js">store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {},
    meta: {
      // ... &lt;any&gt;
    },
    links: {
      self: './person/1', // ... &lt;String&gt;
    }
  }
});
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> will be accepted anywhere a <code>resource</code> may be encountered in a payload.</p>
<pre><code class="language-js">store.push({
  data: [
    {
      type: 'contributor',
      id: '1',
      attributes: {},
      relationships: {
        projects: {
          data: [
            { type: 'project', id: '1' }
          ]
        }
      },
      meta: {
        // ... &lt;any&gt;
      },
      links: {
        self: './person/1', // ... &lt;String&gt;
      }
    }
  ],
  included: [
    {
      type: 'project',
      id: '1',
      attributes: {},
      relationships: {
        contributors: {
          data: [
            { type: 'contributor', id: '1' }
          ]
        }
      },
      meta: {
        // ... &lt;any&gt;
      },
      links: {
        self: './github-projects/1', // ... &lt;String&gt;
      }
    }
  ]
})
</code></pre>
<hr />
<p>Links &amp; Meta on objects used as <code>ResourceIdentifiers</code> (e.g. to link to another resource within a relationship)
will not be used for the associated resource and will be silently ignored.</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {
      projects: {
        data: [
          {
            type: 'project',
            id: '1',         
            meta: {}, // ignored
            links: {} // ignored
          }
        ]
      }
    },
  }
});
</code></pre>
<hr />
<p>Links &amp; Meta on objects provided for <code>Relationships</code> will continue to work (as they do today).</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {
      projects: {
        data: [
          {
            type: 'project',
            id: '1',         
          }
        ],
        meta: {}, // available on the Record's hasMany relationship
        links: {} // available on the Record's hasMany relationship
      }
    },
  }
});
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> properties will be exposed as getters on instances of <code>DS.Model</code> and will default to <code>null</code> if
no <code>meta</code> or <code>links</code> have been provided.</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'person',
    id: '1',
    attributes: { name: '@runspired' },
    meta: {
      expiresDate: '2018-05-10'
    },
    links: {
      self: './people/runspired'
    }
  }
});

record.meta.expiresDate; // '2018-05-10'
record.links.self; // './people/runspired'
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> will similarly be exposed as on instances of <code>Snapshot</code> given to
adapter and serializer methods. In keeping with <code>Snapshot#attributes()</code>, they will
be exposed as methods.  Should users desire to reload a record via link, they could
achieve such by utilizing the <code>links()</code> method to check for a link when making a request.</p>
<pre><code class="language-js">class Snapshot {
  links() {}
  meta() {}
}
</code></pre>
<hr />
<a class="header" href="print.html#the-shared-namespace-problem-and-interop-with-existing-workaround-for-links-and-meta" id="the-shared-namespace-problem-and-interop-with-existing-workaround-for-links-and-meta"><h4>The shared namespace problem and interop with existing workaround for <code>links</code> and <code>meta</code>.</h4></a>
<p>The <code>json-api</code> spec places <code>type</code>, <code>id</code>, and all members of <code>attributes</code> and <code>relationships</code> into
a single shared flattened namespace.  This flattened namespace is what <code>records</code> expose.</p>
<p>The spec does not put <code>links</code> and <code>meta</code> into this namespace, and it is valid to have <code>links</code> and <code>meta</code>
as member names of either <code>attributes</code> or <code>relationships</code>.</p>
<p>Some apps have taken advantage of this to move <code>links</code> and <code>meta</code> into <code>attributes</code> on their serializer
and to expose them via <code>DS.attr</code> on their records.</p>
<p>The <code>getter</code> we are proposing adding to <code>DS.Model</code> would be overwriteable. In the case that there is a
conflict, the version defined by the end user model would win. It would be up to consuming apps to
decide whether they wish to avoid this conflict by renaming the non-resource <code>links</code> and <code>meta</code> either
in their serializer or in their API responses.</p>
<a class="header" href="print.html#how-we-teach-this-53" id="how-we-teach-this-53"><h2>How we teach this</h2></a>
<p>Documentation for <code>DS.Model</code> should be updated to reflect these properties, the potential conflict
(and the default conflict resolution) explained in said documentation, and guides on working with
Models should reflect this capability.</p>
<a class="header" href="print.html#drawbacks-76" id="drawbacks-76"><h2>Drawbacks</h2></a>
<p>Users may sometimes encounter confusion when <code>links</code> or <code>meta</code> is a member of attributes or
relationships.</p>
<a class="header" href="print.html#alternatives-78" id="alternatives-78"><h2>Alternatives</h2></a>
<ul>
<li>
<p>Rename <code>links</code> and <code>meta</code> to a name less likely to collide and which we fully reserve, such as
<code>recordLinks</code> and <code>recordMeta</code>. We felt this would be confusing.</p>
</li>
<li>
<p>Enforce accessing <code>links</code> and <code>meta</code> via some other object such as the <code>Reference</code> API. In addition
to being cumbersome and confusing, this would lack discoverability and be unergonomic in templates.</p>
</li>
<li>
<p>Enforce accessing <code>links</code> and <code>meta</code> via some imported helper, e.g. <code>recordMetaFor(record)</code> or <code>recordLinksFor(record)</code>.
We felt this would be confusing and unergonomic for templates.</p>
</li>
</ul>
<a class="header" href="print.html#unresolved-questions-56" id="unresolved-questions-56"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2018-05-29</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/335</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecate-sendaction" id="deprecate-sendaction"><h1>Deprecate <code>.sendAction</code></h1></a>
<a class="header" href="print.html#summary-80" id="summary-80"><h2>Summary</h2></a>
<p>In old versions of Ember (&lt; 1.13) <code>component#sendAction</code> was the only way for a component to call an
action on a parent scope. In 1.13 with the so called <em>closure actions</em> a more intuitive and flexible
way of calling actions was introduced, yielding the old way redundant.</p>
<a class="header" href="print.html#motivation-81" id="motivation-81"><h2>Motivation</h2></a>
<p>With the new <em>closure actions</em> being the recommended way, <code>component#sendAction</code> is not even
mentioned in the guides.
With the goal of simplifying the framework I think we should remove what is not considered the
current best practice.
<em>Closure actions</em> have been available since 1.13. That is 3 years ago, so deprecating <code>sendAction</code>
should not cause too much pain and yet addons can support still support the last version of the 1.X
cycle if they really want to.</p>
<p>It is out of the scope of this RFC to enumerate the reasons why <em>closure actions</em> are preferred over
<em>sendAction</em> but you can find an in depth explanation of <em>closure actions</em> in <a href="http://miguelcamba.com/blog/2016/01/24/ember-closure-actions-in-depth">this blog post from 2016</a>.</p>
<a class="header" href="print.html#detailed-design-71" id="detailed-design-71"><h2>Detailed design</h2></a>
<p>A deprecation message will appear when <code>sendAction</code> is invoked. The feature will be removed in
Ember 4.0. The deprecation message will use the arguments passed to <code>sendAction</code> to generate a dynamic
explanation that will make super-easy for developers to migrate to closure actions.</p>
<p>As it is mandatory with new deprecations, a new entry in the deprecation guides will be added
explaining the migration path in depth.</p>
<p>To refresh what the migration path would look like in the typical use case.</p>
<p><strong>BEFORE</strong></p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=&quot;sayHi&quot;}}
</code></pre>
<pre><code class="language-js">// child-component.js
export default Component.extend({
  actions: {
    sendSalute() {
      this.sendAction('salute');
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button {{action &quot;sendSalute&quot;}}&gt;Send salute&lt;/button&gt;
</code></pre>
<p><strong>AFTER</strong></p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=(action &quot;sayHi&quot;)}}
</code></pre>
<pre><code class="language-js">// child-component.js
export default Component.extend({
  actions: {
    sendSalute() {
      this.salute();
      // if the salute action is optional you'll have to guard in case it's undefined:
      // if (this.salute) {
      //   this.salute()
      // }
      // 
      // Alternatively, you can also define a noop salute function:
      // salute() {}
      //
      // This allows you to remove the guard while provinding an obvious place to add
      // docs for that action.
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button {{action &quot;sendSalute&quot;}}&gt;Send salute&lt;/button&gt;
</code></pre>
<p>However <em>closure actions</em> allow to be less verbose, so the same behavior could be attained using
less intermediate calls</p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=(action &quot;sayHi&quot;)}}
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button onclick={{@salute}}&gt;Send salute&lt;/button&gt;
</code></pre>
<a class="header" href="print.html#how-we-teach-this-54" id="how-we-teach-this-54"><h2>How we teach this</h2></a>
<p>There are no new concepts to teach, but the removal of an old concept now considered outdated.</p>
<a class="header" href="print.html#drawbacks-77" id="drawbacks-77"><h2>Drawbacks</h2></a>
<p>There might be some churn following the deprecation, specially comming from addons that haven't been
updated in a while.
Addons that want to support the latest versions of Ember without deprecation messages and still work
past Ember 1.13 will have to do some gymnastics to do so.</p>
<a class="header" href="print.html#alternatives-79" id="alternatives-79"><h2>Alternatives</h2></a>
<p>Wait longer to deprecate it and keep <code>sendAction</code> undocumented until it's usage is yet more minoritary
than it is today, to lower the churn.</p>
<ul>
<li>Start Date: 2018-06-14</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/337</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/pull/16795</li>
</ul>
<a class="header" href="print.html#native-class-constructor-update" id="native-class-constructor-update"><h1>Native Class Constructor Update</h1></a>
<a class="header" href="print.html#summary-81" id="summary-81"><h2>Summary</h2></a>
<p>Update the behavior of EmberObject's constructor to defer object
initialization.</p>
<a class="header" href="print.html#motivation-82" id="motivation-82"><h2>Motivation</h2></a>
<p>Using native class syntax with EmberObject has almost reached full feature
parity, meaning soon we'll be able to ship native classes and begin recommending
them. This will do wonders for the Ember learning story, and will bring us in
line with the wider Javascript community.</p>
<p>However, early adopters of native classes have experienced some serious
ergonomic issues due to the current behavior of the class constructor. The issue
is caused by the fact that properties passed to <code>EmberObject.create</code> are
assigned to the instance in the root class <code>constructor</code>. Due to the way that
native class fields work, this means that they are assigned <em>before</em> any
subclasses' fields are assigned, causing subclass fields to overwrite any value
passed to <code>create</code>:</p>
<pre><code class="language-js">class Foo extends EmberObject {
  bar = 'baz';
}

let foo = Foo.create({ bar: 'something different' });

console.log(foo.bar); // 'baz'
</code></pre>
<p>This has made adoption very difficult, and is a consistent stumbling block for
new users of native class syntax in Ember. Worse yet, it makes writing a codemod
for converting to native class syntax very difficult because we don't have a
clear target.</p>
<p>For instance, given the above class, how would we convert the class field? Let's
go through the various options:</p>
<pre><code class="language-js">class Foo extends EmberObject {
  // Does not work, for the reasons described above
  bar = 'baz';

  // Does not cover all cases. If we did `Foo.create({ bar: false })` it would
  // still assign the default.
  bar = this.bar || 'baz';

  // This works, but is very verbose and not ideal
  bar = this.hasOwnProperty('bar') ? this.bar : 'baz';

  // This is one of the community accepted solutions, but it requires lodash
  bar = _.defaultTo(this.bar, 'baz');

  // This is another community accepted solution, but it requires
  // @ember-decorators/argument, which is a separate library
  @argument foo = 'bar';
}
</code></pre>
<p>None of these is ideal. Instead, we can change the behavior of the constructor
and the <code>create</code> method to circumvent this issue.</p>
<p>This change <em>would</em> be a breaking change to the behavior of native classes
today, and a change from the previous class RFC. This will impact early adopters
and should be made with that in mind. It would <em>not</em> be a change that breaks the
behavior of the community solutions to class fields mentioned above, and all
other changes would be relatively easy to create a safe codemod for (essentially
converting <code>constructor</code> -&gt; <code>init</code> in affected classes), so the impact <em>should</em>
be minimal.</p>
<p>Because native classes never officially shipped as part of Ember's public API
(an announcement was not made, docs have not been written, etc), this RFC
proposes that the change would <em>not</em> be considered a breaking change <em>for the
purposes of semver</em>. This would allow us to ship the change during the Ember v3
release cycle, and prevent more code from being built on top of the previous
behavior.</p>
<a class="header" href="print.html#detailed-design-72" id="detailed-design-72"><h2>Detailed design</h2></a>
<p>One very important design constraint to making this change is that we <em>cannot</em>
break the behavior of EmberObject when used <em>without</em> native classes. To do
this, we will leverage the fact that the static <code>create</code> method is the only
public way to create an instance of EmberObject.</p>
<p>Currently, the behavior of EmberObject is the following (simplified):</p>
<pre><code class="language-js">class EmberObject {
  constructor(props) {
    // ..class setup things

    Object.assign(this, props);
    this.init();
  }

  static create(props) {
    let instance = new this(props);

    return instance;
  }
}
</code></pre>
<p>We can change it to the following (simplified):</p>
<pre><code class="language-js">class EmberObject {
  constructor(props) {
    // ..class setup things
  }

  static create(props) {
    let instance = new this(props);

    Object.assign(instance, props);
    instance.init();

    return instance;
  }
}
</code></pre>
<p>This would assign the properties <em>after</em> all of the class fields for any
subclasses have been assigned. Revisiting our previous example, the following
two class declarations would effectively be equivalent:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: 'baz'
});

class Foo extends EmberObject {
  bar = 'baz';
}
</code></pre>
<p>Much easier to codemod! There are other subtle differences between native class
fields and EmberObject properties, such as the fact that class fields are
assigned each time a class is initialized, but these are easier to work around.</p>
<a class="header" href="print.html#injections-and-the-init-hook" id="injections-and-the-init-hook"><h3>Injections and the <code>init</code> hook</h3></a>
<p>One side effect of this change is that injections will not be available on the
class instance during the <code>constructor</code> phase. This behavior is not very
commonly used - based on an informal community survey we found only a few usages
- but it <em>does</em> exist and have its use cases.</p>
<p>Figuring out the ideal behavior of injections during the constructor phase is
outside of the scope of this RFC, and is something that should be discussed in
future RFCs. For the time being, users can still rely on the <code>init</code> hook, which
will continue to be called after all injections and properties have been
assigned to the instance.</p>
<a class="header" href="print.html#new-emberobject" id="new-emberobject"><h3><code>new EmberObject()</code></h3></a>
<p>It was previously possible to use <code>new</code> syntax with EmberObject. While this
was not considered public API, it has technically worked and been under test
since the early days of Ember, and may fall under the category of intimate API.
Ideally, we would deprecate this usage as a private/intimate API, which would
mean supporting it through the next LTS version, and dropping support after
(currently, this would mean dropping it at <code>v3.5.0</code>).</p>
<p>We can continue to support this behavior in a backwards compatible way while
deprecating it with one final tweak to the change above:</p>
<pre><code class="language-js">const DEFER_INIT = new Symbol();

function initialize(instance, props) {
  Object.assign(instance, props);
  instance.init();
}

class EmberObject {
  constructor(props, maybeDefer) {
    // ..class setup things

    if (maybeDefer === DEFER_INIT) {
       return this;
    }

    deprecate('using `new` with EmberObject has been deprecated. Please use `create` instead.', false, {
      id: 'object.new-constructor',
      until: '3.5.0'
    });

    initialize(this, props);
  }

  static create(props) {
    let instance = new this(props, DEFER_INIT);
    initialize(instance, props);

    return instance;
  }
}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-55" id="how-we-teach-this-55"><h2>How we teach this</h2></a>
<p>If this PR is accepted, most of the major issues with classes will have been
resolved. We can begin working on a codemod to make converting easier, and move
toward officially making native classes a finalized part of the public API of
Ember. Pending decorators and class fields moving to a late enough stage in the
TC39 process, we can also begin converting the guides to use native class
syntax.</p>
<p>We can document the exact behavior of the new constructor in the API docs for
EmberObject. Most details won't have to change since this change only affects
native class syntax, which has not been documented much officially. We can also
demonstrate the behaviors of classes throughout the guides and API docs.</p>
<p>One thing we should make clear is that EmberObject will likely be deprecated
in the near future, and that ideally for non-Ember classes (things that aren't
Components, Services, etc.) users should drop EmberObject altogether and use
native classes only.</p>
<a class="header" href="print.html#drawbacks-78" id="drawbacks-78"><h2>Drawbacks</h2></a>
<p>This would be a breaking change that could negatively affect early adopters.</p>
<a class="header" href="print.html#alternatives-80" id="alternatives-80"><h2>Alternatives</h2></a>
<ul>
<li>
<p>We could leave the behavior as is, and choose a method for defaulting to
standardize on.</p>
</li>
<li>
<p>We could make this change behind a feature flag and require users to opt-in
to the new behavior, like optional features that currently exist. This would
have to be a build time feature flag, since the area is very performance
sensitive. Given native classes are not yet public API, if we were to do this we
should probably still default to enabling the new behavior and recommending it
as the preferred path.</p>
</li>
<li>
<p>We could not deprecate <code>new EmberObject</code> altogether, and instead only
deprecate passing properties to the constructor. While this would work as a
temporary solution, it may also encourage users to continue using EmberObject
instead of switching to native classes, which is ultimately the long term goal.</p>
</li>
</ul>
<a class="header" href="print.html#unresolved-questions-57" id="unresolved-questions-57"><h2>Unresolved questions</h2></a>
<p>How do we handle DI during the construction phase?</p>
<ul>
<li>Start Date: 2018-06-19</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/340</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecate-embermerge-in-favor-of-emberassign" id="deprecate-embermerge-in-favor-of-emberassign"><h1>Deprecate Ember.merge in favor of Ember.assign</h1></a>
<a class="header" href="print.html#summary-82" id="summary-82"><h2>Summary</h2></a>
<p>The goal of this RFC is to remove <code>Ember.merge</code> in favor of using <code>Ember.assign</code>.</p>
<a class="header" href="print.html#motivation-83" id="motivation-83"><h2>Motivation</h2></a>
<p><code>Ember.assign</code> has been around quite awhile, and has the same functionality as <code>Ember.merge</code>.
With that in mind, we should remove the old <code>Ember.merge</code>, in favor of just having a single function.</p>
<a class="header" href="print.html#detailed-design-73" id="detailed-design-73"><h2>Detailed design</h2></a>
<p>Ember will start logging deprecation messages that tell you to use <code>Ember.assign</code> instead of <code>Ember.merge</code>.</p>
<p>The exact deprecation message will be decided later, but something along the lines of:</p>
<pre><code>Using `Ember.merge` is deprecated. Please use `Ember.assign` instead. If you are using a version of
Ember &lt;= 2.4 you can use [ember-assign-polyfill](https://github.com/shipshapecode/ember-assign-polyfill) to make `Ember.assign`
available to you.
</code></pre>
<a class="header" href="print.html#how-we-teach-this-56" id="how-we-teach-this-56"><h2>How we teach this</h2></a>
<p>This should be a simple 1 to 1 conversion, and the deprecation message should be clear enough for all to
understand what they need to do, and convert all usages of <code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<a class="header" href="print.html#deprecation-guide-2" id="deprecation-guide-2"><h3>Deprecation Guide</h3></a>
<p>An entry to the <a href="https://emberjs.com/deprecations/">Deprecation Guides</a> will be added outlining the conversion from
<code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<p><code>Ember.merge</code> predates <code>Ember.assign</code>, but since <code>Ember.assign</code> has been released, <code>Ember.merge</code> has been mostly unnecessary.
To cut down on duplication, we are now recommending using <code>Ember.assign</code> instead of <code>Ember.merge</code>. If you are using a version of
Ember &lt;= 2.4 you can use <a href="https://github.com/shipshapecode/ember-assign-polyfill">ember-assign-polyfill</a> to make <code>Ember.assign</code>
available to you.</p>
<p>Before:</p>
<pre><code class="language-js">import { merge } from '@ember/polyfills';

var a = { first: 'Yehuda' };
var b = { last: 'Katz' };
merge(a, b); // a == { first: 'Yehuda', last: 'Katz' }, b == { last: 'Katz' }

</code></pre>
<p>After:</p>
<pre><code class="language-js">import { assign } from '@ember/polyfills';

var a = { first: 'Yehuda' };
var b = { last: 'Katz' };
assign(a, b); // a == { first: 'Yehuda', last: 'Katz' }, b == { last: 'Katz' }
</code></pre>
<a class="header" href="print.html#codemod" id="codemod"><h3>Codemod</h3></a>
<p>A codemod will be provided to allow automatic conversion of <code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<a class="header" href="print.html#drawbacks-79" id="drawbacks-79"><h2>Drawbacks</h2></a>
<p>The only drawback, that I can think of, is people would need to convert <code>Ember.merge</code> to
<code>Ember.assign</code>, but this would be a very easy change and could easily be done via codemod.</p>
<a class="header" href="print.html#alternatives-81" id="alternatives-81"><h2>Alternatives</h2></a>
<p>The impact of not doing this, is we continue to have two functions that do basically the same thing,
which we need to maintain.</p>
<p>Another alternative, could be to remove both <code>Ember.merge</code> and <code>Ember.assign</code>, in favor of <code>Object.assign</code>
or something similar.</p>
<a class="header" href="print.html#unresolved-questions-58" id="unresolved-questions-58"><h2>Unresolved questions</h2></a>
<p>None, that I can think of.</p>
<ul>
<li>Start Date: 07/11/2018</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/345</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#rfc-to-move-the-ember-community-chat-to-discord" id="rfc-to-move-the-ember-community-chat-to-discord"><h1>RFC to move the Ember community chat to Discord</h1></a>
<a class="header" href="print.html#summary-83" id="summary-83"><h2>Summary</h2></a>
<p>Encourage the Ember community to adopt Discord for real-time chat (vs Slack or other options).</p>
<a class="header" href="print.html#motivation-84" id="motivation-84"><h2>Motivation</h2></a>
<p>Real-time chat is essential to the function of online communities, particularly in open source. Chat fosters an informal, interactive style of communication that is important for building relationships, sharing community norms, coordinating on projects, and brainstorming ideas.</p>
<p>The Ember community predominantly uses <a href="https://ember-community-slackin.herokuapp.com/">a Slack instance</a> as the gathering place of choice. While we have benefited enormously from Slack, there are significant downsides as well.</p>
<a class="header" href="print.html#loss-of-history" id="loss-of-history"><h3>Loss of History</h3></a>
<p>Because we use Slack's free plan, the entire instance is limited to 10,000 messages in history at any time. Because of this hard cap, the amount of time messages persist continues to shrink as the community grows.</p>
<p>It's hard to quantify exactly how painful this limitation is, as it means that new community members can't search for the answer to a question that was likely answered in the past. We can never go back to reference how or when a decision was made, which can mean decision-making feels less transparent that it should be.</p>
<p>This limit applies not just to chat messages, but direct messages between community members as well. This leads to annoyance, as people have to ask for the same information over again if they forgot to save it, or data loss, as useful things like code snippets vanish into the ether.</p>
<a class="header" href="print.html#performance" id="performance"><h3>Performance</h3></a>
<p>The architecture of the Slack native application relies on running a separate web application per Slack instance the user is signed into. For users who need to be in multiple Slack instances, this can add up to a significant tax on computer resources, particularly as the application starts up.</p>
<p>Once Slack is up and running, most people generally find the performance reasonable, but a solution that offers better startup and runtime performance would be ideal.</p>
<a class="header" href="print.html#privacy-concerns" id="privacy-concerns"><h3>Privacy Concerns</h3></a>
<p>Slack is very clear that their target audience is companies, who often have strict compliance rules that they must follow. Unfortunately, those needs are often at odds with concerns about privacy in an open source community.</p>
<p>In particular, Slack recently added a feature called Corporate Export that theoretically allows administrators to export all messages, including private messages, without notifying users.</p>
<p>Now, the odds of this feature being abused are extremely low. It is only available on Slack's Plus plan, which means a malicious actor would need to be granted administrator priveleges, pony up at least $150,000 to upgrade our Slack plan for that month, apply for the the Corporate Export feature, have it granted by Slack, and then perform an export without anyone noticing.</p>
<p>Because the difficulty of exploiting this feature for evil is so remote, it's not a primary concern driving this change. But all things being equal, we prefer a solution that doesn't offer export of private messages at all, so it's never a concern at the back of someone's mind.</p>
<a class="header" href="print.html#better-communication--transparency" id="better-communication--transparency"><h3>Better Communication &amp; Transparency</h3></a>
<p>Out of frustration with Slack's disappearing messages, the Ember.js core team set up a Discord server to evaluate if it might be a better fit for open source communities.</p>
<p>While this was a public Discord server that anyone could sign up for, its existence was not widely publicized because we were unsure if Discord was the right solution.</p>
<p>Over time, the core team and many contributors gravitated towards the Discord, finding that it served our needs better. Because of how valuable the Slack instance is, no one wanted to propose a move to Discord until a plan (like, say, this RFC) could be put in place.</p>
<p>Unfortunately, this state of affairs has had several undesirable outcomes.</p>
<p>First, it has caused many of the most prolific contributors to be less active in Slack. This may give the appearance of stagnation or disinterest, when momentum on Ember has never been higher. It robs lurkers of the ability to become contributors if a good opportunity to help pops up. And it prevents some of the most experienced members of the community from being around to help answer questions they might have an off-hand answer to.</p>
<p>Second, and perhaps worst of all, it undermines the transparency and open governance that we have worked hard to create. Our bar is higher than just making it possible to contribute—we go out of our way to actively welcome and encourage everyone to participate, learn and contribute.</p>
<p>Finally, this is not intended to replace <a href="https://discuss.emberjs.com/">the forum</a>, and that should be made clear. The forum is still the preferred place for asyncronous, threaded conversations where in-depth discussion is desired.</p>
<a class="header" href="print.html#detailed-design-74" id="detailed-design-74"><h2>Detailed design</h2></a>
<a class="header" href="print.html#transition-plan-8" id="transition-plan-8"><h3>Transition Plan</h3></a>
<p>We will need these things to transition the community smoothly:</p>
<ul>
<li>a period of time when we use both chat platforms during the transition, put the equivalent Discord channel information in the Slack channel topic</li>
<li>a clear guide (with illustrations)</li>
<li>once all of the setup is complete, the Discord server invites can be distributed.</li>
</ul>
<p>Note: the current Discord chat will be closed while this RFC is under consideration. If the RFC is accepted, then a detailed implementation plan (mostly role/channel/server setup) &amp; invitation strategy will be carried out.</p>
<a class="header" href="print.html#initial-setup" id="initial-setup"><h4>Initial Setup</h4></a>
<p>Because Discord has fine-grained controls, we will be able to implement categories for chats.</p>
<p>We intend to have the &quot;welcome&quot; channel as the initial channel for everyone who joins the Discord server. This channel will be read-only and will list the rules for the Discord server.</p>
<p>We also intend to have a &quot;setup&quot; channel. This channel will give you a complete guide of how to take advantage of the personalization, privacy and security, and notification controls in Discord.</p>
<p><strong>Verification Level</strong>
Initially, we will be implementing the &quot;low&quot; verification level, which means users will need to have a verified email on their Discord account. If this proves to be too easy of a target for spammers, we will implement a higher level of verification (levels include amount of time a user has to be a verified member of the server before they can post).</p>
<p><strong>Explicit Content Filter</strong>
Since this is a public Discord server, we will be setting an explicit content filter- it will scan messages from all members without a role. Email-verified members will be given a community member role to start, and other roles may be added to users over time.</p>
<p><strong>Categories and Channels</strong>
Community members will then have the option of visiting the &quot;setup&quot; channel and learning more about fine-grained controls, such as:</p>
<ul>
<li>notifications</li>
<li>muting a channel</li>
<li>muting a category</li>
</ul>
<p>Because our goal is transparency, all of the channels that exist will be visible in the channel list. A lock icon will display if the user does not have the role necessary to join that channel. (<em>FWIW, the alternative is to not display locked channels at all, which we felt would be less ideal- it is better to know that there are channels where private conversations are necessary and see what they are.</em>)</p>
<p>The following proposed initial category and channel list was chosen based on the current channel needs and evaluation of the channels with the most members on Slack. <em>Additional channels may be requested in the Admin/community-feedback channel.</em></p>
<p><strong>Category/Channel List:</strong></p>
<ul>
<li>(No Category)
<ul>
<li>welcome (community guidelines are posted here) &lt;--readonly &amp; the server invite puts users in this channel first.</li>
<li>setup-profile (how to setup your profile) &lt;--readonly</li>
</ul>
</li>
<li>Admin
<ul>
<li>community-feedback (questions, comments, concerns, requests)</li>
<li>security</li>
<li>steering-committee 🔒 (locked to role “steering-committee”)</li>
<li>news &amp; announcements</li>
<li>ember-jobs</li>
<li>bots</li>
</ul>
</li>
<li>Core Teams
<ul>
<li>ember-js 🔒 (locked to role “core-js”)</li>
<li>ember-data 🔒 (locked to role “core-data”)</li>
<li>ember-cli 🔒 (locked to role “core-cli”)</li>
<li>ember-learning 🔒 (locked to role “core-learning”)</li>
</ul>
</li>
<li>Working on Ember
<ul>
<li>ember-cli</li>
<li>ember-data</li>
<li>ember-engines</li>
<li>ember-js</li>
<li>glimmer-vm</li>
<li>triage</li>
<li>st-* (as needed)</li>
</ul>
</li>
<li>Using Ember
<ul>
<li>general-help</li>
<li>learning-ember</li>
<li>a11y</li>
<li>backend</li>
<li>internationalization</li>
<li>jsonapi</li>
<li>mobile</li>
<li>ember-js</li>
<li>ember-data</li>
<li>ember-cli</li>
<li>ember-engines</li>
<li>fastboot</li>
<li>ember-twiddle</li>
<li>e-*</li>
</ul>
</li>
<li>Supporting Ember
<ul>
<li>documentation</li>
<li>website</li>
<li>marketing-and-advocacy</li>
<li>infrastructure</li>
</ul>
</li>
<li>Event-Chat
<ul>
<li>EmberConf</li>
<li>EmberCamps</li>
<li>EmberFest</li>
<li>Talks</li>
<li>Other Conferences</li>
<li>Meetup organizers</li>
</ul>
</li>
<li>Social
<ul>
<li>Water-cooler (random)</li>
<li>Local-*</li>
<li>Media (livestreams, videos, podcasts)</li>
<li>Pets</li>
<li>Women in Ember 🔒</li>
</ul>
</li>
</ul>
<p><strong>Integrations</strong>
Discord's integration game is strong. Discord has a <a href="https://discordapp.com/developers/docs/intro">very detailed API</a> and many integrations already exist, and with no limitation (compared to free Slack instances, that have limited numbers of integrations).</p>
<a class="header" href="print.html#how-do-we-teach-this" id="how-do-we-teach-this"><h2>How do we teach this?</h2></a>
<p>In addition to having a setup channel available upon login (with illustrated instructions), here are some links where community members can read more:</p>
<ul>
<li><a href="https://discordapp.com/open-source">Discord Loves Open Source</a></li>
<li><a href="https://discordapp.com/guidelines">Discord Community Guidelines</a></li>
<li><a href="http://www.businessinsider.com/how-to-use-discord-the-messaging-app-for-gamers-2018-5">How to use Discord</a></li>
</ul>
<a class="header" href="print.html#drawbacks-80" id="drawbacks-80"><h2>Drawbacks</h2></a>
<a class="header" href="print.html#supporting-learning-vs-supporting-development" id="supporting-learning-vs-supporting-development"><h3>Supporting Learning vs Supporting Development</h3></a>
<p>There is some concern that there is already some confusion on Slack about where to get help learning/using Ember, and where to coordinate working on Ember. We need to have a clear delineation so that the folks who are spending their volunteer time to ship Ember features can continue to concentrate and do that.</p>
<a class="header" href="print.html#losing-community-members" id="losing-community-members"><h3>Losing Community Members</h3></a>
<p>There is some concern that we may lose some community members due to this move. This could happen for a variety of reasons- the nature of OSS work means that some are not always active on the chat community, or the user doesn't want a different chat app, etc. We believe that the former is probably more likely than the latter, since many of us are on at least 2-3 chat apps already.</p>
<a class="header" href="print.html#alternatives-82" id="alternatives-82"><h2>Alternatives</h2></a>
<p>The alternative to this would be to temporarily remain on Slack until we are able to evaluate and choose another viable option. However, we believe that staying on Slack is not desirable.</p>
<p>List of Slack alternatives:</p>
<ul>
<li>riot.io</li>
<li>mattermost.org</li>
<li>rocket.chat</li>
<li>spectrum.chat</li>
</ul>
<a class="header" href="print.html#unresolved-questions--faq" id="unresolved-questions--faq"><h2>Unresolved questions &amp; FAQ</h2></a>
<ul>
<li>When will there be conversation threads? We have been told that it is in the works, but there is no ETA.</li>
<li>Disqus, Discord, Discuss? Which is which? For clarity, we will encourage the use of the terms <strong>chat</strong> (Discord), <strong>the forums</strong> (Discuss), and <strong>blog comments</strong> (Disqus)- mostly so no one has to try to remember.</li>
</ul>
<a class="header" href="print.html#ember-2018-roadmap-rfc" id="ember-2018-roadmap-rfc"><h1>Ember 2018 Roadmap RFC</h1></a>
<a class="header" href="print.html#summary-84" id="summary-84"><h1>Summary</h1></a>
<p>This RFC sets the Ember 2018 Roadmap. This year’s goals are to:</p>
<ul>
<li>Improve communication and streamline decision-making, and empower new leaders.</li>
<li>Finish the major initiatives that we’ve already started.</li>
<li>Ship a new <em>edition</em>, Ember Octane, focused on performance and productivity.</li>
</ul>
<a class="header" href="print.html#motivation-85" id="motivation-85"><h1>Motivation</h1></a>
<p>This document is a distillation of multiple sources:</p>
<ol>
<li>The 2018 Community Survey.</li>
<li>Community #EmberJS2018 blog posts, authored in response to our call for posts.</li>
<li>Discussion on https://discuss.emberjs.com</li>
<li>Deliberations among the Ember core teams.</li>
</ol>
<p>The goal of the RFC is to align the Ember community around a set of shared, achievable goals that balance the needs of existing users with the need to grow and support new use cases.</p>
<a class="header" href="print.html#detailed-design-75" id="detailed-design-75"><h1>Detailed design</h1></a>
<p>This year is primarily about finishing initiatives that we’ve already started, fine-tuning our communication channels, and getting the world excited about Ember.</p>
<ul>
<li><strong>Improve communication and streamline decision-making</strong>. We will expand and refine the core team structure, to ensure decisions are made quickly, communication is clear, and users feel empowered to become contributors. We will invest in mentoring new leaders, and cross-pollinating knowledge between teams. As a community, we will share our excitement about Ember with the wider web development world.</li>
<li><strong>Finish what we started.</strong> We need to focus on stabilizing and polishing the work that we’ve already started in 2018. We will add extension points to allow popular new tools to be quickly adopted in Ember apps. We will standardize around ES modules and npm packages, better enabling the sharing of Ember tools with the wider JavaScript community.</li>
<li><strong>Ship Ember Octane</strong>. We will ship a new <em>edition</em> of Ember, emphasizing its <em>modern productivity and performance</em>. We will polish our compatibility with new JavaScript language features like native classes, decorators, and async functions. We will continue efforts like optional jQuery and treeshaking that reduce file size. We will overhaul the Ember homepage to align with Octane and tell the story of modern Ember.</li>
</ul>
<p>To help us deliver a polished, cohesive experience, we will focus on two end-to-end, real world use cases. Having concrete use cases in mind helps us improve our marketing as well as prioritize feature development. In 2018, our two use cases are:</p>
<ul>
<li><strong>Productivity apps.</strong> Ember’s historical strength: sophisticated, highly interactive apps that users spend a lot of time in, getting things done.</li>
<li><strong>Content apps</strong>, where pages are text-heavy and where the first load is critical. In performance-constrained environments, Ember’s strong conventions can help developers build faster apps by default.</li>
</ul>
<a class="header" href="print.html#improve-communication-and-streamline-decision-making" id="improve-communication-and-streamline-decision-making"><h2>Improve communication and streamline decision-making</h2></a>
<blockquote>
<p>Silence is the only thing that cause developers to lose trust in Ember. And overcommunication is the cure to silence.
—<a href="https://embermap.com/notes/107-our-wish-for-ember-in-2018-overcommunication">Ryan Toronto and Sam Selikoff</a></p>
</blockquote>
<blockquote>
<p>Technical leadership seems to me to be about 10% technical brilliance and 90% clear communication. We have loads of technical brilliance; we need more communication!
—<a href="https://www.chriskrycho.com/2018/emberjs2018-part-3.html">Chris Krycho</a></p>
</blockquote>
<blockquote>
<p>Communication is well, not stellar. Newsletters do a great job at communicating what already happened, but future plans are largely unknown to public.
—<a href="https://medium.com/@vlascik/honest-look-at-ember-in-the-middle-of-2018-a0dc2787e506">V. Lascik</a></p>
</blockquote>
<blockquote>
<p>The Core Team is in a unique position to add external-facing commentary on the framework's vision. Our RFC process and release posts are awesome, and they have done great things internally, so I would like to encourage Core to look outwards next.
—<a href="https://gist.github.com/jenweber/a9fbea98478fc3841fb8b24f7dc961c8">Jen Weber</a></p>
</blockquote>
<blockquote>
<p>My hope is that Ember will continue to be an investment worth making. I see a growing, diverse community with lots of fresh faces as an essential part of that.
—<a href="https://medium.com/@mattmcmanus/emberjs2018-2d28a441fadb">Matt McManus</a></p>
</blockquote>
<blockquote>
<p>Finding how and where I can help feels scattered. Issues do not receive effective labeling. This has translated into me not contributing to varying projects.
—<a href="https://www.innovu.com/2018/05/a-few-quick-thoughts-on-ember-for-2018-from-a-corporate-citizen/">Eli Flanagan</a></p>
</blockquote>
<blockquote>
<p>What I’d wish for Ember’s 2018 Roadmap though is to find ways to lower the entry barriers for newcomers to get started in their attempt to advocate Ember and to be creative on how to encourage a sense of empowerment in the wider community regarding outreach efforts.
—<a href="https://simplabs.com/blog/2018/05/30/a-little-encouragement-goes-a-long-way-in-2018.html">Jessica Jordan</a></p>
</blockquote>
<blockquote>
<p>My hope is that we will continue to hand off the baton of the community values to developers who are new to Ember.
—<a href="https://pixelhandler.com/posts/emberjs2018-a-few-suggestions">Bill Heaton</a></p>
</blockquote>
<blockquote>
<p>A good idea would be to continue creating quests for small things like documentation, code-cleaning… And maybe add a place where this quest can be found
—<a href="https://medium.com/@KamiKillertO/my-emberjs-in-2018-bc7f52739e16">Benjamin Jegard</a></p>
</blockquote>
<p>There has never been more time and energy going into Ember, but we’ve heard loud and clear that this momentum is not as visible as it needs to be. We are going to prioritize sharing work as it happens, making planning and status updates more discoverable, and making it easier for would-be contributors to get involved.</p>
<p>We also need to double down on making Ember as friendly and inclusive as possible, particularly for folks who have never participated in an open source project before. As we bring in new community members, we will make changes to ensure that individuals can have a meaningful impact, no matter what time zone they live in.</p>
<p>Lastly, we need to make sure that our core teams are not so bogged down that they become a bottleneck for decision-making. Core teams and strike teams decentralize planning, empower new contributors to take ownership of community initiatives, and help to build and strengthen relationships among community members. We will invest in improving the organization and structure of these teams this year.</p>
<p>To accomplish these goals, this year we will:</p>
<ul>
<li><strong>Expand and refine our team structure</strong>, breaking up work and delegating it to strike teams or new core teams as appropriate.</li>
<li><strong>Move to discoverable communication tools</strong>, such as our Discourse forum, which is visible to search engines, and Discord chat, which doesn't lose history.</li>
<li><strong>Invest in mentoring</strong>. This includes direct mentorship relationships, as well as written guides like quest issues that are helpful even for people in different time zones or who have difficulty with spoken English.</li>
<li><strong>Track RFC implementation via GitHub issues</strong>, so it's clear what the next steps are after an RFC is merged.</li>
<li><strong>Automate communication and status updates.</strong> For example, we will improve the <a href="https://www.emberjs.com/statusboard">Statusboard</a> to automatically pull from RFCs and RFC tracking issues.</li>
<li><strong>Document “best practices” for core teams</strong>, spreading knowledge about what works and what doesn’t for building an active community.</li>
<li><strong>Unify the RFC process</strong> to ensure a consistent experience across all of Ember's sub-projects.</li>
</ul>
<a class="header" href="print.html#finish-what-we-started" id="finish-what-we-started"><h2>Finish what we started</h2></a>
<blockquote>
<p>The last few years have seen the Ember team do a lot of really important exploratory work, including projects like <a href="https://glimmerjs.com/">Glimmer.js</a>; and we have landed some of the initiatives we have started. But I think it’s fair to say that focus has not been our strong suit. It’s time for a year of shipping.—<a href="https://www.chriskrycho.com/2018/emberjs2018-part-1.html">Chris Krycho</a></p>
</blockquote>
<blockquote>
<p>I think the goal of being able to just npm install or yarn install any package and having it &quot;just work&quot; should be high on the TODO list.
—<a href="http://andrewcallahan.com/a-road-to-ember-4-0/">Andrew Callahan</a></p>
</blockquote>
<blockquote>
<p>When <a href="https://mobile.twitter.com/wycats">Yehuda Katz</a> <a href="https://github.com/emberjs/rfcs/pull/38#issuecomment-355800759">closed</a> that RFC, I think a bit of that dream died, but at the same time I was happy. Not because it wasn't going to happen but because there was clear communication, finally.
—<a href="https://burstcreations.com/ember-in-2018-and-beyond/">Ilya Radchenko</a></p>
</blockquote>
<blockquote>
<p>I firmly believe that Ember needs to deliver all the great new features that are currently in flight before taking more to its plate.
—<a href="https://josemarluedke.com/blog/ember-in-2018-getting-ready-for-the-next-major-release/">Josemar Luedke</a></p>
</blockquote>
<p>This year, we <strong>need a strong focus on shipping</strong>. Huge improvements to Ember have either already landed or are in the pipeline. We need to cross the finish line on these before moving on to new initiatives, however important or exciting they might seem.</p>
<p>“Done” doesn’t mean behind a feature flag on canary. Finishing what we started means ensuring that features are discoverable, on by default, and that the guides and other documentation have been revised to take them into account. It means making sure they work well with the entire Ember ecosystem so that new developers get a seamless experience.</p>
<p>This year, we are going to ship:</p>
<ul>
<li><strong>Broccoli 2.0</strong> in Ember CLI, as well as significant investment into Broccoli documentation, marketing and advocacy.</li>
<li><strong>Module Unification</strong> as the default file system layout.</li>
<li><strong>Glimmer Components</strong> as the default component API.</li>
<li><strong>Native JavaScript classes</strong> as the default object model.</li>
<li><strong>Native JavaScript modules,</strong> including:
<ul>
<li><strong>Exposing modules in the build pipeline</strong> and allowing addons to integrate tools like Parcel, Rollup or Webpack.</li>
<li><strong>Publishing Ember as npm packages</strong>.</li>
<li><strong>Importing npm packages</strong> into your Ember apps with zero additional configuration. (This was, far and away, the most-mentioned feature request in all of the #EmberJS2018 blog posts.)</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#ember-octane" id="ember-octane"><h2>Ember Octane</h2></a>
<blockquote>
<p>The homepage looks a bit outdated and does not a very compelling job at selling Ember to new users, IMHO. This needs to change.
—<a href="https://www.kaliber5.de/en/blog/ember-js-in-2018-get-better-at-marketing/">Simon Ihmig</a></p>
</blockquote>
<blockquote>
<p>When you generate a project with <code>ember new</code>, you get a project that is almost “legacy” by standards of the wider JavaScript community.
—<a href="https://medium.com/@gauravmunjal_86037/stability-without-stagnation-in-2018-ce2d4f519991">Gaurav Munjal</a></p>
</blockquote>
<blockquote>
<p>Ember's custom object model isn't hard to learn, but it's a big reason people are turned off before learning why Ember is such a great choce. I'd like to see ES classes support finished and adopted in the Guides ASAP, followed by decorators.
—<a href="https://gist.github.com/michaelrkn/ffdd67906a724362bd8f5ccc3434db0f">Michael Kaiser-Nyman</a></p>
</blockquote>
<blockquote>
<p>ES6 syntax, the new file layout, new templating etc. — the new features will land in 3.x releases as non-breaking changes, but let’s prepare to show off the sum of all those amazing parts. Sell the vision, right now! A ‘relaunch’ of Ember in the minds of those who dismiss it.
—<a href="https://medium.com/@willviles/ember-js-in-2018-lets-market-the-future-e6be9c42cf86">Will Viles</a></p>
</blockquote>
<p>Ember releases a new, stable version every six weeks. For existing users, this drumbeat of incremental improvement is easier to keep up with than splashy, big-bang releases.</p>
<p>However, for people not following Ember closely, it’s easy to miss the significant improvements that happen over time. As detailed in the forthcoming Ember Editions RFC (being worked on by <a href="https://twitter.com/davewasmer">Dave Wasmer</a>), every year or so <strong>we will release a new edition of Ember</strong>, focused on a particular theme. The set of improvements related to that theme, taken together, mark a meaningful change to how people should think about Ember.</p>
<p>In 2018, we will release the first edition of Ember, called <em>Ember Octane</em>. <strong>Octane will focus on the themes of productivity and performance.</strong> We’ll talk about how Ember excels in performance-constrained environments, particularly on mobile devices, as well as the productivity benefits of modern JavaScript features like classes, decorators, and async functions when paired with Ember’s strong conventions and community.</p>
<p>This is also a good time for us to review the new application blueprint, to ensure that it is up-to-date with the latest Ember Octane idioms and includes the right set of addons to help new users achieve our goals of productivity and performance.</p>
<p>Ember Octane is about <em>doing more with less</em>. Not only does this make Ember simpler to learn, it makes the framework smaller and faster, too. These are some of the highlights of Ember Octane:</p>
<ul>
<li><strong>No jQuery.</strong> Currently available as an optional feature, we will enable this by default.</li>
<li><strong>Svelte builds</strong>, where deprecated features are stripped out of framework code. We will get more aggressive about deprecating code that is not widely used.</li>
<li><strong>Native JavaScript classes</strong> perform better and require less code, and integrate better with tools like TypeScript and ESLint.</li>
<li><strong>Glimmer components</strong> offer a greatly simplified API and remove common slow paths.</li>
<li><strong>Incremental rendering and rehydration</strong> that keeps even low-end devices responsive as the application boots.</li>
<li><strong>Treeshaking</strong> to automatically remove code unused by the application.</li>
<li><strong>Eliminating the runloop</strong> from the programming model, replaced by <code>async</code> and <code>await</code> in tests.</li>
<li><strong>Stabilizing Ember Data</strong> by streamlining internals and providing more extension points for applications and addons to customize behavior.</li>
</ul>
<p>The final timeline and feature set of Ember Octane will be determined by the core teams and are not set in stone in this RFC.</p>
<p>In keeping with our commitment to finishing what we’ve started, these are all features that are either finished or being implemented now. We should not plan for Octane to have any features that are not already close to being done today, so that we have adequate time to make sure they all work well together as part a cohesive programming model.</p>
<p>The process of releasing a new edition also gives us an opportunity to evaluate what it’s like to use Ember end-to-end. We will overhaul the Ember homepage, focusing on Ember Octane and how it helps solve targeted use cases.</p>
<p>This is also a good time to perform a holistic review of the guides, making sure that examples use the latest idioms and set new learners on a good path.</p>
<a class="header" href="print.html#non-goals" id="non-goals"><h1>Non-goals</h1></a>
<p>One of our most important goals this year is to focus on shipping. Focus means saying “no” to ideas that we really like.</p>
<ul>
<li><strong>Significant work on Glimmer.js</strong>. We will instead focus on our efforts on incorporating the lessons of Glimmer.js into work that enables a smaller core in Ember.</li>
<li><strong>Further Glimmer VM optimizations</strong>. Glimmer performance is industry leading and not a bottleneck in most Ember.js apps. At this point, the Ember.js payload is the primary performance bottleneck, and we should turn our attention to enabling better performance there.</li>
<li><strong>Brand new language features</strong> in either Handlebars templates or Ember’s JavaScript files. There is already a full pipeline of features, such as Glimmer components, JavaScript classes with decorators, and module unification that we need to finish before starting any new major design.</li>
</ul>
<ul>
<li>Start Date: 2018-08-30</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/369</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-85" id="summary-85"><h1>Summary</h1></a>
<p>Deprecate computed overridability and <code>computed().readOnly()</code> in favor of
read-only computeds as the default.</p>
<a class="header" href="print.html#motivation-86" id="motivation-86"><h1>Motivation</h1></a>
<p>Computed properties have existed in Ember long before class syntax and native
accessors (getters and setters) were readily available, and as such they have a
few notable behavioral differences. As we move toward adopting native class
syntax and using a decorator-based form of computeds, it makes sense to
reconcile these differences so that users can expect them to work the same as
their native counterparts.</p>
<p>The main and most notable difference this RFC seeks to deprecate is computed
overridability (colloquially known as &quot;clobbering&quot;). There are some other
notable differences, including the caching behavior of the <code>return</code> value of
setter functions, which may be addressed in future RFCs.</p>
<a class="header" href="print.html#overridability" id="overridability"><h2>Overridability</h2></a>
<p>When defining a native getter without a setter, attempting to set the value will
throw a hard error (in strict mode):</p>
<pre><code class="language-js">function makeFoo() {
  'use strict';

  class Foo {
    get bar() {
      return this._value;
    }
  }

  let foo = new Foo();

  foo.bar; // undefined
  foo.bar = 'baz'; // throws an error in strict mode
}
</code></pre>
<p>By constrast, computed properties without setters will be overridden when they
are set, meaning the computed property is removed from the object and replaced
with the set value:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: computed('_value', {
    get() {
      return this._value;
    },
  }),
});

let foo = Foo.create();

foo.bar; // undefined
foo.set('bar', 'baz'); // Overwrites the getter
foo.bar; // 'baz'
foo.set('_value', 123);
foo.bar; // 'baz'
</code></pre>
<p>This behavior is confusing to newcomers, and oftentimes unexpected. Common best
practice is to opt-out of it by declaring the property as <code>readOnly</code>, which
prevents this overridability.</p>
<a class="header" href="print.html#transition-path-10" id="transition-path-10"><h1>Transition Path</h1></a>
<p>This RFC proposes that <code>readOnly</code> properties become the default, and that in
order to override users must opt in by defining their own setters:</p>
<pre><code class="language-js">class Foo {
  get bar() {
    if (this._bar) {
      return this._bar;
    }

    return this._value
  }

  set bar(value) {
    this._bar = value
  }
}
</code></pre>
<a class="header" href="print.html#macros" id="macros"><h2>Macros</h2></a>
<p>Most computed macros are overridable by default, the exception being <code>readOnly</code>.
This RFC proposes that all computed macros with the exception of <code>reads</code> would
become read only by default. The purpose of <code>reads</code> is to <em>be</em> overridable, so
its behavior would remain the same.</p>
<a class="header" href="print.html#decorator-interop" id="decorator-interop"><h2>Decorator Interop</h2></a>
<p>It may be somewhat cumbersome to write overriding functionality or add proxy
properties when overriding is needed. In an ideal world, computed properties
would modify accessors transparently so that they could be composed with other
decorators, such as an <code>@overridable</code> decorator:</p>
<pre><code class="language-js">class Foo {
  @overridable
  @computed('_value')
  get bar() {
    return this._value;
  }

  @overridable
  @and('baz', 'qux')
  quux;
}
</code></pre>
<p>Currently this is not possible as computed properties store their getter/setter
functions elsewhere and replace them with a proxy getter and the mandatory
setter assertion, respectively. In the long term, making computeds more
transparent in this way would be ideal, but it is out of scope for this RFC.</p>
<a class="header" href="print.html#deprecation-timeline" id="deprecation-timeline"><h2>Deprecation Timeline</h2></a>
<p>This change will be a breaking change, which means we will not be able to change
the behavior of <code>computed</code> until Ember v4.0.0. Additionally, users will likely
want to continue using <code>.readOnly()</code> up until overriding has been fully removed
to ensure they are using properties safely. With that in mind, the ordering of
events should be:</p>
<ol>
<li>Ember v3</li>
</ol>
<ul>
<li>Deprecate the default override-setter behavior immediately. This means that
a deprecation warning will be thrown if a user attempts to set a
non-<code>readOnly</code> property which does not have a setter. User's will still be
able to declare a property is <code>readOnly</code> without a deprecation warning.</li>
<li>Add optional feature to change the deprecation to an assertion after the
deprecation has been released, and to show a deprecation when using
the <code>.readOnly()</code> modifier.</li>
<li>After the deprecation and optional feature have been available for a
reasonable amount of time, enable the optional feature by default in new
apps and addons. The main reason we want to delay this is to give <em>addons</em>
a chance to address deprecations, since enabling this feature will affect
both apps and the addons they consume.</li>
</ul>
<ol start="2">
<li>Ember v4</li>
</ol>
<ul>
<li>Remove the override-setter entirely, making non-overrideable properties the
default.</li>
<li>Make the <code>readOnly</code> modifier a no-op, and show a deprecation warning when it
is used.</li>
</ul>
<p>The warnings should explain the deprecation, and recommend that users do not
rely on setter behavior or opting-in to read only behavior.</p>
<a class="header" href="print.html#how-we-teach-this-57" id="how-we-teach-this-57"><h1>How We Teach This</h1></a>
<p>In general, we can teach that computed properties are essentially cached native
getters/setters (with a few more bells and whistles). Once we have official
decorators in the framework, we can make this connection even more solid.</p>
<p>We should add notes on overridability, and we should scrub the guides of any
examples that make use of overriding directly and indirectly via <code>.readOnly()</code>.</p>
<a class="header" href="print.html#drawbacks-81" id="drawbacks-81"><h1>Drawbacks</h1></a>
<p>Overriding is not a completely uncommonly used feature, and developers who have
become used to it may feel like it makes their code more complicated, especially
without any easy way to opt back in.</p>
<a class="header" href="print.html#alternatives-83" id="alternatives-83"><h1>Alternatives</h1></a>
<p>We could convert <code>.readOnly()</code> into <code>.overridable()</code>, forcing users to opt-in
to overriding. Given the long timeline of this deprecation, it would likely be
better to work on making getters/setters transparent to decoration, and provide
a <code>@overridable</code> decorator either in Ember or as an independent package.</p>
<ul>
<li>Start Date: 2018-08-31</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/370</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-86" id="summary-86"><h1>Summary</h1></a>
<p>Deprecate <code>computed().volatile()</code> in favor of undecorated native getters and
setters.</p>
<a class="header" href="print.html#motivation-87" id="motivation-87"><h1>Motivation</h1></a>
<p><code>computed().volatile()</code> is a commonly misunderstood API. On its surface,
declaring a computed as volatile causes the computed to recalculate every time
it is called. This actually works much like native, undecorated accessors do on
classes, with one key difference.</p>
<p>Volatile properties are meant to respresent fundamentally unobservable values.
This means that they swallow notification changes, and will not notify under any
circumstances, and that when setting a volatile value the user must notify
manually:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: computed({
    get() {
      return this._value;
    }

    set(key, value) {
      return this._value = value;
    }
  }).volatile(),

  baz: computed('bar', {
    get() {
      return this.bar;
    }
  }),
});

let foo = Foo.create();

foo.set('bar', 123);
foo.baz; // 123, it's the initial get so nothing cached yet

foo.set('bar', 456);
foo.baz; // 123, no property changes were made so the cache was not cleared
</code></pre>
<p>This behavior is useful at times for framework code, but is generally not what
users are expecting. By constrast, when using native accessors with <code>set</code> and
<code>get</code>, Ember treats them just like any other property. From its perspective,
they <em>are</em> standard properties, so it'll continue to notify as expected.</p>
<pre><code class="language-js">class Foo {
  get bar() {
    return this._value;
  }

  set bar(value) {
    this._value = value;
  }

  @computed('bar')
  get baz() {
    return this.bar;
  }
});

let foo = new Foo();

set(foo, 'bar', 123);
foo.baz; // 123, it's the initial get so nothing cached yet

set(foo, 'bar', 456);
foo.baz; // 456, cache was cleared and value was updated
</code></pre>
<p>The most common use case for volatile computeds was when users wanted a computed
to behave like a native getter/setter. Now that we (almost) <em>have</em> those in a
easy to use form, it makes more sense to deprecate the volatile API and rely
directly on native functionality.</p>
<a class="header" href="print.html#transition-path-11" id="transition-path-11"><h1>Transition Path</h1></a>
<p>Native getters and setters will <em>only</em> work on native classes, due to how the
internals of the old object model work. To ensure that users do not accidentally
try to replace volatile with getters/setters on non-native classes, we should
provide 2 deprecation warnings:</p>
<ol>
<li>
<p>Deprecation when users use volatile on a computed which tells them that the
API has been deprecated, and that they'll need to update native class syntax
to remove the volatile property.</p>
</li>
<li>
<p>Deprecation when users use volatile on a computed decorator (to be RFC'd)
which tells them to remove the computed decorator entirely from the getter.</p>
</li>
</ol>
<p>Volatile properties will be removed once native classes are the default.</p>
<a class="header" href="print.html#how-we-teach-this-58" id="how-we-teach-this-58"><h1>How We Teach This</h1></a>
<p>In general documentation should be updated to use native getters and setters
wherever <code>volatile</code> was used. This will have to happen after docs are updated to
use native classes, because native getters and setters do <em>not</em> work with the
older object model.</p>
<a class="header" href="print.html#drawbacks-82" id="drawbacks-82"><h1>Drawbacks</h1></a>
<p>Volatility is useful for framework level concerns, for instance if developing an
API or decorator that already handles notification. Addon authors may be able to
use this functionality.</p>
<p>Not having an alternative for old style classes or mixins could be problematic
for users who aren't ready to update to native class syntax.</p>
<a class="header" href="print.html#alternatives-84" id="alternatives-84"><h1>Alternatives</h1></a>
<p>We could keep <code>volatile()</code> around for any potential addons that may want to use
it, but teach native getters/setters as the preferred path for most use cases.</p>
<p>We could provide <code>volatile</code> as a separate API/decorator to distinguish it from
computed properties, and discourage use for users.</p>
<ul>
<li>Start Date: 2018-09-06</li>
<li>RFC PR: (leave this empty)</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#ember-data--modelfactoryfor" id="ember-data--modelfactoryfor"><h1>ember-data | modelFactoryFor</h1></a>
<a class="header" href="print.html#summary-87" id="summary-87"><h2>Summary</h2></a>
<p>Promote the private <code>store._modelFactoryFor</code> to public API as <code>store.modelFactoryFor</code>.</p>
<a class="header" href="print.html#motivation-88" id="motivation-88"><h2>Motivation</h2></a>
<p>This RFC is a follow-up RFC for <a href="https://github.com/emberjs/rfcs/pull/293">#293 RecordData</a>.</p>
<p>Ember differentiates between <code>klass</code> and <code>factory</code> for classes registered with the container.
At times, <code>ember-data</code> needs the <code>klass</code>, at other times, it needs the <code>factory</code>. For this reason,
<code>ember-data</code> has carried two APIs for accessing one or the other for some time. The public <code>modelFor</code>
provides access to the <code>klass</code> where schema information is stored, while the private <code>_modelFactoryFor</code>
provides access to the factory for instantiation.</p>
<p>We provide access to the class with <code>modelFor</code> roughly implemented as <code>store._modelFactoryFor(modelName).klass</code>.
We instantiate records from this class roughly implemented as <code>store._modelFactoryFor(modelName).create({ ...args })</code>.</p>
<p>For symmetry, both of these APIs should be public. Making <code>modelFactoryFor</code> public would provide a hook
that consumers can override should they desire to provide a custom <code>ModelClass</code> as an alternative
to <code>DS.Model</code>.</p>
<a class="header" href="print.html#detailed-design-76" id="detailed-design-76"><h2>Detailed design</h2></a>
<p>Due to previous complexity in the lookup of models in <code>ember-data</code>, we previously had both <code>modelFactoryFor</code>
and <code>_modelFactoryFor</code>. Despite the naming, both of these methods were private. During a recent cleanup phase,
we unified the methods into <code>_modelFactoryFor</code> and left a deprecation in <code>modelFactoryFor</code>. This RFC proposes
un-deprecating the <code>modelFactoryFor</code> method and making it public, while deprecating the private <code>_modelFactoryFor</code>.</p>
<p>More precisely:</p>
<ul>
<li><code>store._modelFactoryFor</code> becomes deprecated and calls <code>store.modelFactoryFor</code>.</li>
<li><code>store.modelFactoryFor</code> becomes un-deprecated.</li>
</ul>
<a class="header" href="print.html#the-contract-for-modelfactoryfor" id="the-contract-for-modelfactoryfor"><h3>The contract for <code>modelFactoryFor</code></h3></a>
<p>The return value of <code>modelFactoryFor</code> MUST be the result of a call to <a href="https://www.emberjs.com/api/ember/3.4/classes/ApplicationInstance/methods/factoryFor?anchor=factoryFor"><code>applicationInstance.factoryFor</code></a>
where <code>applicationInstance</code> is the <code>owner</code> returned by using <code>getOwner(this)</code> to access the <code>owner</code> of the <code>store</code> instance.</p>
<pre><code class="language-typescript">interface Klass {}

interface Factory {
  klass: Klass,
  create(): Klass
}

interface FactoryMap {
    [factoryName: string]: Factory
}

declare function factoryFor&lt;K extends keyof FactoryMap&gt;(factoryName: K): FactoryMap[K];

interface Store {
  modelFactoryFor(modelName: string): ReturnType&lt;typeof factoryFor&gt;;
}
</code></pre>
<p>Users interested in providing a custom class for their <code>records</code> and who override <code>modelFactoryFor</code>,
would not need to also change <code>modelFor</code>, as this would be the <code>klass</code> accessible via the <code>factory</code>.</p>
<p>Users wishing to extend the behavior of <code>modelFactoryFor</code> could do so in the following manner:</p>
<p><strong>Example 1:</strong></p>
<p><strong>services/store.js</strong></p>
<pre><code class="language-js">import { getOwner } from '@ember/application';
import Store from 'ember-data/store';

export default Store.extend({
  modelFactoryFor(modelName) {
    if (someCustomCondition) {
      return getOwner(this).factoryFor(someFactoryName);
    }
    
    return this._super(modelName);
  }
});
</code></pre>
<a class="header" href="print.html#modelmodelname" id="modelmodelname"><h4><code>Model.modelName</code></h4></a>
<p><code>ember-data</code> currently sets <code>modelName</code> onto the <code>klass</code> accessible via the <code>factory</code>. For classes that do not
inherit from <code>DS.Model</code> this would not be done, although end users may do so themselves in their implementations
if so desired.</p>
<a class="header" href="print.html#what-is-a-valid-factory" id="what-is-a-valid-factory"><h3>What is a valid factory?</h3></a>
<p>The default export of a custom ModelClass <strong>MUST</strong> conform to the requirements of <code>Ember.factoryFor</code>. The requirements
of <code>factoryFor</code> are currently underspecified; however, in practice, this means that the default export is an
instantiable class with a static <code>create</code> method and an instance <code>destroy</code> method or that inherits from <code>EmberObject</code>
(which provides such methods).</p>
<p><strong>Example 2:</strong></p>
<pre><code class="language-javascript">import { assign } from '@ember/polyfills';

export default class CustomModel {
  constructor(createArgs) {
    assign(this, createArgs);
  }
  destroy() {
    // ... do teardown
  }
  static create(createArgs) {
    return new this(createArgs);
  }
}
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="language-javascript">import EmberObject from '@ember/object';

export default class CustomModel extends EmberObject {
  constructor(createArgs) {
    super(createArgs);
  }
}
</code></pre>
<p>Custom classes for models should expect their constructor to receive a single argument: an object with <em>at least</em>
the following.</p>
<ul>
<li>A <code>recordData</code> instance accessible via <code>getRecordData</code> (see below)</li>
<li>Any properties passed as the second arg to <code>createRecord</code></li>
<li>An <code>owner</code> accessible via <code>Ember.getOwner</code></li>
<li>Any DI injections</li>
<li>any other properties that <code>Ember</code> chooses to pass to a class instantiated via <code>factory.create</code> (currently none)</li>
</ul>
<a class="header" href="print.html#getrecorddata" id="getrecorddata"><h3>getRecordData</h3></a>
<p>Every <code>record</code> (instance of the class returned by <code>modelFactoryFor</code>) will have an associated <a href="https://github.com/emberjs/rfcs/pull/293">RecordData</a>
which contains the backing data for the id, type, attributes and relationships of that record.</p>
<p>This backing data can be accessed by using the <code>getRecordData</code> util on the <code>record</code> (or on the <code>createArgs</code> passed to
a record). Using <code>getRecordData</code> on a <code>record</code> is only guaranteed after the record has been instantiated. During
instantiation, this call should be made on the <code>createArgs</code> object passed into the record.</p>
<p><strong>Example 4</strong></p>
<pre><code class="language-javascript">import { getRecordData } from 'ember-data';

export default class CustomModel {
  constructor(createArgs) {
    // during instantiation, `recordData` is available by calling `getRecordData` on createArgs
    let recordData = getRecordData(createArgs);
  }
  someMethod() {
    // post instantiation, `recordData` is available by calling `getRecordData` on the instance
    let recordData = getRecordData(this);
  }
  destroy() {
    // ... do teardown
  }
  static create(createArgs) {
    return new this(createArgs);
  }
}
</code></pre>
<a class="header" href="print.html#how-we-teach-this-59" id="how-we-teach-this-59"><h2>How we teach this</h2></a>
<p>This API would be intended for addon-authors and power users. It is not expected
that most apps would implement custom models, much as it is not expected that most
apps would implement custom <code>RecordData</code>. The teaching story would be limited to
documenting the nature and purpose of <code>modelFactoryFor</code>.</p>
<a class="header" href="print.html#drawbacks-83" id="drawbacks-83"><h2>Drawbacks</h2></a>
<ul>
<li>Users may try to use the hook to instantiate records on their own. Ultimately, the store
should still do the instantiating.</li>
</ul>
<a class="header" href="print.html#alternatives-85" id="alternatives-85"><h2>Alternatives</h2></a>
<p>Users could define models in <code>models/*.js</code> that utilize a custom <code>ModelClass</code>.
However, such an API for custom classes would exclude the ability to dynamically
generate classes.</p>
<a class="header" href="print.html#unresolved-questions-59" id="unresolved-questions-59"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2018-09-10</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/373</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#element-modifier-manager" id="element-modifier-manager"><h1>Element Modifier Manager</h1></a>
<a class="header" href="print.html#summary-88" id="summary-88"><h2>Summary</h2></a>
<p>This RFC proposes a low-level primitive for defining element modifiers. It is a parent to the <a href="https://github.com/emberjs/rfcs/pull/353">Modifiers RFC</a>.</p>
<a class="header" href="print.html#motivation-89" id="motivation-89"><h2>Motivation</h2></a>
<p>Ever since Ember 1.0 we have had the concept of element modifiers, however Ember only exposes one modifier; <code>{{action}}</code>. We also do not provide a mechanism for defining your own modifiers and managing their life cycles.</p>
<p>As <a href="https://github.com/emberjs/rfcs/pull/353#issuecomment-417769349">pointed out</a> in the <a href="https://github.com/emberjs/rfcs/pull/353">Element Modifiers RFC</a> we should expose the underlying infrastructure that makes element modifiers possible. Based on our experience, we believe it would be beneficial to open up these new primitives to the wider community. The largest benefit is that it allows the community to experiment with and iterate on APIs outside of the core framework.</p>
<p>This RFC is in the same spirit as the <a href="https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md">custom components RFC</a>.</p>
<a class="header" href="print.html#detailed-design-77" id="detailed-design-77"><h2>Detailed design</h2></a>
<p>This RFC introduces the concept of <em>modifier managers</em>. A modifier manager is an object that is responsible for coordinating the lifecycle events that occurs when invoking, installing and updating an element modifier.</p>
<a class="header" href="print.html#registering-modifier-managers" id="registering-modifier-managers"><h3>Registering modifier managers</h3></a>
<p>Modifier managers are registered with the <code>modifier-manager</code> type in the
application's registry. Similar to services, modifier managers are singleton
objects (i.e. <code>{ singleton: true, instantiate: true }</code>), meaning that Ember
will create and maintain (at most) one instance of each unique modifier
manager for every application instance.</p>
<p>To register a modifier manager, an addon will put it inside its <code>app</code> tree:</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  // ...
});
</code></pre>
<p>(Typically, the convention is for addons to define classes like this in its
<code>addon</code> tree and then re-export them from the <code>app</code> tree. For brevity, we will
just inline them in the <code>app</code> tree directly for the examples in this RFC.)</p>
<p>This allows the modifier manager to participate in the DI system – receiving
injections, using services, etc. Alternatively, modifier managers can also
be registered with imperative API. This could be useful for testing or opt-ing
out of the DI system. For example:</p>
<pre><code class="language-js">// ember-basic-modifier/app/initializers/register-basic-modifier-manager.js

const MANAGER = {
  // ...
};

export function initialize(application) {
  // We want to use a POJO here, so we are opt-ing out of instantiation
  application.register('modifier-manager:basic', MANAGER, { instantiate: false });
}

export default {
  name: 'register-basic-modifier-manager',
  initialize
};
</code></pre>
<a class="header" href="print.html#determining-which-modifier-manager-to-use" id="determining-which-modifier-manager-to-use"><h2>Determining which modifier manager to use</h2></a>
<p>When invoking the modifier <code>&lt;p {{foo baz bar=bar}} /&gt;</code>, Ember will first resolve the
modifier class (<code>modifier:foo</code>, usually the <code>default</code> export from
<code>app/modifiers/foo.js</code>). Next, it will determine the appropiate modifier
manager to use based on the resolved modifier class.</p>
<p>Ember will provide a new API to assign the modifier manager for a element modifier
class:</p>
<pre><code class="language-js">// my-app/app/modifier/foo.js

import EmberObject from '@ember/object';
import { createManager } from './basic-manager';
import { setModifierManager } from '@ember/modifier';

export default setModifierManager(createManager, EmberObject.extend({
  // ...
}));
</code></pre>
<pre><code class="language-js">// my-app/app/modifier/basic-manager.js

// ...

export function createManager(owner) {
  return new BasicManager(owner);
}
</code></pre>
<p><code>setModifierManager</code> takes two parameters. The first parameter is a function that takes an <code>Owner</code> and returns an instance of a manager. The second parameter is the base class that applications would extend from.</p>
<p>In reality, an app developer would never have to write this in their apps,
since the modifier manager would already be assigned on a super-class provided
by the framework or an addon. The <code>setModifierManager</code> function is essentially
a low-level API designed for addon authors and not intended to be used by app
developers. Attempting to reassign the modifier manager when one is already
assinged on a super-class will be an error. If no modifier manager is set, it
will also result in a runtime error when invoking the modifier.</p>
<a class="header" href="print.html#modifier-lifecycle" id="modifier-lifecycle"><h2>Modifier Lifecycle</h2></a>
<p>Back to the <code>&lt;p {{foo baz bar=bar}}&gt;&lt;/p&gt;</code> example.</p>
<p>Once Ember has determined the modifier manager to use, it will be used to manage the modifiers's lifecycle.</p>
<a class="header" href="print.html#createmodifier" id="createmodifier"><h3><code>createModifier</code></h3></a>
<p>The first step is to create an instance of the modifier. Ember will invoke the modifier manager's <code>createModifier</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args);
  },
});
</code></pre>
<p>The <code>createModifier</code> method on the modifier manager is responsible for taking the modifier's factory and the arguments passed to the modifier (the ... in {{foo ...}}) and return an instantiated modifier.</p>
<p>The first argument passed to <code>createModifier</code> is the result returned from the <code>factoryFor</code> API. It contains a class property, which gives you the the raw class (the default export from app/modifiers/foo.js) and a create function that can be used to instantiate the class with any registered injections, merging them with any additional properties that are passed.</p>
<p>The second argument is a snapshot of the arguments passed to the modifier in the template invocation, given in the following format:</p>
<pre><code class="language-js">{
  positional: [ ... ],
  named: { ... }
}
</code></pre>
<p>For example, given the following invocation:</p>
<pre><code class="language-hbs">&lt;p {{foo baz bar=bar}}&gt;&lt;/p&gt;
</code></pre>
<p>You will get the following as the second argument:</p>
<pre><code class="language-js">{
  positional: [true],
  named: {
    &quot;bar&quot;: &quot;Another RFC by Chad&quot;
  }
}
</code></pre>
<p>The arguments object should not be mutated (e.g. args.positional.pop() is no good). In development mode, it might be sealed/frozen to help prevent these kind of mistakes.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called as discovered during DOM construction</li>
<li>called in defintion order in template</li>
</ul>
<a class="header" href="print.html#installmodifier" id="installmodifier"><h3><code>installModifier</code></h3></a>
<p>Once the modifier instance has been created, the next step is to install the modifier on to the underlying element.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  // ...
});
</code></pre>
<p><code>installModifer</code> is responsible for giving access to the underlying element and arguments to the modifier instance.</p>
<p>The first argument passed to <code>installModifer</code> is the result of <code>createModifier</code>. The second argument is the <code>element</code> the modifier was defined on. The third argument is the same snapshot of the arguments passed to the modifier in the template invocation that <code>createModifier</code> recieved.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after all children modifier managers <code>installModifer</code> hook are called</li>
<li>called after DOM insertion</li>
</ul>
<p><strong>May or May Not</strong></p>
<ul>
<li>be called in the same tick as DOM insertion</li>
<li>have the sibling nodes fully initialized in DOM</li>
</ul>
<a class="header" href="print.html#updatemodifier" id="updatemodifier"><h3><code>updateModifier</code></h3></a>
<p>Modifiers are only updated when one of its arguments is changed. In this case Ember will call the manager's <code>updateModifier</code> method to give the manager the oppurtunity to reflect those changes on the modifier instance, before re-rendering.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  updateModifier(instance, args) {
    if (instance.didUpdateArguments !== undefined) {
      instance.didUpdateArguments(args.positional, args.named);
    }
  }

  // ...
});
</code></pre>
<p><code>updateModifier</code> recieves the modifier instance and also the the updated snapshot of arguments.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after the arguments to the modifier have changed</li>
</ul>
<p><strong>Never</strong></p>
<ul>
<li>called if the arguments to the modifier are constants</li>
</ul>
<a class="header" href="print.html#destroymodifier" id="destroymodifier"><h3><code>destroyModifier</code></h3></a>
<p><code>destroyModifier</code> will be called when the modifier is no longer needed. This is intended for performing object-model level cleanup.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  destroyModifier(instance, args) {
    if (instance.willDestroyDOM !== undefined) {
      instance.willDestroyDOM();
    }
  }
});
</code></pre>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after all children modifier manager's <code>destroyModifier</code> hook is called</li>
</ul>
<p><strong>May or May Not</strong></p>
<ul>
<li>be called in the same tick as DOM removal</li>
</ul>
<a class="header" href="print.html#capabilities-1" id="capabilities-1"><h2>Capabilities</h2></a>
<p>In addition to the methods specified above, modifier managers are required to
have a <code>capabilities</code> property.  This property must be set to the result of
calling the <code>capabilities</code> function provided by Ember.</p>
<a class="header" href="print.html#versioning-2" id="versioning-2"><h3>Versioning</h3></a>
<p>The first, mandatory, argument to the <code>capabilities</code> function is the modifier
manager API, which is denoted in the <code>${major}.${minor}</code> format, matching the
minimum Ember version this manager is targeting. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/modifier';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.6'),

  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  destroyModifier(instance, args) {
    if (instance.willDestroyDOM !== undefined) {
      instance.willDestroyDOM();
    }
  }
});
</code></pre>
<p>This allows Ember to introduce new capabilities and make improvements to this
API without breaking existing code.</p>
<p>Here is a hypothical scenario for such a change:</p>
<ol>
<li>
<p>Ember 3.6 implemented and shipped the modifier manager API as described in
this RFC.</p>
</li>
<li>
<p>The <code>ember-basic-modifier</code> addon released version 1.0 with the modifier
manager shown above (notably, it declared <code>capabilities('3.6')</code>).</p>
</li>
<li>
<p>In Ember 3.8, we determined that constructing the arguments object passed to
the hooks is a major performance bottleneck, and changes the API to pass a
&quot;proxy&quot; object with getter methods instead (e.g. <code>args.getPositional(0)</code> and
<code>args.getNamed('foo')</code>).</p>
<p>However, since Ember sees that the <code>basic</code> modifier manager is written to
target the <code>3.6</code> API version, it will retain the old behavior and passes the
old (more expensive) &quot;reified&quot; arguments object instead, to avoid breakage.</p>
</li>
<li>
<p>The <code>ember-basic-modifier</code> addon author would like to take advantage of
this performance optimization, so it updates its modifier manager code to
work with the arguments proxy and changes its capabilities declaration to
<code>capabilities('3.8')</code> in version 2.0.</p>
</li>
</ol>
<p>This system allows us to rapidly improve the API and take advantage of
underlying rendering engine features as soon as they become available.</p>
<p>Note that addon authors are not <em>required</em> to update to the newer API.
Concretely, modifier manager APIs have the following support policy:</p>
<ul>
<li>
<p>API versions will continue to be supported in the same major release of
Ember. As shown in the example above, <code>ember-basic-modifier</code> 1.0 (which
targets modifier manager API version 3.6), will continue to work on
Ember 3.8. However, the reverse is not true – modifier manager API version
3.8 will (somewhat obviously) not work in Ember 3.6.</p>
</li>
<li>
<p>In addition, to ensure a smooth transition path for addon authors and app
developers across major releases, each Ember version will support (at least)
the previous LTS version as of the release was made. For example, if 3.16 is
the last LTS release of the 3.x series, the modifier manager API version
3.16 will be supported by Ember 4.0 through 4.4, at minimum.</p>
</li>
</ul>
<p>Addon authors can also choose to target multiple versions of the modifier
manager API using <a href="https://github.com/pzuraq/ember-compatibility-helpers/">ember-compatibility-helpers</a>:</p>
<pre><code class="language-js">// ember-basic-modifier/app/modifier-managers/basic.js

import { gte } from 'ember-compatibility-helpers';

let ComponentManager;

if (gte('3.5')) {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.8'),

    // ...
  });
} else {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.6'),

    // ...
  });
}

export default ComponentManager;
</code></pre>
<p>Since the conditionals are resolved at build time, the irrevelant code will be
stripped from production builds, avoiding any deprecation warnings.</p>
<a class="header" href="print.html#optional-features-1" id="optional-features-1"><h3>Optional Features</h3></a>
<p>The second, optional, argument to the <code>capabilities</code> function is an object
enumerating the optional features requested by the modifier manager.</p>
<p>In the hypothical example above, while the &quot;reified&quot; arguments objects may be
a little slower, they are certainly easier to work with, and the performance
may not matter to but the most performance critical modifiers. A modifier
manager written for Ember 3.8 (again, only hypothically) and above would be
able to explicitly opt back into the old behavior like so:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.8', {
    reifyArguments: true
  }),

  // ...
});
</code></pre>
<p>In general, we will aim to have the defaults set to as bare-bone as possible,
and allow the component managers to opt into the features they need in a PAYGO
(pay-as-you-go) manner, which aligns with the Glimmer VM philosophy. As the
rendering engine evolves, more and more feature will become optional.</p>
<p>At this time this RFC does not specify any optional capabilties for the initial release.</p>
<a class="header" href="print.html#how-we-teach-this-60" id="how-we-teach-this-60"><h2>How we teach this</h2></a>
<p>What is proposed in this RFC is a low-level primitive. We do not expect most users to interact with this layer directly. Instead, most users will simply benefit from this feature by subclassing these special modifiers provided by addons.</p>
<a class="header" href="print.html#drawbacks-84" id="drawbacks-84"><h2>Drawbacks</h2></a>
<p>In the long term, there is a risk of fragmentating the Ember ecosystem with many competing modifier APIs. However, given the Ember community's strong desire for conventions, this seems unlikely. We expect this to play out similar to the data-persistence story – there will be a primary way to do things (Ember Data), but there are also plenty of other alternatives catering to niche use cases that are underserved by Ember Data.</p>
<a class="header" href="print.html#alternatives-86" id="alternatives-86"><h2>Alternatives</h2></a>
<p>Instead of focusing on exposing enough low-level primitives we can just ship the high level API as described in <a href="https://github.com/emberjs/rfcs/pull/353">RFC#353</a>.</p>
<a class="header" href="print.html#unresolved-questions-60" id="unresolved-questions-60"><h2>Unresolved questions</h2></a>
<p>TBD?</p>
<ul>
<li>Start Date: 2019-09-13</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/375</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-89" id="summary-89"><h1>Summary</h1></a>
<p>Deprecate the computed <code>.property()</code> modifier which can be used to add dependent
keys to computed properties.</p>
<a class="header" href="print.html#motivation-90" id="motivation-90"><h1>Motivation</h1></a>
<p>Currently, computed properties can use the <code>.property</code> modifier to add dependent
keys to a computed <em>after</em> the computed has been declared:</p>
<pre><code class="language-js">foo: computed('strings', {
  get() {
    return this.strings.filter(s =&gt; s.includes(this.filterText));
  }
}).property('filterText')
</code></pre>
<p>In most cases, this ability is redundant, since the dependent keys can be moved
into the original computed declaration and be equivalent:</p>
<pre><code class="language-js">foo: computed('strings', 'filterText', {
  get() {
    return this.strings.filter(s =&gt; s.includes(this.filterText));
  }
})
</code></pre>
<p>The one exception is in the case of computed <em>macros</em>, specifically macros which
accept a <em>function</em> such as <code>filter()</code> and <code>map()</code>:</p>
<pre><code class="language-js">foo: filter('strings', function(s) {
  return s.includes(this.filterText);
}).property('filterText')
</code></pre>
<p>The issue stems from the fact that the inner function can access the class
instance and use dynamic properties from it, and this access is opaque to the
macro.</p>
<p>This API is confusing since it bears a strong resemblance to the older style
of computed property declarations, and at first glance appears to be invalid.
The few edge-case macros where it does legitimately apply can be rewritten to
accept more dependent keys, making it fully redundant.</p>
<a class="header" href="print.html#transition-path-12" id="transition-path-12"><h1>Transition Path</h1></a>
<p>As mentioned above, macros which receive a callback function as an argument are
the only valid use of <code>.property()</code> in current Ember. Currently, there are two
such macros in Ember core: <code>map</code> and <code>filter</code>.</p>
<p>This RFC proposes that these macros be updated to receive additional dependent
keys via their public API directly via an optional second parameter which is an
array of the keys:</p>
<pre><code class="language-ts">function filter(filteredPropertyKey: string, callback: Function): ComputedProperty;
function filter(
  filteredPropertyKey: string,
  additionalDependentKeys: string[],
  callback: Function
): ComputedProperty;

function map(mappedPropertyKey: string, callback: Function): ComputedProperty;
function map(
  mappedPropertyKey: string,
  additionalDependentKeys: string[],
  callback: Function
): ComputedProperty;
</code></pre>
<a class="header" href="print.html#deprecation-timeline-1" id="deprecation-timeline-1"><h2>Deprecation Timeline</h2></a>
<p>The deprecation should follow these steps:</p>
<ul>
<li>Update <code>filter</code> and <code>map</code> to their new APIs</li>
<li>Add a deprecation warning to uses of <code>.property</code> which add dependent keys to
computed properties.</li>
<li>Add an optional feature to turn the deprecation into an assertion</li>
<li>After enough time has passed for addons and users to update, enable the
optional feature by default in new addons and apps</li>
<li>Fully remove <code>.property()</code> in Ember v4.0.0</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-61" id="how-we-teach-this-61"><h1>How We Teach This</h1></a>
<p>In most cases, we shouldn't have to teach anything. There are already linting
rules prohibiting <code>.property()</code> usage, and the recommended path is to provide
all dependent keys in the original declaration of the computed property. For
users of <code>map</code> and <code>filter</code> we should ensure that they new documentation is
clear on how to add dependent keys to either macro.</p>
<p>For addon authors that have created their own macros which rely on callbacks and
have similar issues, we should demonstrate how they can structure their macro
API to accept additional dependent keys.</p>
<a class="header" href="print.html#drawbacks-85" id="drawbacks-85"><h1>Drawbacks</h1></a>
<p>The new proposed APIs for <code>filter</code> and <code>map</code> may be somewhat confusing, since
only the first argument will be filtered/mapped</p>
<a class="header" href="print.html#alternatives-87" id="alternatives-87"><h1>Alternatives</h1></a>
<p>We could allow additional dependent keys to be passed via an options argument:</p>
<pre><code class="language-ts">filter(dependentKey: string, options: {
  additionalDependentKeys: [],
  callback: Function,
}): ComputedProperty;

map(dependentKey: string, options: {
  additionalDependentKeys: [],
  callback: Function,
}): ComputedProperty;
</code></pre>
<p>This is more verbose, but would be very clear.</p>
<ul>
<li>Start Date: 2018-10-07</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/386</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#remove-jquery-by-default" id="remove-jquery-by-default"><h1>Remove jQuery by default</h1></a>
<a class="header" href="print.html#summary-90" id="summary-90"><h2>Summary</h2></a>
<p>This RFC proposes deprecating those public APIs that are coupled to jQuery, and to finally remove them (with an optional
backport), so Ember apps will be built <em>by default</em> without bundling jQuery.</p>
<p>While <a href="https://emberjs.github.io/rfcs/0294-optional-jquery.html">RFC294</a>, which is already implemented, provides
a way to opt out of jQuery, the intention of this RFC is to push this a step further and essentially move from the
current &quot;included by default, allow opt out&quot; strategy to &quot;excluded by default, allow opt in&quot;.</p>
<p>In that way it is not meant as a replacement of the previous RFC, but rather as a continuation and the logical next step.</p>
<a class="header" href="print.html#motivation-91" id="motivation-91"><h2>Motivation</h2></a>
<a class="header" href="print.html#lean-by-default" id="lean-by-default"><h3>Lean by default</h3></a>
<p>This follows the philosophy of making Ember leaner (or <em>higher octane</em> if you want), by deprecating unused or
non-essential APIs.
New apps will be smaller and faster by default, while allowing to opt-in into using jQuery when needed.</p>
<a class="header" href="print.html#why-the-current-opt-out-strategy-is-not-sufficient" id="why-the-current-opt-out-strategy-is-not-sufficient"><h3>Why the current opt-out strategy is not sufficient</h3></a>
<p>The biggest problem in the current opt-out strategy is that many addons still require jQuery. Many of these usages
seem to be rather &quot;accidental&quot;, in that the full power of jQuery is not really needed for the given task, and could be
rather easily refactored to use only native DOM APIs. But as it is available anyway by default, and it is very convenient,
authors probably tend to use it without being fully aware of the consequences, that it prohibits jQuery-less builds for
all its consumers.</p>
<p>In that way the general availability of jQuery <em>by default</em> and Ember APIs around it like <code>this.$()</code> tend to manifest the
status quo, the coupling of Ember to jQuery. In fact I could observe an actual <em>increase</em> of jQuery usage numbers
(see below), rather than a decrease, which was an intention of the previous RFC. So it is not only a concern of the core
Ember library to enable jQuery-less builds, but the whole addon ecosystem has to go through that transition.</p>
<p>In that regard early deprecations will help prevent this accidental use of jQuery on the one side, and on the other side
for addons that depend on jQuery already they will provide an incentive and a long enough transition period to refactor
their jQuery usage to use standard DOM APIs.</p>
<a class="header" href="print.html#jquery-might-still-be-needed" id="jquery-might-still-be-needed"><h3>jQuery might still be needed</h3></a>
<p>This RFC does not propose to discourage the use of jQuery. There are legitimate cases where you still want to have it.
And this is also true for addons, especially those that basically wrap other jQuery-based libraries like jQuery plugins
in an Ember friendly way. For those cases, there should be an <em>opt-in</em> path to continue bundling jQuery and to preserve
the existing APIs around it. This is what the <code>@ember/jquery</code> package is meant for.</p>
<a class="header" href="print.html#transition-path-13" id="transition-path-13"><h2>Transition path</h2></a>
<a class="header" href="print.html#add-deprecations" id="add-deprecations"><h3>Add deprecations</h3></a>
<p>All current public APIs that are coupled to jQuery should be deprecated via the usual deprecation process.
This specifically involves:</p>
<ul>
<li>adding a (universal, non-silenceable) deprecation warning to <code>Ember.$()</code></li>
<li>adding a deprecation warning to <code>this.$()</code> in an <code>Ember.Component</code></li>
<li>adding a deprecation warning to <code>this.$()</code> in component integration tests, based on <code>setupRenderingTest()</code></li>
</ul>
<a class="header" href="print.html#this-in-old-style-tests" id="this-in-old-style-tests"><h3><code>this.$()</code> in old style tests</h3></a>
<p><code>this.$()</code> in tests based on the old <code>moduleForComponent()</code> based testing APIs will not be specifically deprecated,
as these legacy testing APIs will eventually be deprecated altogether, as already envisaged in RFC232.</p>
<a class="header" href="print.html#extend-emberjquery-package" id="extend-emberjquery-package"><h3>Extend <code>@ember/jquery</code> package</h3></a>
<p>For apps and addons that have to or choose to still require jQuery, they can add this package to its dependencies.
This will provide a way to retain the deprecated and later removed APIs. So by adding this to your dependencies this
would effectively be the way to <em>opt-in</em> to require jQuery.</p>
<p>RFC294 already introduced this package, being responsible to include jQuery into the JavaScript bundle. As part of this
RFC the scope of this addon will be extended to also reintroduce the deprecated APIs, but <em>without</em> triggering any
deprecation warnings for <code>this.$()</code> in a component.</p>
<p>As the default <code>EventDispatcher</code>, which currently dispatches jQuery events when jQuery is enabled, will eventually
support native events only (see the Timeline below), the addon also needs to replace it with one that again dispatches
jQuery events for compatibility with existing jQuery-based code. This can happen in a similar way as
<a href="https://github.com/rwjblue/ember-native-dom-event-dispatcher">ember-native-dom-event-dispatcher</a> did it, just the other
way around.</p>
<p><strong>This effectively makes the integration of jQuery a feature of this addon, rather than Ember itself, which is freed from
the burden to care about this.</strong></p>
<p>So effectively, for the Ember 3.x release cycle, adding this package will not change the behavior in any significant way,
other than removing the mentioned deprecation warnings, as Ember will still have these APIs available. However starting
with Ember 4.0, which will have these APIs removed and not include jQuery integration features anymore, this
package will make sure jQuery remains included and it will add the now removed APIs back again, so any jQuery depending
code will continue to work just as before. Also see the timeline below.</p>
<p>As <code>ember-cli-babel</code> will currently transform <code>import $ from 'jquery';</code> to use <code>Ember.$</code> again, it must be made aware of
the <code>@ember/jquery</code> package so it tells <code>babel-plugin-ember-modules-api-polyfill</code> not to convert those imports to the
global <code>Ember.$</code>. Instead the package itself should provide the necessary shim to make <code>import $ from 'jquery';</code> work.</p>
<p>Addons that continue to depend on jQuery would have to list this package as a dependency in their <code>package.json</code>,
to make their consuming app automatically include jQuery and the related APIs in its bundle as mentioned above.
Thereby they make their dependency on jQuery explicit, which in turn helps users to make an educated choice if they
deem this to be acceptable.</p>
<a class="header" href="print.html#extend-ember-fetch" id="extend-ember-fetch"><h3>Extend ember-fetch</h3></a>
<p>The <code>ember-fetch</code> addon integrates the newer <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>Fetch API</code></a>
nicely into an Ember app, with an (optional) polyfill for older browsers. This can be used as a replacement for the
jQuery-based <code>ember-ajax</code>.</p>
<p>One piece that is missing so far when switching is a convenient way to customize all outgoing requests, e.g. to add
HTTP headers for authentication tokens. When using jQuery's AJAX implementation, this could be easily done using its
<a href="http://api.jquery.com/jquery.ajaxprefilter/"><code>prefilter</code></a> function. To facilitate something similar when using
<code>ember-fetch</code>, the addon should be extended with an appropriate API, e.g. by adding a simple service through which
fetch requests are issued, which provides similar features for customization. The exact API of such a service is however
out of scope for this RFC.</p>
<a class="header" href="print.html#make-ember-data-use-ember-fetch" id="make-ember-data-use-ember-fetch"><h3>Make ember-data use ember-fetch</h3></a>
<p>It must be ensured that all parts of the core Ember experience work flawlessly without jQuery. Currently <code>ember-data</code>
is still relying on jQuery for its XHR requests. By the time this RFC is implemented (i.e. the deprecation messages are
added), it must work out of the box without jQuery.</p>
<p>Fortunately <a href="https://github.com/emberjs/data/pull/5386">migration efforts</a> are well advanced to support the <code>fetch</code> API
through <code>ember-fetch</code>, so we can expect that to land soon enough that it does not block the transition.</p>
<a class="header" href="print.html#update-app-blueprint" id="update-app-blueprint"><h3>Update app blueprint</h3></a>
<p>The blueprint to create a new app with <code>ember new</code> should be updated to not use jQuery by default. This involves to</p>
<ul>
<li>disable jQuery integration by default (in <code>config/optional-features.json</code>)</li>
<li>remove the <code>@ember/jquery</code> package</li>
<li>replace <code>ember-ajax</code> with <code>ember-fetch</code></li>
<li>add the <a href="https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-jquery.md"><code>no-jquery</code></a> rule to the
default ESLint config</li>
</ul>
<a class="header" href="print.html#timeline-2" id="timeline-2"><h3>Timeline</h3></a>
<p>During Ember 3.x:</p>
<ol>
<li>migrate the jQuery integration features to the <code>@ember/jquery</code> package</li>
<li>update the blueprints as stated above</li>
<li>add deprecation warnings as stated above</li>
</ol>
<p>Upon Ember 4.0</p>
<ul>
<li>remove deprecated functions</li>
<li>remove the jQuery specific code paths in the <code>EventDispatcher</code></li>
</ul>
<a class="header" href="print.html#how-we-teach-this-62" id="how-we-teach-this-62"><h2>How we teach this</h2></a>
<p>As part of the efforts to make jQuery optional, the guides have already been updated to have all examples teach native
DOM APIs instead of jQuery, and the new testing APIs.
The <a href="https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_jquery-integration">jQuery migration guide</a>
already mentions the APIs that are not available anymore without jQuery and how to opt-out now.</p>
<p>Activating the <code>no-jquery</code> ESLint rule will warn developers about any usages of the jQuery-based APIs being deprecated
here.</p>
<p>The newly added deprecation messages should link to a deprecation guide, which will provide details on how to silence
these deprecations, either by using native DOM APIs only or by installing <code>@ember/jquery</code> to explicitly opt-in into
jQuery.</p>
<p>For apps the tone of it should be neutral regarding jQuery itself, in the sense that using jQuery is neither
bad nor good by itself. It depends on the context of the app if using jQuery makes sense or not. It is just that <em>Ember</em>
does no need it anymore, so it is not part of the default Ember experience anymore.</p>
<p>For addons the story is a bit different, in that they are not aware of their app's context, so they should abstain from
using jQuery if possible. See the <a href="print.html#motivation">Motivation</a> chapter above.</p>
<a class="header" href="print.html#drawbacks-86" id="drawbacks-86"><h2>Drawbacks</h2></a>
<a class="header" href="print.html#churn-3" id="churn-3"><h3>Churn</h3></a>
<p>A vast amount of addons still depend on jQuery, so adding the deprecations will add some considerable churn for the addon
ecosystem. As of writing this, there are:</p>
<ul>
<li><a href="https://emberobserver.com/code-search?codeQuery=Ember.%24">407 addons</a> using <code>Ember.$</code></li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=addon%2Fcomponents">546 addons</a> using <code>this.$</code> in components</li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=tests">994 addons</a> using <code>this.$</code> in tests</li>
</ul>
<p>A good amount of that churn can be mitigated by</p>
<ul>
<li>existing codemods that migrate tests</li>
<li>having an easy way, given by the <code>@ember/jquery</code> package, to opt-in to continue bundling jQuery, and to restore the
deprecated APIs, so no further refactorings are required</li>
</ul>
<a class="header" href="print.html#alternatives-88" id="alternatives-88"><h2>Alternatives</h2></a>
<p>Stick to the current <em>opt-out</em> process.</p>
<ul>
<li>Start Date: 2018-10-22</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/391</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#router-helpers" id="router-helpers"><h1>Router Helpers</h1></a>
<a class="header" href="print.html#summary-91" id="summary-91"><h2>Summary</h2></a>
<p>This RFC introduces new router helpers that represent a decomposition of functionality of what we commonly use <code>{{link-to}}</code> for. Below is a list of the new helpers:</p>
<pre><code class="language-hbs">{{url-for}}
{{root-url}}
{{is-active}}
{{is-loading}}
{{is-transitioning-in}}
{{is-transitioning-out}}
</code></pre>
<p>This represents a super set of the functionality provided by <a href="https://github.com/rwjblue/ember-router-helpers/">Ember Router Helpers</a> which has provided this RFC that confidence that a decomposition is possible.</p>
<p>This RFC does <strong>not</strong> deprecate <code>{{link-to}}</code> or <code>{{query-params}}</code>. These deprecations will come in the form of a deprecation RFC.</p>
<a class="header" href="print.html#motivation-92" id="motivation-92"><h2>Motivation</h2></a>
<p><code>{{link-to}}</code> is the primary way for Ember applications to transition from route to route in your application. While this works for a lot of cases there are some use cases that are not well supported or supported at all by the framework. Below is an enumeration of cases that <code>{{link-to}}</code> does not address.</p>
<a class="header" href="print.html#anchor-tags" id="anchor-tags"><h3>Anchor Tags</h3></a>
<p>We currently do not have a good solution for transitioning solely based on HTML anchors defined in the templating layer. For instance let say you are using <a href="https://github.com/ember-intl/ember-intl">Ember Intl</a> to do internationalization for your application. Ember Intl uses the <a href="http://userguide.icu-project.org/formatparse/messages">ICU message format</a> for the actual translation strings and supports having HTML within the string. Now lets say you want to put a link in a translation string and have it work like <code>{{link-to}}</code> works. In that case you either have to roll your own solution or use something like <a href="https://github.com/intercom/ember-href-to">Ember-href-to</a>. Another example where this would be useful is that links within markdown produced by addons like <a href="https://github.com/gcollazo/ember-cli-showdown">Ember-CLI-Showdown</a> would just work. API's like <code>RouterService#transitionTo</code> can transition an application using relative URLs and we have an opportunity to leverage this functionality to support this use case.</p>
<a class="header" href="print.html#extensibility-of-link-to" id="extensibility-of-link-to"><h3>Extensibility Of <code>{{link-to}}</code></h3></a>
<p>In 2.11 we moved <code>LinkComponent</code> from <code>private</code> to <code>public</code> largely because there was no other way to modify the behavior of <code>{{link-to}}</code> and it had effectively become de-facto public API. That being said, it is less than desirable to <code>reopen</code> or <code>extend</code> framework objects to gain access to the functionality to create some application specific primitive. For example <a href="https://github.com/kaliber5/ember-bootstrap/">Ember Bootsrap</a> extends the <a href="https://github.com/kaliber5/ember-bootstrap/blob/master/addon/components/base/bs-dropdown/menu/link-to.js"><code>LinkComponent</code></a> and then layers more functionality on top of it. Addons would be better served if they had access to more primitive functionality.</p>
<a class="header" href="print.html#css-class-magic" id="css-class-magic"><h3>CSS Class Magic</h3></a>
<p><code>{{link-to}}</code> adds some convienent, yet not obvious, classes to the element. These classes are:</p>
<ul>
<li><code>active</code>: applied to any <code>{{link-to}}</code> that is on the &quot;active&quot; path</li>
<li><code>disabled</code>: applied depending on the evaluation of <code>disabled=someBool</code></li>
<li><code>loading</code>: applied if one or more of the models passed are <code>undefined</code></li>
<li><code>ember-transitioning-in</code>: applied to links that are about to be <code>active</code></li>
<li><code>ember-transitioning-out</code>: applied to links that are about to be deactivated</li>
</ul>
<p>The issue with these class names is that they are not declared anywhere in your templated and are provided by the <code>LinkComponent</code> as <code>classNameBindings</code>. This effectively creates a set of reserved class names that are highly prone to colissions in your typical application.</p>
<p>Furthermore, addons like <a href="https://github.com/alexspeller/ember-cli-active-link-wrapper">ember-cli-active-link-wrapper</a> and <a href="https://github.com/zoltan-nz/ember-bootstrap-nav-link">ember-bootstarp-nav-link</a> do a ton of work arounds to get things like the <code>.active</code> class to show up on wrapping elements instead of the element directly. This is a great example that shows we are missing some primitives.</p>
<a class="header" href="print.html#default-query-param-serialization" id="default-query-param-serialization"><h3>Default Query Param Serialization</h3></a>
<p>Lastly, <code>{{link-to}}</code> has very strange behavior when it comes to serializing query params. On a controller you declare the query params for a specific route. These query params can have defaults for them. For example if you have a controller that looks like:</p>
<pre><code class="language-js">// app/controllers/profile.js
import Controller from '@ember/controller';

export default Controller.extend({
  queryParams: ['someBool'],
  someBool: true,
})
</code></pre>
<p>and you to link to it like this:</p>
<pre><code class="language-hbs">{{#link-to 'profile'}}Profile{{/link-to}}
</code></pre>
<p>In the DOM you will have an <code>href</code> on the anchor that gets serializes as:</p>
<pre><code class="language-html">&lt;a href=&quot;/profile?someBool=true&quot; class=&quot;active ember-view&quot;&gt;Profile&lt;/a&gt;
</code></pre>
<p>Looking at a template you would have no idea that rendering the <code>{{link-to}}</code> would result in the query params being serialized. From an implementation point of view, this is problematic as we are forced to <code>lookup</code> the <code>Route</code> and the associated <code>Controller</code> to grab the query params. This can add a non-trivial amount of overhead during rendering, especially if you have many <code>{{link-to}}</code>s on a route that link many different parts of your application. As a side-note, this is one of the things  that needs to be dealt with if we are ever to kill controllers.</p>
<a class="header" href="print.html#does-not-work-with-angle-bracket-invocation" id="does-not-work-with-angle-bracket-invocation"><h3>Does Not Work With Angle Bracket Invocation</h3></a>
<p>Since angle bracket invocation does not support positional params, <code>{{link-to}}</code> has to adapt it's public API.</p>
<a class="header" href="print.html#costly-api" id="costly-api"><h3>Costly API</h3></a>
<p><code>{{link-to}}</code> has <a href="print.html#kitchen-sink">a lot of functionality</a>, however this functionality does come at a cost for every instance of <code>{{link-to}}</code>. This is not ideal especially if you're just using <code>{{link-to}}</code> to generate a url that can be transitioned to. By providing fine grain control of the functionality, applications should see a performance boost.</p>
<a class="header" href="print.html#detailed-design-78" id="detailed-design-78"><h2>Detailed design</h2></a>
<p>Below is a detailed design of all of the template helpers.</p>
<a class="header" href="print.html#url-generation-helpers" id="url-generation-helpers"><h3>URL Generation Helpers</h3></a>
<p>The following helpers are to be used to construct a valid root-relative URL that will be used by the event dispatcher to perform a transition. These helpers <strong>do not</strong> pass the in memory model, meaning the model hook will always run for the route you are transitioning to.</p>
<a class="header" href="print.html#url-for-helper" id="url-for-helper"><h3><code>{{url-for}}</code> Helper</h3></a>
<pre><code class="language-hbs">{{url-for routeName model queryParams=(hash a=a)}}
</code></pre>
<p>Or</p>
<pre><code class="language-hbs">{{url-for routeName models=model queryParams=(hash a=a)}}
</code></pre>
<p><code>{{url-for}}</code> generates a root-relative URL as a string (which will include the application's rootUrl). When the link is clicked it will cause a transition to occur. See the <a href="print.html#event-dispatcher-changes">Event Dispatcher Changes</a>. It will not serialize the default query params on the controller.</p>
<a class="header" href="print.html#signature-explainer" id="signature-explainer"><h4>Signature Explainer</h4></a>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models or identifiers for each dynamic segment to be use for generation.</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>: Optionally pass key value pairs that will be serialized</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>String</em>: a root-relative URL as a string (which will include the application's <code>rootUrl</code>)</li>
</ul>
<a class="header" href="print.html#root-url-helper" id="root-url-helper"><h3><code>{{root-url}}</code> Helper</h3></a>
<p><code>{{root-url}}</code> simply returns the value from <code>Application.rootURL</code>. It can be used to prefix any <code>href</code> values you wish to hard code.</p>
<pre><code class="language-hbs">&lt;a href=&quot;{{root-url}}profile&quot;&gt;Profile&lt;/a&gt;
</code></pre>
<p>Will result in the following for the default configuration:</p>
<pre><code class="language-html">&lt;a href=&quot;/profile&quot;&gt;Profile&lt;/a&gt;
</code></pre>
<a class="header" href="print.html#signature-explainer-1" id="signature-explainer-1"><h4>Signature Explainer</h4></a>
<p><code>{{root-url}}</code> does not take any parameters.</p>
<a class="header" href="print.html#route-state-helpers" id="route-state-helpers"><h3>Route State Helpers</h3></a>
<p>The following helpers are all <em>context dependent</em>, not global. For instance you might have two copies of <code>(is-active &quot;posts&quot;)</code> in your app simultaneously where one is <code>true</code> and one is <code>false</code>, because you're in the middle of an animated transition, or because you're pre-rendering a route that hasn't been entered yet.</p>
<a class="header" href="print.html#is-active-helper" id="is-active-helper"><h3><code>{{is-active}}</code> Helper</h3></a>
<pre><code class="language-hbs">{{is-active 'people.index' model queryParams=(hash a=a)}}
</code></pre>
<p>or</p>
<pre><code class="language-hbs">{{is-active 'people.index' models=model queryParams=(hash a=a)}}
</code></pre>
<p>The arguments to <code>{{is-active}}</code> have the same semantics as <code>{{url-for}}</code>, however the return value is a boolean. This should provide the same logic that determines whether to put an <code>active</code> class on a <code>{{link-to}}</code>.</p>
<a class="header" href="print.html#signature-explainer-2" id="signature-explainer-2"><h4>Signature Explainer</h4></a>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models to use for generation</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>: Optionally pass key value pairs that will be used to determine if the route is active.</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>Boolean</em>: Determines if the route is active or not.</li>
</ul>
<a class="header" href="print.html#is-loading-helper" id="is-loading-helper"><h3><code>{{is-loading}}</code> Helper</h3></a>
<pre><code class="language-hbs">{{is-loading 'people.index' model queryParams=(hash a=a)}}
</code></pre>
<p>Or</p>
<pre><code class="language-hbs">{{is-loading 'people.index' models=model queryParams=(hash a=a)}}
</code></pre>
<p>The arguments to <code>{{is-loading}}</code> have the same semantics as <code>{{url-for}}</code> and <code>{{is-active}}</code>, however if any of the model(s) passed to it are unresolved e.g. evaluate to <code>undefined</code> the helper will return <code>true</code>, otherwise the helper will return <code>false</code>. This should provide the same logic that determines whether to put an <code>loading</code> class on a <code>{{link-to}}</code>.</p>
<a class="header" href="print.html#signature-explainer-3" id="signature-explainer-3"><h4>Signature Explainer</h4></a>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models to use for generation</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>: Optionally pass key value pairs that will be used to determine if the route is loading.</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>Boolean</em>: Determines if the route is loading or not.</li>
</ul>
<a class="header" href="print.html#is-transitioning-in-helper" id="is-transitioning-in-helper"><h3><code>{{is-transitioning-in}}</code> Helper</h3></a>
<pre><code class="language-hbs">{{is-transitioning-in 'people.index' model queryParams=(hash a=a)}}
</code></pre>
<p>Or</p>
<pre><code class="language-hbs">{{is-transitioning-in 'people.index' models=model queryParams=(hash a=a)}}
</code></pre>
<p>The arguments to <code>{{is-transitioning-in}}</code> have the same semantics as all the other route state helpers, however <code>{{is-transitioning-in}}</code> only returns <code>true</code> when the route is going from an non-active to an active state. This should provide the same logic that determines whether to put an <code>ember-transition-in</code> class on a <code>{{link-to}}</code>.</p>
<a class="header" href="print.html#signature-explainer-4" id="signature-explainer-4"><h4>Signature Explainer</h4></a>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models to use for generation</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>:  Optionally pass key value pairs that will be used to determine if the route is transitioning in.</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>Boolean</em>: Determines if the route is transitioning in.</li>
</ul>
<a class="header" href="print.html#is-transitioning-out-helper" id="is-transitioning-out-helper"><h3><code>{{is-transitioning-out}}</code> Helper</h3></a>
<pre><code class="language-hbs">{{is-transitioning-out 'people.index' model queryParams=(hash a=a)}}
</code></pre>
<p>Or</p>
<pre><code class="language-hbs">{{is-transitioning-out 'people.index' models=model queryParams=(hash a=a)}}
</code></pre>
<p><code>{{is-transitioning-out}}</code> is just the inverse of <code>{{is-transitioning-in}}</code>.</p>
<a class="header" href="print.html#signature-explainer-5" id="signature-explainer-5"><h4>Signature Explainer</h4></a>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models to use for generation</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>:  Optionally pass key value pairs that will be used to determine if the route is transitioning out.</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>Boolean</em>: Determines if the route is transitioning out.</li>
</ul>
<a class="header" href="print.html#event-dispatcher" id="event-dispatcher"><h3>Event Dispatcher</h3></a>
<p>In the past, only <code>HTMLAnchorElement</code>s that were produced by <code>{{link-to}}</code>s would produce a transition when a user clicked on them. This RFC changes to the global <code>EventDispatcher</code> to allow for any <code>HTMLAnchorElement</code> with a valid root relative <code>href</code> to cause a transition. This will allow for us to not only allows us to support use cases like the ones described in the <a href="print.html#anchor-tags">motivation</a>, it makes teaching easier since people who know HTML don't need know an Ember specific API to participate in routing transitions.</p>
<a class="header" href="print.html#route-globs-and-route-blacklisting" id="route-globs-and-route-blacklisting"><h4>Route Globs And Route Blacklisting</h4></a>
<p>While the vast majority of the time developers want root relative URLs to cause a transition there are cases where you want root relative urls to cause a normal HTTP navigation. In the router map you can define <a href="https://guides.emberjs.com/release/routing/defining-your-routes/#toc_wildcard--globbing-routes">wildcard / globbing</a> that makes this problematic as any root relative url can be catched by a wildcard route. To solve this issue this RFC proposes expanding the route options to allow for a black list of urls that are allowed to cause a normal HTTP navigation.</p>
<pre><code class="language-js">Router.map(function() {
  this.route('not-found', { path: '/*path', blacklist: ['/contact-us', '/order/:order_id'] });
});
</code></pre>
<p>When an event comes into the <code>EventDispatcher</code> we will cross check the blacklist to see if the event should be let through to the browser or if it should be handled internally.</p>
<a class="header" href="print.html#transition-attribution" id="transition-attribution"><h3>Transition Attribution</h3></a>
<p>This RFC introduces the notion of an <code>attribution</code> to the <code>Transition</code>. The <code>TransitionAttribution</code> is a read-only object that has 2 fields <code>event</code> and <code>source</code>.</p>
<pre><code class="language-ts">interface TransitionAttribution {
  readonly event: Maybe&lt;Event&gt;;
  readonly source: unknown
}

interface Transition {
  readonly attribution: TransitionAttribution;
}
</code></pre>
<p>On initial render <code>event</code> and <code>source</code> will be <code>null</code>. On subsequent transitions, the <code>event</code> will be the DOM event that caused the transition and <code>element</code> will be populated with <code>HTMLElement</code> that the user interacted with to cause the transition. See <a href="print.html#appendix-a">Appendix A</a> for example usage. In the event that the transition occurs programmatically through an API like <code>replaceWith</code> or <code>transitionTo</code> the <code>event</code> will be <code>null</code> but can be <a href="print.html#programatic-attribution">populated by the caller</a>.</p>
<a class="header" href="print.html#programatic-attribution" id="programatic-attribution"><h4>Programatic Attribution</h4></a>
<p>In cases where you need to programatically transition with <code>transitionTo</code> or <code>replaceWith</code> we will allow for you to pass your own <code>TransitionAttribution</code>. See Appendix B for an example.</p>
<pre><code class="language-ts">interface Options {
  queryParams?: Dict&lt;string|number&gt;,
  attribution?: TransitionAttribution;
}

interface Router /* Route, RouterService */ {
  //...
  transitionTo(routeName: string, models?: string|number|object, options?: Options): Transition;
  replaceWith(routeName: string, models?: string|number|object, options?: Options): Transition;
}
</code></pre>
<a class="header" href="print.html#transitionattribution-integrity" id="transitionattribution-integrity"><h4><code>Transition.attribution</code> Integrity</h4></a>
<p>The <code>attribution</code> in a <code>Transition</code> is guaranteed to be carried through the completion of the route transition. This includes <code>abort</code>s, <code>redirect</code>s and <code>retry</code>s of the transition. The <code>attribution</code> field is readonlu and the <code>TransitionAttribution</code> is readonly and frozen.</p>
<a class="header" href="print.html#migration-path-2" id="migration-path-2"><h2>Migration Path</h2></a>
<p>Since this RFC does not deprecate <code>{{link-to}}</code> you can continue to use it. That being said <code>{{link-to}}</code> has static semantics therefore we can write a codemod using <a href="https://github.com/ember-template-lint/ember-template-recast">Ember Template Recast</a> to migrate the code. Below are numerous before and after examples of how the codemod would migrate. It's important to note that the behavior of the application <a href="print.html#url-generation-helpers">will change</a> if you are relying on the passing of the in-memory model. Because of this the codemod would need different levels of converstion.</p>
<a class="header" href="print.html#basic-link-to" id="basic-link-to"><h3>Basic <code>{{link-to}}</code></h3></a>
<p><strong>Before:</strong></p>
<pre><code class="language-hbs">{{#link-to 'profile' class=&quot;profile&quot;}}Profile{{/link-to}}
{{link-to 'About' 'about'}}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-hbs">&lt;a href={{url-for 'profile'}} class=&quot;profile&quot;&gt;Profile&lt;/a&gt;
&lt;a href={{url-for 'about'}}&gt;About&lt;/a&gt;
</code></pre>
<a class="header" href="print.html#with-model-link-to" id="with-model-link-to"><h3>With Model <code>{{link-to}}</code></h3></a>
<p><strong>Before:</strong></p>
<pre><code class="language-hbs">{{#link-to 'profile' this.profile class=&quot;profile&quot;}}Profile{{/link-to}}
{{link-to 'About' 'about' this.contact}}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-hbs">&lt;a class=&quot;profile&quot; href={{url-for 'profile' this.profile}}&gt;Profile&lt;/a&gt;
&lt;a href={{url-for 'about' this.contact}}&gt;About&lt;/a&gt;
</code></pre>
<a class="header" href="print.html#with-query-params-link-to" id="with-query-params-link-to"><h3>With Query Params <code>{{link-to}}</code></h3></a>
<p><strong>Before:</strong></p>
<pre><code class="language-hbs">{{#link-to 'post' this.post (query-params order=&quot;CHRON&quot;)}}{{this.post.name}}{{/link-to}}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-hbs">&lt;a href={{url-for 'post' this.post queryParms=(hash order=&quot;CHRON&quot;)}}&gt;{{this.post.name}}&lt;/a&gt;
</code></pre>
<p>One of the trickier parts about this migration is knowing how the autogenerated CSS classes are being used. Because of this, adding the route state helpers must explicitly be turned on in the codemod. For instance if you are making heavy use of the <code>.active</code> class, you will be suited best by turning pass the codemod the correct configuration to do a transform like the following:</p>
<p><strong>Before</strong></p>
<pre><code class="language-hbs">{{#link-to 'profile'}}Profile{{/link-to}}
</code></pre>
<p><strong>After</strong></p>
<pre><code class="language-hbs">&lt;a href={{url-for 'profile'}} class={{if (is-active 'profile') 'active'}}&gt;Profile&lt;/a&gt;
</code></pre>
<a class="header" href="print.html#kitchen-sink" id="kitchen-sink"><h4>Kitchen Sink</h4></a>
<p>If you were to transform all <code>{{link-to}}</code>s verbatim in terms of functionality this would be the result.</p>
<p><strong>Before</strong></p>
<pre><code class="language-hbs">{{#link-to 'profile' model (query-parmas foo=bar) replace=true}}Profile{{/link-to}}
</code></pre>
<p><strong>After</strong></p>
<pre><code class="language-hbs">&lt;a
  href={{url-for 'profile'
    model
    queryParams=(hash foo=bar)}}
  class=&quot;{{if (is-active 'profile' model queryParams=(hash foo=bar)) 'active'}} {{if (is-loading 'profile' model queryParams=(hash foo=bar)) 'loading'}} {{if (is-transitioning-in 'profile' model queryParams=(hash foo=bar)) 'ember-transitioning-in'}} {{if (is-transitioning-out 'profile' model queryParams=(hash foo=bar)) 'ember-transitioning-out'}}&quot;&gt;Profile&lt;/a&gt;
</code></pre>
<p>As the kitchen sink example shows, <code>{{link-to}}</code> is packed with functionality. While this convienent, it comes with a cost per <code>{{link-to}}</code> and is the reason why addons like <a href="https://github.com/intercom/ember-href-to">Ember-href-to</a> were created. In reality the vast majority of applications only need a subset of this functionality and in only rare cases need things like the transition and loading states.</p>
<a class="header" href="print.html#how-we-teach-this-63" id="how-we-teach-this-63"><h2>How we teach this</h2></a>
<p>In many ways this vastly simplifies the Ember's approach to linking within the app. It removes the requirement for a proprietary API and instead embraces the power of URLs.</p>
<p>In the cases where you do need to do more complicated things like pass in memory models to a route, things should feel very similar to <code>{{link-to}}</code> as they have the exact same signature. In the case of query param serialization, I believe we are actually aligning a mental model as to how URL generation should work.</p>
<a class="header" href="print.html#drawbacks-87" id="drawbacks-87"><h2>Drawbacks</h2></a>
<p>This RFC expands the surface area of the templating layer by exposing the primitives that make up <code>{{link-to}}</code>. This may cause confusion of choosing between using simple basic anchor tags, <code>{{url-for}}</code> and <code>{{link-to}}</code>, however I believe that each one of the these APIs are solving a real problem that we have in Ember today.</p>
<p>By proxy this may cause people to encapsulate all of these primitives into a single component and thus creating a user-land version of <code>{{link-to}}</code>. This could be seen as a framework misstep if the majority of applications end up depending on the addon.</p>
<a class="header" href="print.html#alternatives-89" id="alternatives-89"><h2>Alternatives</h2></a>
<p>We could just start deprecating and removing functionality from <code>{{link-to}}</code> it self. That being said, it is hard to understand how much of the community is reliant on certain feature of <code>{{link-to}}</code>. This also doesn't help with usecases like the i18n and markdown use cases.</p>
<a class="header" href="print.html#unresolved-questions-61" id="unresolved-questions-61"><h2>Unresolved questions</h2></a>
<p>TBD?</p>
<a class="header" href="print.html#appendix-a" id="appendix-a"><h2>Appendix A</h2></a>
<pre><code class="language-js">// app/utils/tracking.js
const TRACKING_DATA = new WeakMap();
export default TRACKING_DATA;
</code></pre>
<pre><code class="language-js">// app/components/track-link.js
import Component from '@ember/component';
import TRACKING_DATA from '../utils/tracking';

export default Component.extend({
  tagName: 'a',
  attributeBindings: ['href'],
  didInsertElement() {
    TRACKING_DATA.set(this.element, this.contextName);
  }
})
</code></pre>
<pre><code class="language-js">// app/routes/application.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  router: service('router'),
  init() {
    this._super(...arguments);

    this.router.on('routeDidChange', transition =&gt; {
      let { source, event } = trasition.attribution;

      let trackingInfo = {
        cause: event.type,
        contextName: null
      };

      if (TRACKING_DATA.has(trasition.source)) {
        trackingInfo.contextName = TRACKING_DATA.get(source);
      }

      ga.send('pageView', {
        from: transition.from ? transition.from.name : 'initial',
        to: transition.to.name,
        attribution: trackingInfo
      });
    });
  }
})
</code></pre>
<pre><code class="language-hbs">&lt;h1&gt;Hello {{@name}}!&lt;/h1&gt;
&lt;TrackLink href=&quot;/profile&quot; @contextName=&quot;profile.link&quot;&gt;Profile&lt;/TrackLink&gt;
&lt;TrackLink href=&quot;/about&quot; @contextName=&quot;about.link&quot;&gt;About&lt;/TrackLink&gt;
&lt;TrackLink href=&quot;/contact&quot; @contextName=&quot;contact.link&quot;&gt;Contact&lt;/TrackLink&gt;
</code></pre>
<a class="header" href="print.html#appendix-b" id="appendix-b"><h2>Appendix B</h2></a>
<pre><code class="language-js">// app/utils/tracking.js
const TRACKING_DATA = new WeakMap();
export default TRACKING_DATA;
</code></pre>
<pre><code class="language-js">// app/routes/profile.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  store: service('store'),
  actions: {
    changeName(name) {
      this.model.set('name', name);
    },

    changeAge(age) {
      this.model.set('age', age);
    },

    submit(e) {
      if (isValid(this.model)) {
        let attribution = {
          event: e,
          source: e.target,
        };

        TRACKING_DATA.set(e.target, 'profile.submit');

        this.model.save().then(() =&gt; {
          this.transitionTo('profile.success', { attribution });
        }, () =&gt; {
          alert('Issue saving... please try again.');
        });
      } else {
        alert('Data is not valid!');
      }
    }
  }
})
</code></pre>
<pre><code class="language-hbs">&lt;input onchange={{action 'changeName' value=&quot;target.value&quot;}} /&gt;
&lt;input onchange={{action 'changeAge' value=&quot;target.value&quot;}} /&gt;
&lt;button onclick={{action 'submit' this.model}}&gt;Submit&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// app/routes/application.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  router: service('router'),
  init() {
    this._super(...arguments);

    this.router.on('routeDidChange', transition =&gt; {
      let { source, event } = trasition.attribution;

      let trackingInfo = {
        cause: event.type,
        contextName: null
      };

      if (TRACKING_DATA.has(trasition.source)) {
        trackingInfo.contextName = TRACKING_DATA.get(source);
      }

      ga.send('pageView', {
        from: transition.from ? transition.from.name : 'initial',
        to: transition.to.name,
        attribution: trackingInfo
      });
    });
  }
})
</code></pre>
<ul>
<li>Start Date: 2018-10-23</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/392</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#summary-92" id="summary-92"><h1>Summary</h1></a>
<p>This deprecates the string-based lookup API for associating a custom component manager with a corresponding base class.</p>
<pre><code class="language-js">import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend({
  //...
}))
</code></pre>
<p>Instead, you must pass a factory function that produces an instance of the custom manager:</p>
<pre><code class="language-js">import EmberObject from '@ember/object';
import { createManager } from './basic-manager';
import { setComponentManager } from '@ember/modifier';

export default setComponentManager(createManager, EmberObject.extend({
  // ...
}));
</code></pre>
<p>Where <code>createManager</code> is:</p>
<pre><code class="language-js">export function createManager(owner) {
  return new BasicManager(owner);
}
</code></pre>
<a class="header" href="print.html#motivation-93" id="motivation-93"><h1>Motivation</h1></a>
<p>There are several motivators:</p>
<ul>
<li>A string-based API is not friendly when it comes to tree shaking. It would force us into creating a compiler to turn the string into a symbol that build tools like Rollup and Webpack could analyze.</li>
<li>This API expands the namespacing problems associated with module unification. Specifically, an addon author would have to associate the package name with the string, similar to how <a href="https://github.com/mixonic/rfcs/blob/mu-packages/text/0000-module-unification-packages.md#explicit-packages-for-service-injections">RFC#367</a> proposes changes to services.</li>
<li><code>setModifierManager</code> as introduced by <a href="https://github.com/emberjs/rfcs/blob/89349d30ade24303a06448bc121b8fd810cbe58d/text/0373-Element-Modifier-Managers.md#determining-which-modifier-manager-to-use">RFC#373</a> uses a factory style API. This RFC intends to align these to function signatures.</li>
<li>We want to make sure this API is compatible with the binary AoT compilation work we did in the Glimmer-VM.</li>
</ul>
<a class="header" href="print.html#transition-path-14" id="transition-path-14"><h1>Transition Path</h1></a>
<p>We can transition away by producing a factory function in the internals of <code>setupComponentManager</code>. The implementation would look something like:</p>
<pre><code class="language-js">export function setComponentManager(stringOrFunction, obj: any) {
  let factory;
  if (typeof stringOrFunction === 'string') {
    deprecate(
      `Passing the name of the component manager to 'setupComponentManager' is deprecated. Please pass a function that produces an instance of the manager.`,
      {
        id: 'deprecate-string-based-component-manager',
        unil: '4.0.0'
      }
    );
    factory = function(owner: Owner) {
      return owner.lookup(`component-manager:${stringOrFunction}`);
    };
  } else {
    factory = stringOrFunction;
  }

  // ...
}

</code></pre>
<a class="header" href="print.html#how-we-teach-this-64" id="how-we-teach-this-64"><h1>How We Teach This</h1></a>
<p>From our understanding this API has very limited usage as it is a low-level API. We should update that docs accordingly.</p>
<a class="header" href="print.html#drawbacks-88" id="drawbacks-88"><h1>Drawbacks</h1></a>
<p>Historically, Ember has given developers base classes that the developer would extend from and Ember would create instances on your behalf. This allows the framework to know that the interface of the object is complete. With this approach we are relying more on the addon author to construct the object and ensure it conforms to the correct interface.</p>
<p>Generally speaking this a good practice of OOP but due to the fact that JavaScript does not have first-class interfaces, Ember has taken the concretion approach.</p>
<a class="header" href="print.html#alternatives-90" id="alternatives-90"><h1>Alternatives</h1></a>
<p>Instead of passing a factory function we could pass the class itself. This option does have the issue of Ember needing to know how to construct the class and does not allow for the addon author to perform any dependency injections.</p>
<a class="header" href="print.html#unresolved-questions-62" id="unresolved-questions-62"><h1>Unresolved questions</h1></a>
<p>TBD?</p>
<ul>
<li>Start Date: 2018-10-31</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/395</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#ember-data-packages" id="ember-data-packages"><h1>Ember Data Packages</h1></a>
<a class="header" href="print.html#summary-93" id="summary-93"><h2>Summary</h2></a>
<p>This documents presents the proposed <strong>public</strong> import path changes for <code>ember-data</code>, and moving <code>ember-data</code>
into the <code>@ember-data</code> namespace.</p>
<a class="header" href="print.html#motivation-94" id="motivation-94"><h2>Motivation</h2></a>
<p><strong>Reduce Confusion &amp; Bike Shedding</strong></p>
<p>Users of <code>ember-data</code> have often noted their confusion by the existence of both direct and &quot;god object&quot; (<code>DS.</code>) style
imports for modules from <code>ember-data</code>. The documentation currently uses primarily the <code>DS.</code> style, and users have
expressed interest and confusion over why the documentation has not been updated to reflect direct imports.</p>
<p><strong>Improve The TypeScript Experience</strong></p>
<p>Presence of multiple import locations confuses <code>Typescript</code>'s autocomplete, symbol resolution, and type hinting.</p>
<p><strong>Simplify The Mental Model</strong></p>
<p>Users of <code>ember-data</code> complain about the large API surface area; however, a large portion of this surface area is
non-essential user-land APIs that the provided adapter and serializer implementations expose. This move to packages
helps us simplify the mental model in three ways.</p>
<p>First: it gives us a natural way of dividing the documentation and learning story such that key concepts
and APIs are more discoverable.</p>
<p>Second: it allows us specifically to isolate the API surface area explosion of the provided adapter and serializer
implementations and make it clear that these are non-essential, replaceable APIs. E.G. it will help us to communicate
that these adapters and serializers are <em>an implementation</em>, <strong>not</strong> <em>the required implementation</em>.</p>
<p>Third: it clarifies the roles of several concepts within <code>ember-data</code> that are often misused today. Specifically:
the <code>embedded-records-mixin</code> should <em><em>only</em></em> be used with the <code>RESTAdapter</code>, and <code>transforms</code> are <em><em>only</em></em> a
serialization/deserialization concern and not a way of defining custom <code>attrs</code> or <code>types</code>. Furthermore, <code>transforms</code>
are only applicable to the serializer implementations that <code>ember-data</code> provides, and not to <code>custom</code> (and sometimes
not to <code>subclassed</code>) serializers.</p>
<p><strong>Improve the Contributor Experience</strong></p>
<p>Contributors to <code>ember-data</code> are faced with a large, complex project with poor code and test organization. This makes it
unduly difficult to discover what tests exist, where to add tests, where associated code lives, and even what parts of
the code base relate to the feature or bug that they are looking to address.</p>
<p>This move to packages will help us restructure the project and associated tests in a manner that is more discoverable.</p>
<p><strong>Provide a Clear Subdivision of Packages</strong></p>
<p>Today, <code>ember-data</code> is a large single package (<code>~35KB gzipped</code> in production). <code>ember-data</code> is often one of the largest
dependencies <code>emberjs</code> users have in their applications. However, not all users utilize all parts of <code>ember-data</code>, and
some users use very little. Providing these packages helps to clearly show the cost of various features, and better
allows us to enable end users to eliminate unneeded packages.</p>
<p>Users that implement their own adapter or serializers today must still carry the significant weight of the adapter and
serializer implementations that <code>ember-data</code> ships regardless. This is a weight we should enable these users to eliminate.</p>
<p>With the landing of <code>RecordData</code> and the merging of the <code>modelFactoryFor</code> RFC, it is likely that many applications
will soon require far less of <code>ember-data</code> than they do today. <code>ember-m3</code> is an example of a project that utilizes these
APIs in a way that requires significantly less of the <code>ember-data</code> experience.</p>
<p><strong>Provide Infrastructure for Additional Changes</strong></p>
<p><code>ember-data</code> is entering a period of extended evolution, of which <code>RecordData</code> and <code>modelFactoryFor</code> are only the early
pieces. For example, current thinking includes the possibility of <code>ember-data</code> evolving to provide an <code>ember-m3</code>-like
experience for <code>json-api</code> as the default out-of-the-box experience, and a rethinking of how we manage the request/response
lifecycle when fulfilling a request for data.</p>
<p>These experiences would live alongside the existing experience for a time prior to any deprecations of the current layer,
and it is possible that sometimes the current experience would never be deprecated. Subdividing <code>ember-data</code> into these
packages will enable us to provide a more seamless transition between these experiences without hoisting any package
size costs onto users that do not use either the current or the new experience.</p>
<a class="header" href="print.html#detailed-design-79" id="detailed-design-79"><h2>Detailed design</h2></a>
<p>This RFC proposes import paths following the guidelines established in <a href="https://github.com/emberjs/rfcs/pull/176">Ember Modules RFC #176</a>,
with two addendums to account for scenarios that weren't faced by <code>ember</code>:</p>
<ul>
<li><code>Error</code> sub-classes are named exports</li>
<li><code>Mixins</code> are named exports</li>
</ul>
<p>This is done to allow for continued grouping by common usage and mental model, where otherwise users would be faced with multiple imports from length file paths.</p>
<p>The following modules would continue to live in a monorepo that (until further RFC) would continue to live at <code>github.com/ember/data</code>.</p>
<table>
  <thead>
    <tr>
      <th colspan="2">Before</th>
      <th>After</th>
    </tr>
    <tr>
        <th>import DS from 'ember-data';</th>
        <th>Direct Import</th>
        <th>New Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="3"><a class="header" href="print.html#ember-datamodel" id="ember-datamodel"><h3>@ember-data/model</h3></a></td>
    </tr>
    <tr>
      <td>DS.Model</td>
      <td>import Model from 'ember-data/model';</td>
      <td>import Model from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.attr</td>
      <td>import attr from 'ember-data/attr';</td>
      <td>import { attr } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.belongsTo</td>
      <td>import { belongsTo } from 'ember-data/relationships';</td>
      <td>import { belongsTo } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.hasMany</td>
      <td>import { hasMany } from 'ember-data/relationships';</td>
      <td>import { hasMany } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td colspan="3"><a class="header" href="print.html#ember-dataadapter" id="ember-dataadapter"><h3>@ember-data/adapter</h3></a></td>
    </tr>
    <tr>
      <td>DS.Adapter</td>
      <td>import Adapter from 'ember-data/adapter';</td>
      <td>import Adapter from '@ember-data/adapter';</td>
    </tr>
    <tr>
      <td>DS.RESTAdapter</td>
      <td>import RESTAdapter from 'ember-data/adapters/rest';</td>
      <td>import RESTAdapter from '@ember-data/adapter/rest';</td>
    </tr>
    <tr>
      <td>DS.JSONAPIAdapter</td>
      <td>import JSONAPIAdapter from 'ember-data/adapters/json-api';</td>
      <td>import JSONAPIAdapter from '@ember-data/adapter/json-api';</td>
    </tr>
    <tr>
      <td>DS.BuildURLMixin</td>
      <td>none</td>
      <td>import { BuildURLMixin } from '@ember-data/adapter';</td>
    </tr>
    <tr>
      <td>DS.AdapterError</td>
      <td>import { AdapterError } from 'ember-data/adapters/errors';</td>
      <td>import AdapterError from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.InvalidError</td>
      <td>import { InvalidError } from 'ember-data/adapters/errors';</td>
      <td>import { InvalidError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.TimeoutError</td>
      <td>import { TimeoutError } from 'ember-data/adapters/errors';</td>
      <td>import { TimeoutError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.AbortError</td>
      <td>import { AbortError } from 'ember-data/adapters/errors';</td>
      <td>import { AbortError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.UnauthorizedError</td>
      <td>import { UnauthorizedError } from 'ember-data/adapters/errors';</td>
      <td>import { UnauthorizedError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ForbiddenError</td>
      <td>import { ForbiddenError } from 'ember-data/adapters/errors';</td>
      <td>import { ForbiddenError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.NotFoundError</td>
      <td>import { NotFoundError } from 'ember-data/adapters/errors';</td>
      <td>import { NotFoundError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ConflictError</td>
      <td>import { ConflictError } from 'ember-data/adapters/errors';</td>
      <td>import { ConflictError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ServerError</td>
      <td>import { ServerError } from 'ember-data/adapters/errors';</td>
      <td>import { ServerError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.errorsHashToArray</td>
      <td>none</td>
      <td>import { errorsHashToArray } from '@ember-data/adapter/error';<br>
         <br>this public method should also be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td>DS.errorsArrayToHash</td>
      <td>none</td>
      <td>import { errorsArrayToHash } from '@ember-data/adapter/error';<br>
        <br>this public method should also be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td colspan="3"><a class="header" href="print.html#ember-dataserializer" id="ember-dataserializer"><h3>@ember-data/serializer</h3></a></td>
    </tr>
    <tr>
      <td>DS.Serializer</td>
      <td>import Serializer from 'ember-data/serializer';</td>
      <td>import Serializer from '@ember-data/serializer';</td>
    </tr>
    <tr>
      <td>DS.JSONSerializer</td>
      <td>import JSONSerializer from 'ember-data/serializers/json';</td>
      <td>import JSONSerializer from '@ember-data/serializer/json';</td>
    </tr>
    <tr>
      <td>DS.RESTSerializer</td>
      <td>import RESTSerializer from 'ember-data/serializers/rest';</td>
      <td>import RESTSerializer from '@ember-data/serializer/rest';</td>
    </tr>
    <tr>
      <td>DS.JSONAPISerializer</td>
      <td>import JSONAPISerializer from 'ember-data/serializers/json-api';</td>
      <td>import JSONAPISerializer from '@ember-data/serializer/json-api';</td>
    </tr>
    <tr>
      <td>DS.EmbeddedRecordsMixin</td>
      <td>import EmbeddedRecordsMixin from 'ember-data/serializers/embedded-records-mixin';</td>
      <td>import { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';</td>
    </tr>
    <tr>
      <td>DS.Transform</td>
      <td>import Transform from 'ember-data/transform';</td>
      <td>import Transform from '@ember-data/serializer/transform';</td>
    </tr>
    <tr>
      <td colspan="3"><a class="header" href="print.html#ember-datastore" id="ember-datastore"><h3>@ember-data/store</h3></a></td>
    </tr>
    <tr>
      <td>DS.Store</td>
      <td>import Store from 'ember-data/store';</td>
      <td>import Store from '@ember-data/store';</td>
    </tr>
    <tr>
      <td>DS.Snapshot</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.PromiseArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.PromiseObject</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.RecordArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.AdapterPopulatedRecordArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.RecordarrayManager</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.normalizeModelName</td>
      <td>none</td>
      <td>import { normalizeModelName } from '@ember-data/store';<br>
        <br>this public method should be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td colspan="3"><a class="header" href="print.html#ember-datarecord-data" id="ember-datarecord-data"><h3>@ember-data/record-data</h3></a></td>
    </tr>
    <tr>
      <td>none</td>
      <td>import { RecordData } from 'ember-data/-private';</td>
      <td>import RecordData from '@ember-data/record-data';</td>
    </tr>
    <tr>
      <td colspan="3"><a class="header" href="print.html#ember-datarelationship-layer" id="ember-datarelationship-layer"><h3>@ember-data/relationship-layer</h3></a></td>
    </tr>
    <tr>
      <td>DS.Relationship</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td colspan="3"><a class="header" href="print.html#ember-datadebug" id="ember-datadebug"><h3>@ember-data/debug</h3></a></td>
    </tr>
    <tr>
      <td>DS.DebugAdapter</td>
      <td>none</td>
      <td>none</td>
    </tr>
  </tbody>
</table>
<a class="header" href="print.html#notes-1" id="notes-1"><h3>Notes</h3></a>
<a class="header" href="print.html#ember-datamodel-1" id="ember-datamodel-1"><h4><code>@ember-data/model</code></h4></a>
<ol>
<li>
<p><code>InternalModel</code> and <code>RootState</code> are tightly coupled to the store and to our provided <code>Model</code>
implementation. Over time we need to uncouple this, but given their coupling to <code>Model</code> and our
desire to enable them to be eliminated from projects not using <code>Model</code>, these concepts belong in <code>@ember-data/model</code>, although they will not be given direct import paths.</p>
</li>
<li>
<p>The following belong in <code>@ember-data/model</code> and not in <code>@ember-data/relationship-layer</code> with
relationships.  While this presents a mild risk of confusion due to the presence of the
<code>relationship-layer</code> package, the argument for their presence here is they are a ui-layer concern being coupled to the current <code>Model</code> presentation layer and not related to overall state management
of relationships which could itself be used with alternative implementations.</p>
</li>
</ol>
<ul>
<li>
<p><code>belongsTo</code></p>
</li>
<li>
<p><code>hasMany</code></p>
</li>
</ul>
<ol start="3">
<li>
<p>The following have the same considerations as #2 but they will not be given direct import paths.</p>
</li>
</ol>
<ul>
<li><code>PromiseManyArray</code></li>
<li><code>ManyArray</code></li>
</ul>
<a class="header" href="print.html#ember-dataserializers" id="ember-dataserializers"><h4><code>@ember-data/serializers</code></h4></a>
<ol>
<li>We should move automatic registration of transforms into a more traditional
<code>app/</code> directory re-export for the package so that when the package is dropped they
cleanly drop as well.</li>
</ol>
<a class="header" href="print.html#ember-datarelationship-layer-1" id="ember-datarelationship-layer-1"><h4><code>@ember-data/relationship-layer</code></h4></a>
<p>This package seems thin but it's likely to hold quite a bit.
Additional private things that would be moved here:</p>
<ul>
<li>everything in <code>-private/system/relationships/state</code></li>
<li><code>BelongsToReference</code> and <code>HasManyReference</code></li>
<li>relationship logic from <code>store</code> / <code>internal-model</code> that need to be isolated and extracted</li>
</ul>
<a class="header" href="print.html#ember-datadebug-1" id="ember-datadebug-1"><h4><code>@ember-data/debug</code></h4></a>
<p>Moving <code>DebugAdapter</code> here would allow dropping it if not desired. Additionally we should likely
RFC dropping it for production builds where it adds persistent unnecessary overhead for a tool
meant for devs. This exists to support the ember inspector.</p>
<a class="header" href="print.html#documented-public-apis-without-public-import-paths" id="documented-public-apis-without-public-import-paths"><h3>Documented Public APIs without public import paths</h3></a>
<p>There are a few public classes that are not exposed at all via <code>export</code> today. Those classes will not be given
public export paths, but the package containing their documentation and implementation is shown here:</p>
<ul>
<li><code>@ember-data/store</code>
<ul>
<li><code>Reference</code></li>
<li><code>RecordReference</code></li>
<li><code>StoreWrapper</code></li>
</ul>
</li>
<li><code>@ember-data/relationship-layer</code>
<ul>
<li><code>BelongsToReference</code></li>
<li><code>HasManyReference</code></li>
</ul>
</li>
<li><code>@ember-data/model</code>
<ul>
<li><code>PromiseBelongsTo</code></li>
<li><code>PromiseRecord</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#migration-3" id="migration-3"><h2>Migration</h2></a>
<p>Blueprints, guides, docs, and twiddle would be updated to use the new <code>@ember-data/</code> package imports.</p>
<p>A codemod would be provided to convert from the existing import locations to the new ones, as well as lint rules for encouraging their use.</p>
<p>The package <code>ember-data</code> would continue to exist, much like <code>ember-source</code>. Initially, this package would provide all of the subpackages
as dependencies as well as the respective re-exports for supporting the existing import paths. After a time, the existing paths would
be deprecated.</p>
<p>Users who have resolved the deprecations may choose to convert to consuming only the packages they still require directly,
by dropping <code>ember-data</code> from their <code>package.json</code> and adding in the individual <code>@ember-data/</code> packages as necessary.</p>
<p>Ultimately, the default <code>ember-data</code> story in <code>ember-cli</code> would change to install select packages from <code>@ember-data</code> directly.</p>
<a class="header" href="print.html#how-we-teach-this-65" id="how-we-teach-this-65"><h2>How we teach this</h2></a>
<p>This RFC should be seen as a continuation of the <code>javascript-modules</code> RFC that defined explicit import paths for <code>emberjs</code>.</p>
<p>Codemods and lint rules would be provided to convert existing imports to the new syntax. Existing import locations
would continue to exist for a time but would at some point in the future be made to print build-time deprecations.</p>
<p>End users would need to run the codemod at some point, but no other changes will be required.</p>
<p>Ember documentation and guides would be updated to reflect these new import paths as well as to utilize the new package
divisions to improve the teaching story.</p>
<a class="header" href="print.html#drawbacks-89" id="drawbacks-89"><h2>Drawbacks</h2></a>
<ul>
<li>A Tiny amount of churn</li>
<li>Sub-packages will require sprinkling significant numbers of excess package.json files throughout our repo.</li>
<li>Our import paths may not align with the expected mental model for addon import paths going forward (no <code>/src/</code> in path)</li>
</ul>
<a class="header" href="print.html#alternatives-91" id="alternatives-91"><h2>Alternatives</h2></a>
<ol>
<li>
<p>Divide into packages without exposing the new division publicly</p>
</li>
</ol>
<ul>
<li>
<p><em>argument for:</em> Don't expose churn to end users without a clear win, we aren't 100% sure what belongs in a vague
&quot;future ember-data&quot;, so wait until we are sure.</p>
</li>
<li>
<p><em>rebuttal:</em> The churn is minimal and mostly automated (codemod). There are clear wins here for many users. We
should not hold up progress now on an uncertain future. Dividing into packages now gives us more options for how to
manage future evolution. Regardless of when we become certain of what belongs in &quot;future ember-data&quot;, these packages
would need to exist alongside at least for a time.</p>
</li>
</ul>
<ol start="2">
<li>
<p>Don't divide into packages until nebulous future RFCs have landed</p>
</li>
</ol>
<ul>
<li>
<p><em>argument for:</em> This argument is an extension of <em>alternative 1</em> in which we wait for specific concepts to mature and
materialize that we have discussed internally, including a significant rework of how we manage the <code>request/response</code>
lifecycle. These new feature RFCs would come with corresponding deprecation RFCs for parts of the system they either
fully replace or make vestigial.</p>
</li>
<li>
<p><em>rebuttal:</em> The argument here is a variation of the argument in <em>alternative 1</em> and the rebuttal merely extends
that rebuttal as well. These future deprecations would necessarily be long-tail, if we deprecate at all. There is
the option to have both old and new experiences live side-by-side. Additionally, if we deprecate and then land
<code>@ember-data/packages</code> there is both an equal amount of churn and fewer options for how to manage those deprecations.</p>
</li>
</ul>
<ol start="3">
<li>
<p>Use the <code>@ember</code> namespace.</p>
</li>
</ol>
<ul>
<li>
<p><em>argument for:</em> <code>ember-data</code> is an official package and we wish to position it centrally within the <code>ember</code>
ecosystem. This <a href="https://github.com/emberjs/rfcs/pull/238#issuecomment-318745236">argument has been presented</a>
by other core teams in response to previous attempts to move forward with a packages RFC for <code>ember-data</code>.</p>
</li>
<li>
<p><em>rebuttal:</em> <code>ember-cli</code> and <code>glimmer</code> are also official packages, but with their own namespaces. Additionally
re-using the <code>@ember</code> namespace would only further confusion that many folks already have regarding:</p>
<ul>
<li>where <code>ember</code> ends and <code>ember-data</code> begins.</li>
<li>whether <code>ember-data</code> is required or optional</li>
<li>whether other data layers are seen as &quot;bad practices&quot; (they are not)</li>
<li>what packages are provided by <code>ember-data</code> vs <code>ember</code>
<code>ember-data</code>'s status as a team, in the guides and in release blog posts on <code>emberjs.com</code>, as well as presence in
the default blueprint provided by <code>ember-cli</code> make clear it's status as an official offering. Using the <code>@ember</code>
namespace is not required for this.</li>
</ul>
<p>This argument also necessarily foments an untrue presupposition: that <code>ember-data</code> is the right choice for every app.
While we strive to make this the case, it would be very difficult to claim this today, and may never be true,
as every app presents unique concerns and needs.</p>
<p>Finally, using the <code>@ember</code> namespace would leave us in the unfortunate position of either always scoping all of our
packages to <code>@ember/data/</code> or of fighting with <code>emberjs</code> for package names.</p>
</li>
</ul>
<ol start="4">
<li>
<p>This RFC but with Adapters and Serializers broken out into the packages <code>@ember-data/json</code> <code>@ember-data/rest</code> <code>@ember-data/json-api</code>.</p>
</li>
</ol>
<ul>
<li>
<p><em>argument for:</em> grouping the adapter / serializer &quot;by API spec&quot; feels more natural and would allow for users to drop only the versions of adapters / serializer they don't require.</p>
</li>
<li>
<p><em>rebuttal:</em> Even without considering future changes to <code>ember-data</code>'s API surface, there are several issues with this approach.</p>
<ol>
<li>
<p>The implementations inherit each other:</p>
<ul>
<li><code>JSONAPISerializer extends RESTSerializer extends JSONSerializer extends Serializer</code></li>
<li><code>JSONAPIAdapter extends RESTAdapter extends Adapter</code></li>
</ul>
</li>
<li>
<p>The adapter / serializer pairings aren't coupled</p>
<ul>
<li>It is fairly common to use the <code>JSONAPIAdapter</code> with the <code>RESTSerializer</code> or
with a custom serializer that extends the <code>RESTSerializer</code> and vice-verse.</li>
<li>Even when using a consistent spec (<code>json-api</code> or <code>rest</code>) it is common to need
a fully custom serializer. The division of needs is at least equally between
adapter/serializer as it is between specs.</li>
</ul>
</li>
<li>
<p>Transforms are an implementation detail for all the provided serializers</p>
<ul>
<li>But they  are not required and likely not even used by custom serializers.</li>
</ul>
</li>
<li>
<p>Packages for automatically registered fallbacks would fit poorly.</p>
<ul>
<li>Serializers: <code>&quot;-default&quot;</code> <code>&quot;-rest&quot;</code> <code>&quot;-json-api&quot;</code></li>
<li>Adapters: <code>&quot;-rest&quot;</code> <code>&quot;-json-api&quot;</code></li>
</ul>
</li>
<li>
<p>Today, we use multiple serializers for a single type based on entry-point</p>
<ul>
<li><code>Model.serialize</code> (per-type) / <code>Model.toJSON</code> (<code>&quot;-json&quot;</code>) / <code>Adapter.serialize</code> (per-adapter)</li>
</ul>
</li>
</ol>
<p>That said, this organization is also one of the only-nods
to future RFCs this RFC concedes. The existing provided implementations all follow roughly the same interface for their implementations, and that interface is something we strongly wish to change. For this reason, it seems advantageous to keep the existing implementations together such that the delineation between a new experience and this experience can be kept clear.</p>
</li>
</ul>
<ul>
<li>Start Date: 2018-11-02</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/398</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#routeinfo-metadata" id="routeinfo-metadata"><h1>RouteInfo MetaData</h1></a>
<a class="header" href="print.html#summary-94" id="summary-94"><h2>Summary</h2></a>
<p>The RFC introduces the ability to associate application specific metadata with its corresponding <code>RouteInfo</code> object. This also adds a <code>metadata</code> field to <code>RouteInfo</code>, which will be the return value of <code>buildRouteInfoMetadata</code> for its corresponding <code>Route</code>.</p>
<pre><code class="language-js">// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';

export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      trackingKey: 'page_profile',
      user: {
        id: this.user.id,
        type: this.user.type
      }
    }
  }
  // ...
});
</code></pre>
<pre><code class="language-js">// app/services/analytics.js
import Service, { inject } from '@ember/service';

export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) =&gt; {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromMeta,
        to: toMeta,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
</code></pre>
<a class="header" href="print.html#motivation-95" id="motivation-95"><h2>Motivation</h2></a>
<p>While the <code>RouteInfo</code> object is sufficient in providing developers metadata about the <code>Route</code> itself, it is not sufficient in layering on application specific metadata about the <code>Route</code>. This metadata could be anything from a more domain-specific name for a <code>Route</code>, e.g. <code>profile_page</code> vs <code>profile.index</code>, all the way to providing contextual data when the <code>Route</code> was visited.</p>
<p>This metadata could be used for more pratical things like updating the <code>document.title</code>.
Currently, addons like <a href="https://github.com/ronco/ember-cli-head">Ember CLI Head</a> and <a href="https://github.com/kimroen/ember-cli-document-title">Ember CLI Document Title</a> require the user to supply special metadata fields on your <code>Route</code> that will be used to update the title. This API would be a formalized place to place that metadata.</p>
<p>See the <a href="print.html#appendix-a">appendix</a> for examples.</p>
<a class="header" href="print.html#detailed-design-80" id="detailed-design-80"><h2>Detailed design</h2></a>
<a class="header" href="print.html#buildrouteinfometadata" id="buildrouteinfometadata"><h3><code>buildRouteInfoMetadata</code></h3></a>
<p>This optional hook is intended to be used as a way of letting the routing system know about any metadata associated with the route.</p>
<a class="header" href="print.html#route-interface-extension" id="route-interface-extension"><h4><code>Route</code> Interface Extension</h4></a>
<pre><code class="language-ts">interface Route {
  // ... existing public API
  buildRouteInfoMetadata(): unknown
}
</code></pre>
<a class="header" href="print.html#runtime-semantics" id="runtime-semantics"><h4>Runtime Semantics</h4></a>
<ul>
<li><strong>Always</strong> called before the <code>beforeModel</code> hook is called</li>
<li><strong>Maybe</strong> called more than once during a transition e.g. aborts, redirects.</li>
</ul>
<a class="header" href="print.html#routeinfometadata" id="routeinfometadata"><h3><code>RouteInfo.metadata</code></h3></a>
<p>The <code>metadata</code> optional field on <code>RouteInfo</code> will be populated with the return value of <code>buildRouteInfoMetadata</code>. If there is no metadata associated with the <code>Route</code>, the <code>metadata</code> field will be <code>null</code>.</p>
<pre><code class="language-ts">interface RouteInfo {
  // ... existing public API
  metadata: Maybe&lt;unknown&gt;;
}
</code></pre>
<p>This field will also be added to <code>RouteInfoWithAttributes</code> as it is just a super-set of <code>RouteInfo</code>.</p>
<a class="header" href="print.html#how-we-teach-this-66" id="how-we-teach-this-66"><h2>How we teach this</h2></a>
<p>We feel that this a low-level primitive that will allow existing tracking addons to encapsulate. That being said the concept here is pretty simple: What gets returned from <code>buildRouteInfoMetadata</code> becomes the value of <code>RouteInfo.metadata</code> for that <code>Route</code>.</p>
<p>The guides and tutorial should be updated to incorporate an example on how these APIs could integrate with services like Google Analytics.</p>
<a class="header" href="print.html#drawbacks-90" id="drawbacks-90"><h2>Drawbacks</h2></a>
<p>This adds an additional hook that is called during route activation, expanding the surface area of the <code>Route</code> class.
While this is true, there is currently no good way to associate application-specific metadata with a route transition.</p>
<a class="header" href="print.html#alternatives-92" id="alternatives-92"><h2>Alternatives</h2></a>
<p>There are numerous alternative to the proposal:</p>
<a class="header" href="print.html#setroutemetadata" id="setroutemetadata"><h3><code>setRouteMetadata</code></h3></a>
<p>This API would be similar to <code>setComponentManager</code> and <code>setModifierManager</code>. For example:</p>
<pre><code class="language-js">// app/route/profile.js
import Route, { setRouteMetadata } from '@ember/routing/route';

export default Route.extend({

  init() {
    this._super(...arguments);
    setRouteMetadata(this, {
      trackingKey: 'page_profile',
      profile: {
        viewing: this.userId,
        locale: this.userLocale
      }
    });
  }
  // ...
});
</code></pre>
<p>You would then use the a <code>RouteInfo</code> to lookup the value:</p>
<pre><code class="language-js">// app/services/analytics.js
import { getRouteMetadata } from '@ember/routing/route';
import Service, { inject } from '@ember/service';
 export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) =&gt; {
      let { to, from } = transition;
      let { trackingKey: fromKey } = getRouteMetadata(from);
      let { trackingKey: toKey } = getRouteMetadata(to);
      ga.sendEvent('pageView', {
        from: fromKey,
        to: toKey,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
</code></pre>
<p>This could work but there are two things that are confusing here:</p>
<ol>
<li>What happens if you call <code>setRouteMetadata</code> mutliple times. Do you clobber the existing metadata? Do you merge it?</li>
<li>It is very odd that you would use a <code>RouteInfo</code> to access the metadata when you set it on the <code>Route</code>.</li>
</ol>
<a class="header" href="print.html#routemetadata" id="routemetadata"><h3><code>Route.metadata</code></h3></a>
<p>This would add a special field to the <code>Route</code> class that would be copied off on to the <code>RouteInfo</code>. For example:</p>
<pre><code class="language-js">// app/route/profile.js
import Route, { setRouteMetadata } from '@ember/routing/route';

export default Route.extend({
  metadata: {
    trackingKey: 'page_profile',
    profile: {
      viewing: this.userId,
      locale: this.userLocale
    }
  }
  // ...
});
</code></pre>
<p>The value would then be populated on <code>RouteInfo.metadata</code>.</p>
<pre><code class="language-js">// app/services/analytics.js
import { getRouteMetadata } from '@ember/routing/route';
import Service, { inject } from '@ember/service';
 export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) =&gt; {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromKey,
        to: toKey,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
</code></pre>
<p>This could work but there are two things that are problematic here:</p>
<ol>
<li>What happens to the this data if you subclass it? Do you merge or clobber the field?</li>
<li>This is a generic property name and may conflict in existing applications</li>
</ol>
<a class="header" href="print.html#return-metadata-from-activate" id="return-metadata-from-activate"><h3>Return Metadata From <code>activate</code></h3></a>
<p>Today <code>activate</code> does not get called when the dynamic segments of the <code>Route</code> change, making it not well fit for this use case.</p>
<a class="header" href="print.html#unresolved-questions-63" id="unresolved-questions-63"><h2>Unresolved questions</h2></a>
<p>TBD?</p>
<a class="header" href="print.html#apendix-a" id="apendix-a"><h3>Apendix A</h3></a>
<p>Tracking example</p>
<pre><code class="language-js">// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';
export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      trackingKey: 'page_profile',
      user: {
        id: this.user.id,
        type: this.user.type
      }
    }
  }
  // ...
});
</code></pre>
<pre><code class="language-js">// app/services/analytics.js
import Service, { inject } from '@ember/service';

export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) =&gt; {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromMeta,
        to: toMeta,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
</code></pre>
<a class="header" href="print.html#appendix-b-1" id="appendix-b-1"><h3>Appendix B</h3></a>
<p>Updating document.title</p>
<pre><code class="language-js">// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';
export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      title: 'My Cool WebPage'
    }
  }
  // ...
});
</code></pre>
<pre><code class="language-js">// app/router.js
import Router from '@ember/routing/router';

// ...
export default Router.extend({
  init() {
    this._super(...arguments);
    this.on('routeDidUpdate', (transition) =&gt; {
      let { title } = transition.metadata;
      document.title = title;
    });
  },
  // ...
});
</code></pre>
<ul>
<li>Start Date: 2018-10-20</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/408</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#decorators" id="decorators"><h1>Decorators</h1></a>
<a class="header" href="print.html#summary-95" id="summary-95"><h2>Summary</h2></a>
<p>Native classes are now officially supported in Ember, but currently their usage
is very limited. Core Ember features such as computed properties, actions, and
service injections have no publicly supported APIs to be used with native class
syntax.</p>
<p>Decorators provide a way to abstract functionality and improve the developer
experience of working with native classes.  This RFC outlines the implementation
and rollout plan for bringing decorators to Ember's computed properties (and
other behavior) for use in native classes.</p>
<a class="header" href="print.html#a-note-on-decorator-stability" id="a-note-on-decorator-stability"><h3>A Note on Decorator Stability</h3></a>
<p><a href="https://github.com/tc39/proposal-decorators">Decorators</a> are important to
adopting native class syntax. They are a formalization of the patterns we have
been using as a community for years, and it will not be possible to use native
classes ergonomically without them unless a number of major concepts (computed
properties, injections, actions) are rethought. That said, as of today (01/03/19)
decorators are still a <a href="https://tc39.github.io/process-document"><em>stage 2</em> proposal</a>
in TC39, which means that while they are fully defined as a spec, they are not
yet considered a candidate for inclusion in the language, and may have
incremental changes that could be breaking if/when moved to stage 3. As such,
merging support for them now would pose some risk. Additionally, <a href="https://github.com/tc39/proposal-class-fields">class
fields</a> are also required for
effective use of decorators, and while they are stage 3 in the process, they
have not yet been fully accepted either.</p>
<p>Ember cannot guarantee that the spec won't change, and such changes cannot apply
to Ember's normal semver guarantees. But it can make the following guarantees:</p>
<ol>
<li>
<p>If there are changes to the spec, and it <strong><em>is</em></strong> possible to avoid changing
the public APIs of decorators, then Ember will make the changes necessary to
avoid public API changes.</p>
</li>
<li>
<p>If there are changes to the spec, and it <strong><em>is not</em></strong> possible to avoid
breaking changes, Ember will minimize the changes as much as possible, and
will provide a codemod to convert from the previous version of the spec to
the next.</p>
</li>
<li>
<p>If the spec is dropped from TC39 altogether, Ember would have to continue to
provide support for decorators via babel transforms until they are deprecated
following the standard RFC process, and removed according to SemVer. Reverse
codemods which translate decorators and native class syntax back to classic
class syntax <em>will</em> be made, and alternatives for native class syntax will be
explored.</p>
</li>
<li>
<p>Classic class syntax will continue to be supported <em>at least</em> until these
features have been stabilized in the JavaScript language, to allow us to
revert these changes if necessary. They will most likely be supported for
longer to allow a smooth transition for users who do not want to adopt native
classes until they are completely stable.</p>
</li>
</ol>
<p>This RFC is being made with the assumption that decorators will be moved to
stage 3 in the near future, <em>before</em> this RFC is implemented in Ember,
dramatically reducing the risk of adopting decorators. If this RFC is accepted
and decorators are not advanced in a timely manner, a followup RFC should be
made to determine whether or not decorators should be adopted in stage 2, and
what the support for them would look like.</p>
<a class="header" href="print.html#terminology-2" id="terminology-2"><h2>Terminology</h2></a>
<p>For the purposes of this RFC, we'll use the following terminology:</p>
<ul>
<li>The <strong>Octane programming model</strong> refers to the new programming model
established by the Ember Octane edition. It includes <em>native classes</em>,
<em>tracked properties</em> and <em>Glimmer components</em>, and more generally refers to
features that will be considered <em>core to Ember</em> in the future.</li>
<li>The <strong>classic programming model</strong> refers to the traditional programming model.
It includes <em>classic classes</em>, <em>computed properties</em>, <em>event listeners</em>,
<em>observers</em>, <em>property notifications</em>, and <em>classic components</em>, and more
generally refers to features that will not be central to Ember Octane.</li>
<li><strong>Native classes</strong> are classes defined using the JavaScript <code>class</code> keyword</li>
<li><strong>Classic classes</strong> are classes defined by subclassing from <code>EmberObject</code>
using the static <code>extend</code> method.</li>
</ul>
<a class="header" href="print.html#motivation-96" id="motivation-96"><h2>Motivation</h2></a>
<p>Native JavaScript class syntax has been evolving for the past three years, filling in
the cracks and providing better, more standardized ways to write classes for the
web. They will be a key part of the Octane programming model, and the ES Classes
RFC was the first step toward enabling Ember users to use native class syntax,
but there are still key features of Ember that are not usable with <code>class</code>
syntax today, including <em>computed properties</em>, <em>actions</em>, and <em>injections</em>.</p>
<p>These features cannot be used ergonomically with native classes as it stands.
The only options are to either use Ember's <code>defineProperty</code> function directly,
or to define these values in an anonymous class. Both of these options are hard
to read, and will be difficult to codemod in the future:</p>
<pre><code class="language-js">// Using define property
import { computed, defineProperty } from '@ember/object';

class Person {
  constructor() {
    this.firstName = 'Melanie';
    this.lastName = 'Sumner';
  }
}

// define a computed property
defineProperty(
  Person.prototype,
  'fullName',
  computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
);

// Using intermediate extends
import EmberObject, { computed } from '@ember/object';

class Person extends EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
}) {
  constructor() {
    super(...arguments);
    this.firstName = 'Melanie';
    this.lastName = 'Sumner';
  }
}
</code></pre>
<p>Another method which was used for some time was to assign these values using
class field initializers. This practice is problematic however as it creates a
new instance of the computed property per <em>instance</em> of the class, and does not
work with native getters either:</p>
<pre><code class="language-ts">import EmberObject, { computed } from '@ember/object';

export default class Person extends EmberObject {
  firstName = 'Melanie';
  lastName = 'Sumner';

  fullName = computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  });
}

new Profile().fullName; // returns the CP instance, not 'Melanie Sumner'
</code></pre>
<p>The missing piece of functionality that we need here are <em>decorators</em>, and in
fact that is not a coincidence. The roots of the current TC39 decorator proposal
can be traced back to Ember (Yehuda having worked on the first few drafts of it)
specifically because computed properties, observers, and so on <em>are</em> decorators.
We've been using them for years in Ember, just with a non-standard,
slightly-less-clean syntax.</p>
<pre><code class="language-ts">import Component from '@ember/component';
import { computed } from '@ember/object';

export default class Profile extends Component {
  firstName = 'Melanie';
  lastName = 'Sumner';

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>Native decorators bring a more natural way of declaring computed properties to
native classes than the current computed macros.</p>
<a class="header" href="print.html#prior-art-1" id="prior-art-1"><h2>Prior Art</h2></a>
<p>The <a href="http://ember-decorators.github.io/ember-decorators/">Ember Decorators</a>
project has been experimenting with using decorators within Ember for some time
now, with the goal of reaching feature parity with the classic object model, and
the learnings from that project will be used to inform the API design in this
RFC.</p>
<a class="header" href="print.html#detailed-design-81" id="detailed-design-81"><h2>Detailed design</h2></a>
<p>This RFC proposes that:</p>
<ol>
<li><code>Ember.computed</code>, the <code>inject</code> macros, and the computed property macros be
updated to return a standard JavaScript decorator. Internally, the classic
object model will be made aware of these decorators, and know how to apply
them. This will allow the same exact imports to continue working as both
native decorators and classic decorators. This decorator <em>will</em> be compatible
with classes that extend from <code>EmberObject</code> and classes which do not.</li>
<li>A new <code>@action</code> decorator be added to allow the definition of actions on
classes. This decorator will <em>only</em> be compatible with classes that are
action handlers.</li>
</ol>
<p>This does leave out some features from the classic programming model which are
currently provided by Ember Decorators. This is both to minimize decorators' API
surface area, and because they will not be a major part of Ember Octane's
programming model. Addressing them individually:</p>
<ul>
<li><strong>Observers and event listeners</strong>, which have long been considered an
antipattern.</li>
<li><strong>Classic component</strong> functionality such as <code>classNames</code>, <code>classNameBindings</code>,
<code>attributeBindings</code>, etc. will be unnecessary with Glimmer components.</li>
<li><strong>Ember Data</strong> provides computed properties which had to be manually wrapped
in decorators. With the changes proposed in this RFC, however, they should
continue to work without any additional changes. In fact, all computed
property macros will.</li>
</ul>
<p>Users who want these features will still be able to rely on addons such as Ember
Decorators, which will provide decorator support for them for the forseeable
future. Moving forward, this RFC breaks down into <em>computed properties</em> and
<em>actions</em>.</p>
<a class="header" href="print.html#computed-properties" id="computed-properties"><h3>Computed Properties</h3></a>
<p>As mentioned before, computed properties essentially <em>are</em> decorators. However,
they are not spec compliant. Currently, <code>computed()</code> returns an instance of the
<code>ComputedProperty</code> class, which contains all of the meta information about the
decorated property. Native decorators, by contrast, are functions which receive
a descriptor and modify it as necessary.</p>
<p>Unfortunately, there's no way for us to know <em>ahead of time</em> when a computed
property is going to be used as a native decorator in a native class, and when
it is going to be used in a classic class. Consider the following:</p>
<pre><code class="language-js">class Person {
  @alias('prefix') title;
}
</code></pre>
<p>Really, what's going on there is <em>not</em> that we are invoking the <code>@alias</code>
decorator with parameters. We are invoking a function which <em>returns</em> a
decorator, so it desugars to:</p>
<pre><code class="language-js">const aliasForPrefix = alias('prefix');

class Person {
  @aliasForPrefix title;
}
</code></pre>
<p>Therefore, the <code>alias</code> function <em>must</em> itself return a decorator function.
However, this conflicts with usage in the classic programming model:</p>
<pre><code class="language-js">const Person = EmberObject.extend({
  title: alias('prefix')
})
</code></pre>
<p>We just established that <code>alias</code> must return a decorator function, but here it
is with the exact same arguments, and it needs to return a <code>ComputedProperty</code>
instance. There is nothing we can branch on here - in both cases, <code>alias</code> only
receives the string <code>'prefix'</code>, so it has no context for how it will be used.</p>
<p>The native class piece of this puzzle is completely inflexible. A decorator must
be a function, there is no choice about it. However, the <em>Ember</em> piece is <em>very</em>
flexible. The classic object model just needs a way to get the meta information
for the property when the class is being finalized. We can either assign the
meta information to the decorator function directly, or we can associate it via
a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap"><code>WeakMap</code></a>.</p>
<p>The benefit of doing this is that the entire Ember ecosystem will get decorator
support with no extra work required. Because standard <code>computed</code> definitions
will work as decorators, existing macros will also work as decorators with no
changes to existing code.</p>
<p>All of Ember's built in computed macros in the <code>@ember/object/computed</code> module
will also become decorators with no extra work. However, the injection macros
will require slight updates as they use a subclass of the <code>ComputedProperty</code>
class. These updates should be relatively minor, and will follow the same
strategy as <code>computed()</code>.</p>
<a class="header" href="print.html#usage-and-api" id="usage-and-api"><h4>Usage and API</h4></a>
<p>The API for <code>computed</code> will remain mostly the same. The key differences will be:</p>
<ol>
<li>The result of <code>computed</code> will be a decorator which can be applied directly to
native <em>getters</em>, <em>setters</em>, and <em>class fields</em>.</li>
<li>The <code>ComputedPropertyConfig</code> (the getter/setter functions) argument provided
to <code>computed</code> will now be optional when used as a decorator on a native
getter or setter, and the native getter/setter will be used instead.</li>
</ol>
<pre><code class="language-ts">function computed(...args: (string | ComputedPropertyConfig)[]): PropertyDecorator;
</code></pre>
<p>The function signatures of all existing macros, including <code>inject</code> macros, would
change in the same way.</p>
<p>In general usage, these three definitions are equivalent:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
});

class Person {
  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

class Person {
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
  fullName;
}
</code></pre>
<p>That last example may seem confusing at first, but this is actually the same as
defining a computed property macro:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

function join(...dependentKeys) {
  return computed(...dependentKeys, {
    get() {
      return dependentKeys.map(key =&gt; this[key]).join(' ');
    }
  });
}

class Person {
  @join('firstName', 'lastName')
  fullName;
}
</code></pre>
<p>Notably, using <code>@computed</code> as a decorator <em>directly</em>, without parenthesis, will
not be supported. This is to prevent a parameter check on a critical path:</p>
<pre><code class="language-js">class Person {
  @computed
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>The most common use case for this form in classic classes was to provide a new
instance of an object or array per instance of the class. This use case is
solved in native classes by class fields:</p>
<pre><code class="language-js">const Person = EmberObject.extend({
  cache: computed(function() {
    return {};
  })
})

class Person {
  cache = {};
}
</code></pre>
<p>For other use cases, such as lazy evaluation and caching, it will still be
possible to call <code>@computed</code> with no arguments:</p>
<pre><code class="language-js">class Person {
  @computed()
  get cache() {
    return {};
  };
}
</code></pre>
<a class="header" href="print.html#preventing-incoherent-usage" id="preventing-incoherent-usage"><h4>Preventing Incoherent Usage</h4></a>
<p>Making the <code>ComputedPropertyConfig</code> optional opens up lots of room for
accidents. A computed property without a getter or setter does not make sense,
nor does a computed propery with <em>two</em> getters or setters. The new decorator
will assert at <em>decorator application</em> time to ensure it is being used
correctly:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

// This will throw because the user attempted to define a CP without a getter
const Person = EmberObject.extend({
  fullName: computed()
});

// This will also throw because it is missing a getter
class Person {
  @computed('firstName', 'lastName')
  fullName;
}

// This will throw because a getter was already defined
class Person {
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>Effectively, if <code>computed</code> is passed a <code>ComputedPropertyConfig</code>, it returns a
class field decorator. Otherwise, it returns an accessor (getter/setter)
decorator.</p>
<a class="header" href="print.html#property-modifiers" id="property-modifiers"><h4>Property Modifiers</h4></a>
<p>Almost all computed property modifiers have been deprecated at this point, but
they are still in use today and will still be available until Ember v4. As such,
their syntax needs to remain available and unchanged:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  }).readOnly().volatile().property('lastName') // a very strange combination
});
</code></pre>
<p>The decorator returned from <code>computed()</code> will need to have these chainable
methods available, and they will need to set the state of the decorator. This
should not be too difficult to accomplish.</p>
<p>Usage in native decorator syntax is a little bit trickier. In the current
proposal, only simple chaining is allowed in a decorator invocation. You may not
chain on the result of a function:</p>
<pre><code class="language-js">import { computed } from '@ember/object';

const fullName = computed('firstName', 'lastName', function() {
  return `${this.firstName} ${this.lastName}`;
});

class Person {
  @computed('firstName', 'lastName').readOnly() // this is invalid JS decorator syntax
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  @fullName.readOnly() // this is valid because it's a simple chain
  otherFullName;
}
</code></pre>
<p>Luckily, there is one other form of invocation which is available - wrapping the
entire decorator expression in parenthesis:</p>
<pre><code class="language-js">import { computed } from '@ember/object';

class Person {
  @(computed('firstName', 'lastName').readOnly()) // this is valid
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>This is clearly <em>not</em> ideal for commonly used features, and while <code>volatile()</code>
and <code>property()</code> are not very well known, <code>readOnly()</code> is generally considered
best practice, and is used all over the place. However, it <em>is</em> deprecated, and
in the future computed properties will be read only by default. Rather than
attempt to write a different API for decorators, this RFC proposes that we
accept the current syntax, and focus instead on the implementation of Svelte.
This will allow users to enable default read only CPs much sooner, and prevent
the need to use <code>readOnly()</code> at all.</p>
<a class="header" href="print.html#a-tale-of-two-readonlys" id="a-tale-of-two-readonlys"><h5>A Tale of Two <code>readOnly</code>s</h5></a>
<p>You may be wondering why we can't add more decorators to Ember to take the place
of these modifiers. The crux of the issue is the <code>readOnly()</code> modifier, and the
<code>readOnly()</code> macro. These share a name, and when macros become decorators as
well they will collide. The only difference would be the import paths, and this
would result in awkward renaming which would likely <em>not</em> be conventional:</p>
<pre><code class="language-js">import { readOnly, computed } from '@ember/object';
import { readOnly as readOnlyAlias } from '@ember/object/computed';

class Person {
  @readOnly
  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  @readOnlyAlias('fullName')
  otherFullName;
}
</code></pre>
<p>Ember Decorators made the decision to attempt renaming the macros themselves,
since <code>reads</code>, <code>readOnly</code>, and <code>oneWay</code> were all poorly named (arguably, <code>reads</code>
should have been <code>readOnly</code> since it is the more common use case) but this is
not a possibility in Ember, since this would cause collisions and confusion
within the macros namespace.</p>
<p>All of this would be to support a deprecated feature, which can still be used
(albeit, with a less-than-ideal syntax). Accepting the current syntax would also
prevent us from polluting the decorator namespace - we may want to use
<code>@readOnly</code> or <code>@volatile</code> in the future with tracked properties instead.</p>
<a class="header" href="print.html#actions" id="actions"><h3>Actions</h3></a>
<p>Actions are special in Ember because they are namespaced within a class on the
<code>actions</code> object, despite being able to reference the class directly using
<code>this</code> when called, and otherwise behaving like standard methods. The reason for
this stems from the early days of Ember, when users would accidentally name an
action something that conflicted with existing lifecycle and event hooks (e.g.
<code>destroy</code>, or <code>click</code>). The <code>actions</code> namespace was added as a convenience to
prevent these collisions, and to separate them from the rest of the class body
organizationally.</p>
<p>This namespace is problematic for native classes for a number of reasons:</p>
<ol>
<li>The namespace cannot be defined using class field syntax, since that would
assign a copy of the object to every instance of the class, and there is no
other native way to easily assign it.</li>
<li>Actions must inherit from the parent, which means that the <code>actions</code> object
must have its prototype set to the parent class's <code>actions</code> object.</li>
<li>It is not possible to use <code>super</code> within non-class methods, meaning an
alternative would have to be developed specifically for the namespace.</li>
</ol>
<p>With these constraints, a decorator would be necessary to maintain the current
namespacing functionality. The options for such a decorator are limited. It
could:</p>
<ol>
<li>
<p>Decorate a class field, placing the value on the class prototype and setting
up inheritance/super functionality. This would necessarily result in either
some amount of repetition in the decorator name and field name, or a
redundant field name:</p>
<pre><code class="language-js">class Foo {
  @actions actions = {
    onClick() { /* ... */ }
  }
}
</code></pre>
</li>
<li>
<p>Decorate the class itself with the actions object as a parameter. This would
be awkward, since actions would be removed from the class definition:</p>
<pre><code class="language-js">@actions({
  onClick() { /* ... */ }
})
class Foo {}
</code></pre>
</li>
<li>
<p>Decorate the class itself, with the expectation that the <code>actions</code> class
field exists and is an object. This leads to a disconnect between the
decoration and the definition that is easy to miss, and could be
counterintuitive to newcomers:</p>
<pre><code class="language-js">@actionHandler
class Foo {
  actions = {
    onClick() { /* ... */ }
  }
}
</code></pre>
</li>
</ol>
<p>None of these options is ergonomic in the least. Instead, it is much cleaner and
easier to decorate method definitions that are directly on the class body:</p>
<pre><code class="language-js">class Foo {
  @action
  onClick() { /* ... */ }
}
</code></pre>
<p>This would be implemented by creating the class's <code>actions</code> object and assigning
the method to it, setting up inheritance and such in the process. The decorator
leaves the method definition on the class, where it can be called like a normal
method would, including <code>super</code> functionality. This maintains compatibility with
the classic object model, while making the <code>actions</code> namespace an
<em>implementation</em> detail rather than something users need to know about.</p>
<p>This does mean that actions can once again collide with actual lifecycle and
event hooks on the class, since they are no longer namespaced. The decorator
<em>could</em> remove the method from the class definition entirely, but this would be
confusing for users not familiar with the old <code>actions</code> namespace - why does
this method disappear from the class? It would also break <code>super</code> functionality,
so it would not be ideal to do this.</p>
<p>The <code>@action</code> decorator <em>could</em> warn users when it collides with a lifecycle
hook. However, hooks may vary from class type to class type, which presents a
design challenge. We could either:</p>
<ol>
<li>Allow classes to specify lifecycle hooks, and throw whenever <code>@action</code>
collides with a specified hook.</li>
<li>Only throw on hooks that are shared across all classes, such as <code>init</code> and
<code>destroy</code>.</li>
<li>Do nothing, and leave it to user's to know which lifecycle hooks exist.</li>
</ol>
<p>Specifying hooks for each class would be time consuming and could fall out of
sync with the implementations. Throwing on &quot;universal&quot; hooks only is
inconsistent, and could lead users to think that they are safe when they are
not. This RFC suggests that we choose option 3 for this reason. When the actions
namespace was introduced, lifecycle hooks like <code>destroy</code> and <code>click</code> were less
commonly known and used (event listeners were not uncommon). Most Ember users
know they exist now, and will be aware that implementing an action with the same
name is not recommended. In addition, eslint rules can be added to hint against
these collisions.</p>
<a class="header" href="print.html#method-binding" id="method-binding"><h3>Method Binding</h3></a>
<p><code>@action</code> will also bind the function to the class instance, allowing it to be
used in templates and elsewhere without having to be bound:</p>
<pre><code class="language-js">export default class ButtonComponent extends Component {
  @action
  onClick() {
    // handle click
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;button onclick={{this.onClick}}&gt;Click me!&lt;/button&gt;
</code></pre>
<a class="header" href="print.html#usage-and-api-1" id="usage-and-api-1"><h4>Usage and API</h4></a>
<p>The API for this new decorator would be much simpler than the computed API,
since it is only used as a decorator without parameters.</p>
<pre><code class="language-ts">// Technically `action` is a function, but we can't type it transparently that way
const action: MethodDecorator;
</code></pre>
<p>Attempting to pass any parameters to the decorator, or to apply the decorator to
anything other than a class method, will throw an error.</p>
<a class="header" href="print.html#how-we-teach-this-67" id="how-we-teach-this-67"><h2>How we teach this</h2></a>
<p>Teaching decorators is intrinsically tied to a wider shift in the Ember
programming model - the Ember Octane edition. From a teaching perspective, this
edition will be completely overhauling the guides and updating all of the best
practices as they stand. New users should see native class syntax with
decorators as the <em>default</em>, and should not ever have to write a classic class
or see an example for one.</p>
<p>With this RFC, the majority of existing examples in the Ember guides will be
updatable to native class syntax. The exception would be examples of classic
components, which would be addressed separately by updating the guides to
Glimmer Components (proposed in a separate RFC). Otherwise, all examples in the
guides should be updated.</p>
<a class="header" href="print.html#updating-and-interop" id="updating-and-interop"><h3>Updating and Interop</h3></a>
<p>For existing users, or users who have to interact with classic code from a modern
context, it'll be important to have a reference for the classic object model.
The current section on the object model in the guides can be moved to a classic
section, and a section on updating should be added. Links to relevant codemods,
such as the
<a href="https://github.com/scalvert/ember-es6-class-codemod">ember-es6-class-codemod</a>,
should be included. This section should remain updated and included in the main
guides for as long as <code>EmberObject</code> is a part of Ember's public API.</p>
<a class="header" href="print.html#acceptance-commitments" id="acceptance-commitments"><h2>Acceptance Commitments</h2></a>
<blockquote>
<p>This section serves to capture the various commitments accepting this RFC
would entail.</p>
</blockquote>
<ul>
<li>Adds support for decorators and class fields to Ember's public API. Transforms
would be included out of the box as well.</li>
<li>Allows computed properties to work as a native decorators on native classes.</li>
<li>Adds the <code>@action</code> decorator for defining actions on native classes.</li>
</ul>
<a class="header" href="print.html#drawbacks-91" id="drawbacks-91"><h2>Drawbacks</h2></a>
<ul>
<li>
<p>The <code>ComputedProperty</code> class has long been considered intimate API. Even with
recent changes as part of the native getter RFC to make it more private, these
changes could still cause breakage.</p>
</li>
<li>
<p>The strategy for converting <code>computed</code> to decorators has one major drawback,
which is that decorator macros cannot easily be customized and will require a
bit of boilerplate in some cases. For instance, currently in Ember Decorators
it is possible to apply the <code>map</code> and <code>reduce</code> macros directly to a <em>method</em>,
which becomes the method to map or reduce by:</p>
<pre><code class="language-js">@map('array')
mappedArray() {}

@map('array', function() {}) mappedArray;
</code></pre>
<p>With this method, only the second form would be usable. Likewise, by default
addons like Ember Data would need to write thin decorator wrappers around
macros that may be called <em>without</em> parameters, or which require key
reflection:</p>
<pre><code class="language-js">@attr name; // This would not work OOTB
@attr('string') name; // This would

@belongsTo user; // This would not work OOTB
@belongsTo('user') user; // This would
</code></pre>
</li>
</ul>
<a class="header" href="print.html#alternatives-93" id="alternatives-93"><h2>Alternatives</h2></a>
<a class="header" href="print.html#no-decorators" id="no-decorators"><h3>No Decorators</h3></a>
<p>We could not have official Ember support for any aspects of the classic
programming model. This essentially means computed properties, since <code>@action</code>
and the injection helpers are still needed for the Octane model. This would
leave many users in limbo, unable to update to native class syntax fully because
it would mean rewriting large amounts of classes and components, and would make
libraries like <code>@ember-decorators</code> essential.</p>
<a class="header" href="print.html#namespaced-decorators" id="namespaced-decorators"><h3>Namespaced Decorators</h3></a>
<p>We could include decorators as a separate package, such as <code>@ember/decorators</code>.
This is not ideal as it would force users to remember more import paths, and it
would make eventual deprecation of the classic form much more difficult. It would
also mean that the wider ecosystem would have to do much more work to adopt
decorator syntax.</p>
<a class="header" href="print.html#full-compatibility-decorators" id="full-compatibility-decorators"><h3>Full Compatibility Decorators</h3></a>
<p>We could include decorators for the remaining classic features: Observers, event
listeners, and classic components. These would add extra weight, and may
encourage users to continue using these features, which would not be ideal.</p>
<p>Instead, we can recommend that users wanting to update to native class syntax
use external packages that implement these features, such as
<code>@ember-decorators</code>. The native class codemod will detect and automatically
include these packages if they are necessary.</p>
<a class="header" href="print.html#default-read-only-decorator" id="default-read-only-decorator"><h3>Default Read Only Decorator</h3></a>
<p>In this proposal, computeds used as decorators match the semantics of computeds
used in classic classes exactly. This is true even in the unfortunate case of
computed overridability:</p>
<pre><code class="language-js">class Person {
  firstName = 'Stefan';
  lastName = 'Penner';

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let person = new Person;

person.fullName; // 'Tom Dale'

person.set('firstName', 'Kris');
person.set('lastName', 'Selden');

person.set('fullName', 'Melanie Sumner'); // overrides the setter

person.fullName; // 'Melanie Sumner'
</code></pre>
<p>We could, instead, make decorators apply computeds as <em>readOnly by default</em>,
since this is a new usage of them and not a breaking change. This would require
us to add a new <code>overridable()</code> modifier to opt-out of readOnly behavior by
default, for backwards compatibility, and would add a fair amount of complexity
to codemods. Either way, this behavior will be the default in Ember v4, and
deprecations will begin appearing when this happens soon.</p>
<a class="header" href="print.html#allow-action-to-rename-actions" id="allow-action-to-rename-actions"><h3>Allow <code>@action</code> to Rename Actions</h3></a>
<p>If the namespace collisions caused by actions becoming standard methods are
difficult to refactor around or codemod, we can consider allowing the <code>@action</code>
helper to receive an alternative action name:</p>
<pre><code class="language-js">export default class ButtonComponent extends GlimmerComponent {
  @action('destroy')
  destroyAction() {
    // handle click
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;button {{action 'destroy'}}&gt;Click me!&lt;/button&gt;
</code></pre>
<p>This could be added later by a followup RFC, so it is not part of this proposal.
Ideally it won't be necessary.</p>
<a class="header" href="print.html#unresolved-questions-64" id="unresolved-questions-64"><h2>Unresolved questions</h2></a>
<p>As stated in the introduction, this RFC is being made with the assumption that
decorators will be moved to stage 3 before this RFC is actually implemented. If
they are <em>not</em> moved to stage 3, we will have to decide if decorators should be
supported in while they are in stage 2.</p>
<p>If they are supported while in stage 2, there are some additional questions:</p>
<ul>
<li>Should stage 2 transforms continue to be supported after decorators move to
stage 3? Would removing stage 2 support require a major version bump?</li>
<li>Should Typescript's stage 1-like decorators be supported, since Typescript
will not implement new decorator transforms until they reach stage 3?</li>
</ul>
<a class="header" href="print.html#appendix-a-1" id="appendix-a-1"><h2>Appendix A</h2></a>
<p>This appendix contains the list of affected APIs and new APIs for quick reference.</p>
<p>| <code>@ember/controller</code> |
|---------------------|
| <code>inject</code>            |</p>
<p>| <code>@ember/object</code> |
|-----------------|
| <code>computed</code>      |
| <em><code>action</code></em>      |</p>
<p>| <code>@ember/object/computed</code> |
|--------------------------|
| <code>alias</code>                  |
| <code>and</code>                    |
| <code>bool</code>                   |
| <code>collect</code>                |
| <code>deprecatingAlias</code>       |
| <code>empty</code>                  |
| <code>equal</code>                  |
| <code>filter</code>                 |
| <code>filterBy</code>               |
| <code>gt</code>                     |
| <code>gte</code>                    |
| <code>intersect</code>              |
| <code>lt</code>                     |
| <code>lte</code>                    |
| <code>map</code>                    |
| <code>mapBy</code>                  |
| <code>match</code>                  |
| <code>max</code>                    |
| <code>min</code>                    |
| <code>none</code>                   |
| <code>not</code>                    |
| <code>notEmpty</code>               |
| <code>oneWay</code>                 |
| <code>or</code>                     |
| <code>readOnly</code>               |
| <code>reads</code>                  |
| <code>setDiff</code>                |
| <code>sort</code>                   |
| <code>sum</code>                    |
| <code>union</code>                  |
| <code>uniq</code>                   |
| <code>uniqBy</code>                 |</p>
<p>| <code>@ember/service</code> |
|------------------|
| <code>inject</code>         |</p>
<a class="header" href="print.html#appendix-b-2" id="appendix-b-2"><h2>Appendix B</h2></a>
<p>This appendix contains a full list of changed APIs and their old and new signatures.</p>
<a class="header" href="print.html#embercontroller-1" id="embercontroller-1"><h3><strong><code>@ember/controller</code></strong></h3></a>
<ul>
<li><code>inject</code>
<pre><code class="language-ts">// old
function inject(): ComputedProperty&lt;Controller&gt;;
function inject&lt;K extends keyof ControllerRegistry&gt;(
    name: K
): ComputedProperty&lt;ControllerRegistry[K]&gt;;

// new
function inject(): PropertyDecorator;
function inject&lt;K extends keyof ControllerRegistry&gt;(
    name: K
): PropertyDecorator;
</code></pre>
</li>
</ul>
<a class="header" href="print.html#emberobject-1" id="emberobject-1"><h3><strong><code>@ember/object</code></strong></h3></a>
<ul>
<li>
<p><code>computed</code></p>
<pre><code class="language-ts">// old
function computed(...args: (string | ComputedPropertyConfig&lt;T&gt;)[]): ComputedProperty&lt;T&gt;;

// new
function computed(...args: (string | ComputedPropertyConfig)[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>action</code></p>
<pre><code class="language-ts">// old
// N/A

// new
const action: MethodDecorator;
</code></pre>
</li>
</ul>
<a class="header" href="print.html#emberobjectcomputed" id="emberobjectcomputed"><h3>**<code>@ember/object/computed</code></h3></a>
<ul>
<li>
<p><code>alias</code></p>
<pre><code class="language-ts">// old
function alias(dependentKey: string): ComputedProperty&lt;any&gt;;

// new
function alias(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>and</code></p>
<pre><code class="language-ts">// old
function and(...dependentKeys: string[]): ComputedProperty&lt;boolean&gt;;

// new
function and(...dependentKeys: string[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>bool</code></p>
<pre><code class="language-ts">// old
function bool(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function bool(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>collect</code></p>
<pre><code class="language-ts">// old
function collect(...dependentKeys: string[]): ComputedProperty&lt;any[]&gt;;

// new
function collect(...dependentKeys: string[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>deprecatingAlias</code></p>
<pre><code class="language-ts">// old
function deprecatingAlias(
  dependentKey: string,
  options: { id: string; until: string }
): ComputedProperty&lt;any&gt;;

// new
function deprecatingAlias(
  dependentKey: string,
  options: { id: string; until: string }
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>empty</code></p>
<pre><code class="language-ts">// old
function empty(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function empty(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>equal</code></p>
<pre><code class="language-ts">// old
function equal(dependentKey: string, value: any): ComputedProperty&lt;boolean&gt;;

// new
function equal(dependentKey: string, value: any): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>filter</code></p>
<pre><code class="language-ts">// old
function filter(
  dependentKey: string,
  callback: (value: any, index: number, array: any[]) =&gt; boolean
): ComputedProperty&lt;any[]&gt;;

// new
function filter(
  dependentKey: string,
  callback: (value: any, index: number, array: any[]) =&gt; boolean
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>filterBy</code></p>
<pre><code class="language-ts">// old
function filterBy(
  dependentKey: string,
  propertyKey: string,
  value?: any
): ComputedProperty&lt;any[]&gt;;

// new
function filterBy(
  dependentKey: string,
  propertyKey: string,
  value?: any
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>gt</code></p>
<pre><code class="language-ts">// old
function gt(dependentKey: string, value: number): ComputedProperty&lt;boolean&gt;;

// new
function gt(dependentKey: string, value: number): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>gte</code></p>
<pre><code class="language-ts">// old
function gte(dependentKey: string, value: number): ComputedProperty&lt;boolean&gt;;

// new
function gte(dependentKey: string, value: number): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>intersect</code></p>
<pre><code class="language-ts">// old
function intersect(...propertyKeys: string[]): ComputedProperty&lt;any[]&gt;;

// new
function intersect(...propertyKeys: string[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>lt</code></p>
<pre><code class="language-ts">// old
function lt(dependentKey: string, value: number): ComputedProperty&lt;boolean&gt;;

// new
function lt(dependentKey: string, value: number): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>lte</code></p>
<pre><code class="language-ts">// old
function lte(dependentKey: string, value: number): ComputedProperty&lt;boolean&gt;;

// new
function lte(dependentKey: string, value: number): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>map</code></p>
<pre><code class="language-ts">// old
function map&lt;U&gt;(
  dependentKey: string,
  callback: (value: any, index: number, array: any[]) =&gt; U
): ComputedProperty&lt;U[]&gt;;

// new
function map&lt;U&gt;(
  dependentKey: string,
  callback: (value: any, index: number, array: any[]) =&gt; U
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>mapBy</code></p>
<pre><code class="language-ts">// old
function mapBy(dependentKey: string, propertyKey: string): ComputedProperty&lt;any[]&gt;;

// new
function mapBy(dependentKey: string, propertyKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>match</code></p>
<pre><code class="language-ts">// old
function match(dependentKey: string, regexp: RegExp): ComputedProperty&lt;boolean&gt;;

// new
function match(dependentKey: string, regexp: RegExp): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>max</code></p>
<pre><code class="language-ts">// old
function max(dependentKey: string): ComputedProperty&lt;number&gt;;

// new
function max(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>min</code></p>
<pre><code class="language-ts">// old
function min(dependentKey: string): ComputedProperty&lt;number&gt;;

// new
function min(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>none</code></p>
<pre><code class="language-ts">// old
function none(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function none(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>not</code></p>
<pre><code class="language-ts">// old
function not(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function not(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>notEmpty</code></p>
<pre><code class="language-ts">// old
function notEmpty(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function notEmpty(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>oneWay</code></p>
<pre><code class="language-ts">// old
function oneWay(dependentKey: string): ComputedProperty&lt;any&gt;;

// new
function oneWay(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>or</code></p>
<pre><code class="language-ts">// old
function or(...dependentKeys: string[]): ComputedProperty&lt;boolean&gt;;

// new
function or(...dependentKeys: string[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>readOnly</code></p>
<pre><code class="language-ts">// old
function readOnly(dependentKey: string): ComputedProperty&lt;any&gt;;

// new
function readOnly(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>reads</code></p>
<pre><code class="language-ts">// old
function reads(dependentKey: string): ComputedProperty&lt;any&gt;;

// new
function reads(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>setDiff</code></p>
<pre><code class="language-ts">// old
function setDiff(setAProperty: string, setBProperty: string): ComputedProperty&lt;any[]&gt;;

// new
function setDiff(setAProperty: string, setBProperty: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>sort</code></p>
<pre><code class="language-ts">// old
function sort(
  itemsKey: string,
  sortDefinition: string | ((itemA: any, itemB: any) =&gt; number)
): ComputedProperty&lt;any[]&gt;;

// new
function sort(
  itemsKey: string,
  sortDefinition: string | ((itemA: any, itemB: any) =&gt; number)
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>sum</code></p>
<pre><code class="language-ts">// old
function sum(dependentKey: string): ComputedProperty&lt;number&gt;;

// new
function sum(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>union</code></p>
<pre><code class="language-ts">// old
function union(...propertyKeys: string[]): ComputedProperty&lt;any[]&gt;;

// new
function union(...propertyKeys: string[]): PropertyDecorator
</code></pre>
</li>
<li>
<p><code>uniq</code></p>
<pre><code class="language-ts">// old
function uniq(propertyKey: string): ComputedProperty&lt;any[]&gt;;

// new
function uniq(propertyKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>uniqBy</code></p>
<pre><code class="language-ts">// old
function uniqBy(dependentKey: string, propertyKey: string): ComputedProperty&lt;any[]&gt;;

// new
function uniqBy(dependentKey: string, propertyKey: string): PropertyDecorator;
</code></pre>
</li>
</ul>
<a class="header" href="print.html#emberservice-1" id="emberservice-1"><h3><strong><code>@ember/service</code></strong></h3></a>
<ul>
<li><code>inject</code>
<pre><code class="language-ts">// old
function inject(): ComputedProperty&lt;Service&gt;;
function inject&lt;K extends keyof ServiceRegistry&gt;(
    name: K
): ComputedProperty&lt;ServiceRegistry[K]&gt;;

// new
function inject(): PropertyDecorator;
function inject&lt;K extends keyof ServiceRegistry&gt;(
    name: K
): PropertyDecorator;
</code></pre>
</li>
</ul>
<ul>
<li>Start Date: 2018-12-05</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/410</li>
<li>Ember Issue: (leave this empty)</li>
<li>Authors: Tom Dale, Chris Garrett, Chad Hietala, Yehuda Katz</li>
</ul>
<a class="header" href="print.html#tracked-properties" id="tracked-properties"><h1>Tracked Properties</h1></a>
<a class="header" href="print.html#summary-96" id="summary-96"><h2>Summary</h2></a>
<p>Tracked properties introduce a simpler and more ergonomic system for tracking
state change in Ember applications. By taking advantage of new JavaScript
features, tracked properties allow Ember to reduce its API surface area while
producing code that is both more intuitive and less error-prone.</p>
<p>This simple example shows a <code>Person</code> class with three tracked properties:</p>
<pre><code class="language-js">export default class Person {
  @tracked firstName = 'Chad';
  @tracked lastName = 'Hietala';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<a class="header" href="print.html#a-note-on-decorator-support" id="a-note-on-decorator-support"><h3>A Note on Decorator Support</h3></a>
<p>This RFC proposes a decorator version of tracked properties, and uses this
decorator version in most examples, on the assumption that the [Decorators RFC]
(https://github.com/emberjs/rfcs/pull/408) will be accepted and implemented
before this RFC. If the Decorators RFC is <em>not</em> accepted, or cannot be
implemented due to other criteria not being met (such as decorators remaining at
stage 2), then only the classic class syntax for tracked properties will be
implemented.</p>
<a class="header" href="print.html#terminology-3" id="terminology-3"><h2>Terminology</h2></a>
<p>Because of the occasional overlap in terminology when discussing similar
features, this document uses the following language consistently:</p>
<ul>
<li>A <strong>getter</strong> is an ES5 JavaScript feature that executes a function to
determine the value of a property. The function is executed every time the
property is accessed.</li>
<li>A <strong>computed property</strong> is a property on an Ember object whose value is lazily
produced by executing a function. That value is nearly always cached until one
of computed property's dependencies changes.</li>
<li>A <strong>tracked property</strong> refers to any class field that has been instrumented
with <code>@tracked</code>. Unlike computed properties, tracked properties are <em>never</em>
getters or setters.</li>
<li>The <strong>classic programming model</strong> refers to the traditional Ember programming
model. It includes <em>classic classes</em>, <em>computed properties</em>, <em>event
listeners</em>, <em>observers</em>, <em>property notifications</em>, and <em>classic components</em>,
and more generally refers to features that will not be central to Ember
Octane. Concepts like <em>routes</em>, <em>controllers</em>, and <em>services</em> belong to both
the Octane programming model and the classic programming model.</li>
<li><strong>Native classes</strong> are classes defined using the Javascript <code>class</code> keyword.</li>
<li><strong>Classic classes</strong> are classes defined by subclassing from <code>EmberObject</code>
using the static <code>extend</code> method.</li>
</ul>
<a class="header" href="print.html#motivation-97" id="motivation-97"><h2>Motivation</h2></a>
<p>Tracked properties are designed to be simpler to learn, simpler to write, and
simpler to maintain than today's computed properties. In addition to clearer
code, tracked properties eliminate the most common sources of bugs and mental
model confusion in computed properties today, and reduce memory overhead by not
caching by default.</p>
<a class="header" href="print.html#leverage-existing-javascript-knowledge" id="leverage-existing-javascript-knowledge"><h3>Leverage Existing JavaScript Knowledge</h3></a>
<p>Ember's computed properties provide functionality that overlaps with native
JavaScript getters and setters. Because native getters don't provide Ember with
the information it needs to track changes, it's not possible to use them
reliably in templates or in other computed properties.</p>
<p>New learners have to &quot;unlearn&quot; native getters, replacing them with Ember's
computed property system. Unfortunately, this knowledge is not portable to other
applications that don't use Ember that developers may work on in the future, and
while this problem may be lessened by adopting native classes and decorators, it
still requires users learn Ember's notification system and its quirks.</p>
<p>Tracked properties are as thin a layer as possible on top of native JavaScript.
Tracked properties look like normal properties because they <em>are</em> normal
properties.</p>
<p>Because there is no special syntax for retrieving a tracked property, any
JavaScript syntax that feels like it should work does work:</p>
<pre><code class="language-js">// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];
</code></pre>
<p>Similarly, syntax for changing properties works just as well:</p>
<pre><code class="language-js">// Simple assignment
this.firstName = 'Yehuda';
// Addition assignment (+=)
this.lastName += 'Katz';
// Increment operator
this.age++;
</code></pre>
<p>This compares favorably with APIs from other libraries, which becomes more
verbose than necessary when JavaScript syntax isn't available:</p>
<pre><code class="language-js">this.setState({
  age: this.state.age + 1,
});
</code></pre>
<pre><code class="language-js">this.setState({
  lastName: this.state.lastName + &quot;Katz&quot;;
})
</code></pre>
<a class="header" href="print.html#avoiding-dependency-hell" id="avoiding-dependency-hell"><h3>Avoiding Dependency Hell</h3></a>
<p>Currently, Ember requires developers to manually enumerate a computed property's
dependent keys: the list of <em>other</em> properties that <em>this</em> computed property
depends on. Whenever one of the listed properties changes, the computed
property's cache is cleared and any listeners are notified that the computed
property has changed.</p>
<p>In this example, <code>'firstName'</code> and <code>'lastName'</code> are the dependent keys of the
<code>fullName</code> computed property:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  }),
});
</code></pre>
<p>While this system typically works well, it comes with its share of drawbacks.</p>
<p>First, it's extra work to have to type every property twice: once as a string as
a dependent key, and again as a property lookup inside the function. While
explicit APIs can often lead to clearer code, this verbosity has the potential
to complicate the implementation without improving developer intent at all.
People understand intuitively that they are typing out dependent keys to help
<em>Ember</em>, not other programmers.</p>
<p>It's also not clear what syntax goes inside the dependent key string. In this
simple example it's a property name, but nested dependencies become a property
path, like <code>'person.firstName'</code>. (Good luck writing a computed property that
depends on a property with a period in the name.)</p>
<p>You might form the mental model that a JavaScript expression goes inside the
string—until you encounter the <code>{firstName,lastName}</code> expansion syntax or the
magic <code>@each</code> syntax for array dependencies.</p>
<p>The truth is that dependent key strings are made up of an unintuitive,
unfamiliar microsyntax that you just have to memorize if you want to use Ember
well.</p>
<p>Lastly, it's easy for dependent keys to fall out of sync with the
implementation, leading to difficult-to-detect, difficult-to-troubleshoot bugs.</p>
<p>For example, imagine a new member on our team is assigned a bug where a user's
middle name is not appearing in their profile. Our intrepid developer finds the
problem, and updates <code>fullName</code> to include the middle name:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }),
});
</code></pre>
<p>They test their change and it seems to work. Unfortunately, they've just
introduced a subtle bug. If the user's <code>middleName</code> were to change, <code>fullName</code>
wouldn't update! Maybe this will get caught in a code review, given how simple
the computed property is, but noticing missing dependencies is a challenge even
for experienced Ember developers when the computed property gets more
complicated.</p>
<p>Tracked properties have a feature called <em>autotrack</em>, where dependencies are
automatically detected as they are used. This means that as long as all
properties that are dependencies are marked as tracked, they will automatically
be detected:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>Note that getters and setters do <em>not</em> need to be marked as tracked, only the
properties that they access need to. This also allows us to opt out of tracking
entirely, like if we know for instance that a given property is constant and
will never change. In general, the idea is that <em>mutable</em>, <em>watchable</em>
properties should be marked as tracked, and <em>immutable</em> or <em>unwatched</em>
properties should not be.</p>
<a class="header" href="print.html#reducing-memory-consumption" id="reducing-memory-consumption"><h3>Reducing Memory Consumption</h3></a>
<p>By default, computed properties cache their values. This is great when a
computed property has to perform expensive work to produce its value, and that
value gets used over and over again.</p>
<p>But checking, populating, and invalidating this cache comes with its own
overhead. Modern JavaScript VMs can produce highly optimized code, and in many
cases the overhead of caching is greater than the cost of simply recomputing the
value.</p>
<p>Worse, cached computed property values cannot be freed by the garbage collector
until the entire object is freed. Many computed properties are accessed only
once, but because they cache by default, they take up valuable space on the heap
for no benefit.</p>
<p>For example, imagine this component that checks whether the <code>files</code> property is
supported in input elements:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { computed } from '@ember/object';

export default Component.extend({
  inputElement: computed(function() {
    return document.createElement('input');
  }),

  supportsFiles: computed('inputElement', function() {
    return 'files' in this.inputElement;
  }),

  didInsertElement() {
    if (this.supportsFiles) {
      // do something
    } else {
      // do something else
    }
  },
});
</code></pre>
<p>This component would create and retain an <code>HTMLInputElement</code> DOM node for the
lifetime of the component, even though all we really want to cache is the
Boolean value of whether the browser supports the <code>files</code> attribute.</p>
<p>Particularly on inexpensive mobile devices, where RAM is limited and often slow, we should
be more conservative about our memory consumption. Tracked properties switch
from an opt-out caching model to opt-in, allowing developers to err on the side
of reduced memory usage, but easily enabling caching (a.k.a. memoization) if a
property shows up as a bottleneck during profiling.</p>
<a class="header" href="print.html#prior-art-2" id="prior-art-2"><h2>Prior Art</h2></a>
<p>Tracked properties were first implemented in <a href="https://glimmerjs.com/">Glimmer.js</a>,
and were recently polyfilled with clever usage of <code>notifyPropertyChange</code> by
the <a href="https://github.com/rwjblue/sparkles-component/">sparkles-components</a> addon.
These initial implementations inform the design in this RFC, but differ from it
in some key ways. For instance, both Sparkles's and early versions of Glimmer's
<code>@tracked</code> did not have an autotracking stack, and instead relied on explicit
dependency keys. After benchmarking showed that autotracking was a viable
strategy, the API for <code>@tracked</code> was updated to what is proposed here.</p>
<a class="header" href="print.html#detailed-design-82" id="detailed-design-82"><h2>Detailed Design</h2></a>
<p>This RFC proposes adding the <code>tracked</code> decorator function, used to mark class
fields as tracked:</p>
<pre><code class="language-ts">const tracked: PropertyDecorator;
</code></pre>
<p>This new function will be exported from <code>@glimmer/tracking</code>. Revisiting our
example from earlier, <code>@tracked</code> can be used on native class fields and
getters/setters:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<a class="header" href="print.html#getting-tracked-properties" id="getting-tracked-properties"><h3>Getting Tracked Properties</h3></a>
<p>Tracked properties can be accessed using standard Javascript syntax. From the
user's point of view, there is nothing special about them. This should continue
to work in the future, even if new methods are added for accessing properties,
because tracked properties use native getters under the hood.</p>
<pre><code class="language-js">let person = new Person();

// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];
</code></pre>
<a class="header" href="print.html#setting-tracked-properties" id="setting-tracked-properties"><h3>Setting Tracked Properties</h3></a>
<p>Tracked properties can be set using standard Javascript syntax. They use native
setters under the hood, meaning that there is no need for using a setter method
like <code>set</code>.</p>
<pre><code class="language-js">let person = new Person();

// Simple assignment
person.firstName = 'Jen';
// Addition assignment (+=)
person.lastName += 'Weber';
// Increment operator
person.age++;
</code></pre>
<a class="header" href="print.html#autotracking" id="autotracking"><h3>Autotracking</h3></a>
<p>Tracked properties do not need to specify their dependencies. Under the hood,
this works by utilizing an <em>autotrack stack</em>. This stack is a bit of global
state which tracked properties can access. As tracked properties are accessed,
they push themselves onto the stack, and once they have finished running, the
stack contains the full list of all the tracked properties that were accessed
while it was running.</p>
<p>In our first example, with the <code>Person</code> class, we can see this in action:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>When we create a new instance of <code>Person</code>, the tracking system has no knowledge
of the connection between <code>fullName</code>, <code>firstName</code>, and <code>lastName</code>. Now, let's
say we go to render this person's name in a component's template:</p>
<pre><code class="language-hbs">{{this.person.fullName}}
</code></pre>
<p>When Glimmer accesses the <code>fullName</code> property on person, it creates an
<em>autotrack stack frame</em>. As we computed <code>fullName</code>, any values that are
decorated with <code>@tracked</code> push themselves into this stack frame. Because getters
and setters are pure functions, they will ultimately end up accessing some
tracked properties - in this case, the <code>fullName</code> getter accesses the
<code>firstName</code> and <code>lastName</code> properties, and they push themselves onto the stack
frame.</p>
<p>In this way, Glimmer will know about <em>all</em> properties that were accessed when
calculating any bound value in templates.</p>
<blockquote>
<p><strong>NOTE:</strong> This does <em>not</em> invalidate a cache like in computed properties.
Internally, Glimmer checks to see if a value has updated <em>before calling the
getter</em>. If it hasn't, then Glimmer does not rerender the related section of
the DOM. This is effectively an automatic <code>shouldComponentUpdate</code> (at least
the most common usage) from React.</p>
</blockquote>
<a class="header" href="print.html#manual-invalidation" id="manual-invalidation"><h3>Manual Invalidation</h3></a>
<p>In user code, the idea that all mutable properties should be marked as tracked
and that all other properties are effectively immutable works well in isolation.
However, there are cases where users will want to work with code they do <em>not</em>
control, such as external library code.</p>
<p>Consider the following example. We have a <code>simple-timer</code> library that we've
imported from NPM, and we're trying to wrap it with a <code>TimerComponent</code> that
uses it to keep track of how much time has passed:</p>
<pre><code class="language-js">// simple-timer/index.js
export default class Timer {
  seconds = 0;
  minutes = 0;
  hours = 0;

  listeners = [];

  constructor() {
    setInterval(() =&gt; {
      this.seconds++;
      this.minutes = Math.floor(this.seconds / 60);
      this.hours = Math.floor(this.minutes / 60);
      this.notifyTick();
    }, 1000);
  }

  notifyTick() {
    for (let listener of this.listeners) {
      listener(this.seconds);
    }
  }

  onTick(listener) {
    this.listeners.push(listener);
  }
}
</code></pre>
<pre><code class="language-js">import Timer from 'simple-timer';
import Component, { tracked } from '@glimmer/tracking';

export default class TimerComponent extends Component {
  @tracked timer = new Timer();

  get currentSeconds() {
    return this.timer.seconds;
  }

  get currentMinutes() {
    return this.timer.minutes;
  }
}
</code></pre>
<p>Even though we've marked the <code>timer</code> property as tracked, the <code>timer.seconds</code>
property is untracked, and <em>it</em> is the field that is updated. We can solve this
problem by using the timer library's <code>onTick</code> event handler to re-set the field,
invalidating it:</p>
<pre><code class="language-js">export default class TimerComponent extends Component {
  @tracked timer = new Timer();

  constructor() {
    this.timer.onTick(() =&gt; {
      // invalidate the timer field.
      this.timer = this.timer;
    });
  }

  get currentSeconds() {
    return this.timer.seconds;
  }

  get currentMinutes() {
    return this.timer.minutes;
  }
}
</code></pre>
<a class="header" href="print.html#interop-with-the-classic-programming-model" id="interop-with-the-classic-programming-model"><h3>Interop with the Classic Programming Model</h3></a>
<p>Tracked properties represent a paradigm shift. They are a completely new system,
fully independent of the classic programming model and based on modern
Javascript features and design, and they will be the <em>default</em> change tracking
system in Ember Octane.</p>
<p>However, existing apps, libraries, and addons will be using the classic
programming model for some time, and experience tells us that these sort of
transitions to new features take a while to settle in the community. To ease
this process and enable gradual adoption, tracked properties will be able to
interoperate with the most commonly used features of the classic model:</p>
<ul>
<li>Classic classes</li>
<li>Computed properties</li>
<li><code>get</code>/<code>set</code> and property notifications</li>
<li>Observers</li>
</ul>
<a class="header" href="print.html#classic-classes" id="classic-classes"><h4>Classic Classes</h4></a>
<p>The <code>tracked</code> decorator function will be usable in classic classes, similar to
<code>computed</code>:</p>
<pre><code class="language-js">import EmberObject from '@ember/object';
import { tracked } from '@glimmer/tracking';

const Person = EmberObject.extend({
  firstName: tracked({ value: 'Tom' }),
  lastName: tracked({ value: 'Dale' }),

  fullName: tracked({
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
  }),
});
</code></pre>
<p>This form will <em>not</em> be allowed on native classes, and will hard error if it is
attempted. Additionally, default values will be defined on the <em>prototype</em> to
maintain consistency with the classic object model.</p>
<p>This will allow existing libraries to transition incrementally, and add tracked
support minimally where necessary. This also brings the <em>benefits</em> of tracked
to classic classes, including the ability to drop usage of <code>set</code>:</p>
<pre><code class="language-js">// before
let person = Person.create();
person.set('firstName', 'Stefan');
person.set('lastName', 'Penner');

// after
let person = Person.create();
person.firstName = 'Stefan';
person.lastName = 'Penner';
</code></pre>
<p>Ember's <code>set</code> function is nowhere to be seen!</p>
<a class="header" href="print.html#computed-properties-1" id="computed-properties-1"><h4>Computed Properties</h4></a>
<p>Computed properties will interoperate with tracked properties in both
directions:</p>
<ul>
<li>
<p>Accessing a computed property from a tracked property will add the computed
property to its list of depedencies. Whenever the computed property is
invalidated (i.e. because it or one of its dependencies is updated), the
tracked property will be invalidated as well.</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { set } from '@ember/object';
import { alias } from '@ember/object/computed';

class Person {
  @tracked firstName;
  @tracked lastName;

  @alias('title') prefix;

  get fullName() {
    return `${this.prefix} ${this.firstName} ${this.lastName}`;
  }
}

let person = new Person();

person.firstName = 'Tom';
person.lastName = 'Dale';

set(person, 'title', 'Mr.');

person.fullName; // 'Mr. Tom Dale'
</code></pre>
</li>
<li>
<p>Accessing a tracked property from a computed property will <em>also</em>
automatically add the tracked property to the list of its dependencies. In
this way, users will be able to gradually add tracked properties and
simultaneously reap the benefits of not having to use <code>set</code> with computeds,
and not having to specify dependent keys.</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  firstName;
  lastName;

  @tracked middleName;

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }
}

let person = new Person();

set(person, 'firstName', 'Tom');
set(person, 'lastName', 'Dale');

person.middleName = 'Tomster';

person.fullName; // 'Tom Tomster Dale'
</code></pre>
</li>
</ul>
<p>It will still be required to use <code>set</code> when updating computed properties and
their dependencies. In the future, this restriction could possibly be relaxed.</p>
<a class="header" href="print.html#get-and-set" id="get-and-set"><h4><code>get</code> and <code>set</code></h4></a>
<p>It is common in the classic model to set and consume plain object properties
which are not computed properties, or in any other way special. Ember's <code>get</code>
and <code>set</code> functions historically allowed this by giving us the ability to
intercept all property changes and watch for mutations.</p>
<p>This presents a problem for tracked properties, particularly because of the
recent change in Ember to enable native Javascript getters to replace <code>get</code>.
This change means that we have no way to intercept <code>get</code>, and consequently no
way for tracked properties to know whether or not a plain property will later
be updated with <code>set</code>.</p>
<p>To demonstrate this case, consider the following service and component:</p>
<pre><code class="language-js">const Config = Service.extend({
  polling: {
    shouldPoll: false,
    pollInterval: -1,
  },

  init() {
    this._super(...arguments);

    fetch('config/api/url')
      .then(r =&gt; r.json())
      .then(polling =&gt; set(this, 'polling', polling));
  },
});
</code></pre>
<pre><code class="language-js">class SomeComponent extends Component {
  @service config;

  get pollInterval() {
    let { shouldPoll, pollInterval } = this.config.polling;

    return shouldPoll ? pollInterval : -1;
  }
}
</code></pre>
<pre><code class="language-hbs">{{this.pollInterval}}
</code></pre>
<p>Let's walk through the flow here:</p>
<ol>
<li>The <code>SomeComponent</code> component is rendered for the first time, instantiating
the <code>Config</code> service (assuming this the first time it has ever been
accessed). The service's init hook kicks off an async request to get the
configuration from a remote URl.</li>
<li>The <code>pollInterval</code> property first accesses the service injection when
rendered, which is a computed property. The property is detected and added to
the tracked stack.</li>
<li>We then access the plain, undecorated <code>polling</code> object. Because it is
is not tracked and not a computed property, tracked does not know that it
could update in the future.</li>
<li>Sometime later, the async request returns with the configuration object. We
set it on the service, but because our tracked getter did not know this
property would update, it does not invalidate.</li>
</ol>
<p>In order to prevent this from happening, user's will have to use <code>get</code> when
accessing any values which may be set with <code>set</code>, and are not computed
properties.</p>
<pre><code class="language-js">class SomeComponent extends Component {
  @service config;

  get pollInterval() {
    let shouldPoll = get(this, 'config.polling.shouldPoll');
    let pollInterval = get(this, 'config.polling.pollInterval');

    return shouldPoll ? pollInterval : -1;
  }
}
</code></pre>
<p>The reverse, however, is not true - computed properties will be able to add
tracked properties, and listen to dependencies explicitly. In some cases, this
may be preferable, though undecorated getters should be the conventional
standard with the long term goal of removing all explicit dependencies and
computed decorations.</p>
<a class="header" href="print.html#observers" id="observers"><h4>Observers</h4></a>
<p>While Ember's observer system has been minimized in recent years, it is still
supported in Ember 3 and used occasionally throughout the ecosystem. Observers
use a fundamentally different system for tracking changes than tracked
properties, but this does not mean that it is impossible for the two systems to
interoperate, and it theory it shouldn't require much effort to maintain such
interoperation or regress performance in any meaningful way.</p>
<p>As such, tracked properties will be made to interoperate with observers so that
whenever a tracked property is set using <em>any</em> valid syntax, observers watching
that key will be fired:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { addObserver } from '@ember/object/observers';

class Person {
  constructor() {
    addObserver('firstName', () =&gt; {
      console.log('firstName changed!');
    });
  }

  @tracked firstName;
}
</code></pre>
<p>If in the implementation of this RFC it becomes apparent that there <em>are</em> major
caveats to supporting interop with observers, a followup RFC will be made to
address those caveats and make a decision on whether or not to support observers
with those additional constraints.</p>
<a class="header" href="print.html#does-this-mean-i-still-have-to-use-get-and-set" id="does-this-mean-i-still-have-to-use-get-and-set"><h3>Does this mean I still have to use <code>get</code> and <code>set</code>?</h3></a>
<p>Yes. As mentioned above, interoperating with legacy code will require using
<code>get</code> and <code>set</code> to be fully safe. However, even in greenfield applications which
do not need to interoperate with legacy addons or code, there will still be use
cases which are <em>not</em> covered by tracked properties. These use cases are roughly
the same as those that come with native <a href="https://github.com/emberjs/rfcs/blob/master/text/0281-es5-getters.md#motivation">ES Getters</a>:</p>
<ol>
<li>Objects that implement <code>unknownProperty</code> and <code>setUnknownProperty</code></li>
<li><a href="https://emberjs.com/api/ember/release/classes/ObjectProxy">Ember proxies</a>,
which use <code>unknownProperty</code> and <code>setUnknownProperty</code></li>
<li>In general, cases where change tracking should be <em>dynamic</em>, where the keys
that are being tracked are <em>not</em> known in advance and cannot be declared
using decorators.</li>
</ol>
<p><code>get</code> and <code>set</code> will continue to work (as defined in this RFC) and will be
necessary in many applications for the forseeable future. How long exactly is
an <a href="print.html#unresolved-questions">open question addressed below in the unresolved questions section</a>.</p>
<a class="header" href="print.html#how-we-teach-this-68" id="how-we-teach-this-68"><h2>How we teach this</h2></a>
<p>There are three different aspects of tracked properties which need to be
considered for the learning story:</p>
<ol>
<li><strong>General usage.</strong> Which properties should I mark as tracked? How do I
consume them? How do I trigger changes?</li>
<li><strong>Interop with classic systems.</strong> How do I safely consume tracked properties
from classic classes and computeds? How do I safely consume classic APIs from
tracked properties?</li>
<li><strong>Interop with non-Ember systems.</strong> How do I tell my app that something has
changed in MobX objects, RxJS objects, Redux, etc.</li>
</ol>
<a class="header" href="print.html#general-usage" id="general-usage"><h3>General Usage</h3></a>
<p>The mental model with tracked properties is that anything <em>mutable</em> that is
public should be tracked. If a value will ever change, and it will or could be
watched externally, it should have the <code>@tracked</code> decorator attached to it.</p>
<p>After that, usage should be &quot;Just Javascript&quot;. You can safely access values
using any syntax you like, including desctructuring, and you can update values
using standard assignments.</p>
<pre><code class="language-js">// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];

// Simple assignment
this.firstName = 'Yehuda';
// Addition assignment (+=)
this.lastName += 'Katz';
// Increment operator
this.age++;
</code></pre>
<a class="header" href="print.html#triggering-updates-on-complex-objects" id="triggering-updates-on-complex-objects"><h4>Triggering Updates on Complex Objects</h4></a>
<p>There may be cases where users want to update values in complex, untracked
objects such as arrays or POJOs. <code>@tracked</code> will only be usable with class
syntax at first, and while it may make sense to formalize these objects into
tracked classes in some cases, this will not always be the case.</p>
<p>To do this, users can re-set a tracked value directly after its inner values
have been updated.</p>
<pre><code class="language-js">class SomeComponent extends Component {
  @tracked items = [];

  @action
  pushItem(item) {
    let { items } = this;

    items.push(item);

    this.items = items;
  }
}
</code></pre>
<p>This may seem a bit strange at first, but it allows users to mentally scope
off a tree of objects. They manipulate internals as they see fit, and the only
operation they need to do to update state is set the nearest tracked property.</p>
<a class="header" href="print.html#interop-with-classic-systems" id="interop-with-classic-systems"><h3>Interop with Classic Systems</h3></a>
<p>There are two cases that we need to consider when teaching interoperability:</p>
<ol>
<li>Accessing non-tracked properties and computeds from an autotrack context</li>
<li>Accessing tracked properties from a computed context</li>
</ol>
<p>In the first case, the general rule of thumb is to use <code>get</code> if you want to be
100% safe. In cases where you are certain that the values you are accessing are
tracked, computeds, or immutable, you can safely use standard access syntax.</p>
<p>In the second case, no additional changes need to be made when using tracked
properties. They can be accessed as normal, and will be automatically added to
the computed's dependencies. There is no need to use <code>get</code>, and you can use
standard assignments when updating them.</p>
<a class="header" href="print.html#interop-with-non-ember-systems" id="interop-with-non-ember-systems"><h3>Interop with Non-Ember Systems</h3></a>
<p>The strategy for trickier updates on complex objects by retriggering their
setters should cover most integration use cases. We should add a guide which
specifically demonstrates their usage by wrapping a common, simple external
library such as <code>moment.js</code>. This will demonstrate its usage concretely, and
establish best practices.</p>
<a class="header" href="print.html#drawbacks-92" id="drawbacks-92"><h2>Drawbacks</h2></a>
<p>Like any technical design, tracked properties must make tradeoffs to balance
performance, simplicity, and usability. Tracked properties make a different set
of tradeoffs than today's computed properties.</p>
<p>This means tracked properties come with edge cases or &quot;gotchas&quot; that don't exist
in computed properties. When evaluating the following drawbacks, please consider
the two features in their totality, including computed property gotchas you have
learned to work around.</p>
<p>In particular, please try to compensate for <a href="https://en.wikipedia.org/wiki/Familiarity_heuristic">familiarity</a> and
<a href="https://en.wikipedia.org/wiki/Loss_aversion">loss aversion</a> biases. Before you form a strong opinion, <a href="https://signalvnoise.com/posts/3124-give-it-five-minutes">give
it five minutes</a>.</p>
<a class="header" href="print.html#tracked-properties--promises" id="tracked-properties--promises"><h3>Tracked Properties &amp; Promises</h3></a>
<p>Dependency autotracking requires that tracked getters access their dependencies
synchronously. Any access that happens asynchronously will not be detected as a
dependency.</p>
<p>This is most commonly encountered when trying to return a <code>Promise</code> from a
tracked getter. Here's an example that would &quot;work&quot; but would never update if
<code>firstName</code> or <code>lastName</code> change:</p>
<pre><code class="language-js">class Person {
  @tracked firstName;
  @tracked lastName;

  get fullNameAsync() {
    return this.reloadUser().then(() =&gt; {
      return `${this.firstName} ${this.lastName}`;
    });
  }

  async reloadUser() {
    const response = await fetch('https://example.com/user.json');
    const { firstName, lastName } = await response.json();
    this.firstName = firstName;
    this.lastName = lastName;
  }

  setFirstName(firstName) {
    // This should cause `fullNameAsync` to update, but doesn't, because
    // firstName was not detected as a dependency.
    this.firstName = firstName;
  }
}
</code></pre>
<p>One way you could address this is to ensure that any dependencies are consumed
synchronously:</p>
<pre><code class="language-js">get fullNameAsync() {
  // Consume firstName and lastName so they are detected as dependencies.
  let { firstName, lastName } = this;

  return this.reloadUser().then(() =&gt; {
    // Fetch firstName and lastName again now that they may have been updated
    let { firstName, lastName } = this;
    return `${firstName} ${lastName}`;
  });
}
</code></pre>
<p>However, <strong>modeling async behavior as tracked properties is an incoherent
approach and should be discouraged</strong>. Tracked properties are intended to hold
simple state, or to derive state from data that is available synchronously.</p>
<p>But asynchrony is a fact of life in web applications, so how should we deal with
async data fetching?</p>
<p><strong>In keeping with Data Down, Actions Up, async behavior should be modeled as
methods that set tracked properties once the behavior is complete.</strong></p>
<p>Async behavior should be explicit, not a side-effect of property access. Today's
computed properties that rely on caching to only perform async behavior when a
dependency changes are effectively reintroducing observers into the programming
model via a side channel.</p>
<p>A better approach is to call a method to perform the async data fetching, then
set one or more tracked properties once the data has loaded. We can refactor the
above example back to a synchronous <code>fullName</code> tracked property:</p>
<pre><code class="language-js">class Person {
  @tracked firstName;
  @tracked lastName;

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  async reloadUser() {
    const response = await fetch('https://example.com/user.json');
    const { firstName, lastName } = await response.json();
    this.firstName = firstName;
    this.lastName = lastName;
  }
}
</code></pre>
<p>Now, <code>reloadUser()</code> must be called explicitly, rather than being run implicitly
as a side-effect of consuming <code>fullName</code>.</p>
<a class="header" href="print.html#accidental-untracked-properties" id="accidental-untracked-properties"><h3>Accidental Untracked Properties</h3></a>
<p>One of the design principles of tracked properties is that they are only
required for state that <em>changes over time</em>. Because tracked properties imply
some overhead over an untracked property (however small), we only want to pay
that cost for properties that actually change.</p>
<p>However, an obvious failure mode is that some property <em>does</em> change over time,
but the user simply forgets to annotate that property as <code>@tracked</code>. This will
cause frustrating-to-diagnose bugs where the DOM doesn't update in response to
property changes.</p>
<p>Fortunately, we have a strategy for mitigating some of this frustration. It
involves the way most tracked properties will be consumed: via a component
template. In development mode, we can detect when an untracked property is used
in a template and install a setter that causes an exception to be thrown if it
is ever mutated. (This is similar to today's &quot;mandatory setter&quot; that causes an
exception to be thrown if a watched property is set without going through
<code>set()</code>.)</p>
<p>Unfortunately this strategy cannot be applied to values accessed by tracked
getters. The only way we could detect such access would be with native
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a>, but proxies are more focussed on security over flexibility
and recent discussion shows that <a href="https://github.com/tc39/proposal-class-fields/issues/106">they may break entirely when used with
private fields</a>. As
such, it would not be ideal for us to use them in this way.</p>
<a class="header" href="print.html#alternatives-94" id="alternatives-94"><h2>Alternatives</h2></a>
<a class="header" href="print.html#ship-tracked-properties-in-user-land" id="ship-tracked-properties-in-user-land"><h3>Ship tracked properties in user-land</h3></a>
<p>Instead of shipping <code>@tracked</code> today, we can focus on formalizing the primitives
which it uses under the hood in Glimmer VM (References and Validators) and make
these publicly consumable. This way, users will be able to implement tracked in
an addon and experiment with it before it becomes a core part of Ember.</p>
<p>This approach is similar to the approach taken with component managers in the
past year, which unblocked experimentation with <code>SparklesComponent</code>s as a way to
validate the design of <code>GlimmerComponent</code>s, and unlocked the ability for power
users to create their own component APIs. However, the reference and validator
system is a much more core part of the Glimmer VM, and it could take much longer
to figure out the best and safest way to do this without exposing too much of
the internals. It would certainly prevent <code>@tracked</code> from shipping with Ember
Octane.</p>
<a class="header" href="print.html#keep-the-current-system" id="keep-the-current-system"><h3>Keep the current system</h3></a>
<p>We could keep the current computed property based system, and refactor it
internally to use references only and not rely on chains or the old property
notification system. This would be difficult, since CPs are very intertwined
with property events as are their dependencies. It would also mean we wouldn't
get the DX benefits of cleaner syntax, and the performance benefits of opt-in
change tracking and caching.</p>
<a class="header" href="print.html#we-could-keep-set" id="we-could-keep-set"><h3>We could keep <code>set</code></h3></a>
<p>Tracked properties were designed around wanting to use native setters to update
state. If we remove that constraint and keep <code>set</code>, it opens up some
possibilities. There is precedent for this in other frameworks, such as React's
<code>setState</code>.</p>
<p>However, keeping <code>set</code> likely wouldn't be able to restrict the requirement for
<code>@tracked</code> being applied to all mutable properties for the same reason <code>get</code>
must be used in interop - there's no way for a tracked property to know that a
plain, undecorated property could update in the future.</p>
<a class="header" href="print.html#allow-explicit-dependencies" id="allow-explicit-dependencies"><h3>Allow explicit dependencies</h3></a>
<p>We could allow <code>@tracked</code> to receive explicit dependencies instead of forcing
<code>get</code> usage for interop. This would be very complex, if even possible, and is
ultimately not functionality <code>@tracked</code> should have in the long run, so it would
not make sense to add it now.</p>
<a class="header" href="print.html#we-could-wait-on-private-fields-and-proxy-developments" id="we-could-wait-on-private-fields-and-proxy-developments"><h3>We could wait on private fields and Proxy developments</h3></a>
<p>Native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a> represent a lot of possibilities for automatic change
tracking. Other frameworks such as Vue and Aurelia are looking into using
recursive proxy structures to wrap objects and intercept access, which would
allow them to track changes without <em>any</em> decoration. We also considered using
recursive proxies in earlier drafts of this proposal, even though they aren't
part of our support matrix we believed they could be used during development to
assert when users attempted to update untracked properties which had been
consumed from tracked getters.</p>
<p>However, as mention above, TC39 has made it clear that this was <a href="https://github.com/tc39/proposal-class-fields/issues/106">not an intended
use for Proxy</a>, and
they will be <em>breaking</em> this functionality with the inclusion of private fields.
They have also expressed that <a href="https://github.com/tc39/proposal-class-fields/issues/162#issuecomment-441101578">they would like to solve this
use-case</a>
(observing object state changes in general) separately, and <a href="https://github.com/littledan/proposal-proxy-transparent">a strawman proposal
was made</a> (though it
has not advanced and does not seem like it will). We could wait to see what the
future looks like here, and see if we can provide a more ergonomic tracked
properties RFC in the future.</p>
<a class="header" href="print.html#unresolved-questions-65" id="unresolved-questions-65"><h2>Unresolved questions</h2></a>
<a class="header" href="print.html#when-can-i-stop-using-get-and-set" id="when-can-i-stop-using-get-and-set"><h3>When can I stop using <code>get</code> and <code>set</code>?</h3></a>
<p>This is the biggest open question in this RFC, and with the direction that
tracked properties set. How do we get rid of <code>get</code> and <code>set</code> for good, if that
is the direction we want to go in?</p>
<p>The full answer to that question is out of scope for tracked properties, but it
would likely require at least two additional steps:</p>
<ol>
<li>
<p>The underlying system for tracking changes, including the ability to create
tags for fields and the ability to add to the current autotracking stack,
will need to be made public for advanced users who need dynamic change
tracking.</p>
</li>
<li>
<p>First class support for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">native proxies</a> within Ember.
<code>unknownProperty</code> and <code>setUnknownProperty</code> have no other analag in native
Javascript, and without support for native proxies there will likely be use
cases that cannot be supported in any other way.</p>
<p>As mentioned above, native proxies <em>will</em> (potentially) have more limitations
than Ember proxies, but these limitations will most likely be possible to
work around for advanced users who need this functionality in the first
place. In other words, while they probably don't make sense as a basis for
<em>all</em> change tracking in Ember, they will probably be invaluable for specific
use cases such as <a href="https://www.npmjs.com/package/ember-m3">Ember M3</a> which
require very dynamic change tracking.</p>
</li>
</ol>
<ul>
<li>Start Date: 2018-12-13</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/415</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#render-element-modifiers" id="render-element-modifiers"><h1>Render Element Modifiers</h1></a>
<a class="header" href="print.html#summary-97" id="summary-97"><h2>Summary</h2></a>
<p>Element modifiers are a recently introduced concept in Ember that allow users to
run code that is tied to the lifecycle of an <em>element</em> in a template, rather
than the component's lifecycle. They allow users to write self-contained logic
for manipulating the state of elements, and in many cases can be fully
independent of component code and state.</p>
<p>However, there are many cases where users wish to run some component code when
an element is setting up or tearing down. Today, this logic conventionally lives
in the <code>didInsertElement</code>, <code>didRender</code>, <code>didUpdate</code>, and  <code>willDestroyElement</code>
hooks in components, but there are cases where these hooks are not ideal.</p>
<p>This RFC proposes creating an official Ember addon which provides three new
generic element modifiers: <code>{{did-insert}}</code>, <code>{{did-update}}</code>, and
<code>{{will-destroy}}</code>. Users will be able to use these to run code during the most
common phases of any element's lifecycle.</p>
<a class="header" href="print.html#motivation-98" id="motivation-98"><h2>Motivation</h2></a>
<p>The primary component hooks for interacting with the DOM today are:</p>
<ul>
<li><code>didInsertElement</code></li>
<li><code>didRender</code></li>
<li><code>didUpdate</code></li>
<li><code>willDestroyElement</code></li>
</ul>
<p>These render hooks cover many use cases. However, there are some cases which
they do not cover, such as setting up logic for conditional elements, or tagless
components. There also is no easy way to share element setup logic, aside from
mixins or pure functions (which require some amount of boilerplate).</p>
<a class="header" href="print.html#conditionals" id="conditionals"><h3>Conditionals</h3></a>
<p>Render code for elements which exist conditionally is fairly tricky. Consider a
simple popover component:</p>
<pre><code class="language-hbs">{{#if this.isOpen}}
  &lt;div class=&quot;popover&quot;&gt;
    {{yield}}
  &lt;/div&gt;
{{/if}}
</code></pre>
<p>If the developer decides to use an external library like <a href="https://popper.js.org">Popper.js</a>
to position the popover, they have to add a fair amount of boilerplate. On each
render, they need to check if the popover was added to the DOM or removed from
it, and setup or teardown accordingly.</p>
<pre><code class="language-js">export default Component.extend({
  didRender() {
    if (this.isOpen &amp;&amp; !this._popper) {
      let popoverElement = this.element.querySelector('.popover');

      this._popper = new Popper(document, popoverElement);
    } else if (this._popper) {
      this._popper.destroy();
    }
  },

  willDestroyElement() {
    if (this._popper) {
      this._popper.destroy();
    }
  }
});
</code></pre>
<p>At this level of complexity, most developers would reasonably choose to create
a second component to be used within the <code>{{if}}</code> block so they can use standard
lifecycle hooks. Sometimes this makes sense as it helps to separate concerns and
organize code, but other times it is clearly working around the limitations of
render hooks, and can feel like more components are being created than are
necessary.</p>
<p>With render modifiers, hooks are run whenever the <em>element</em> they are applied to
is setup and torn down, which means we can focus on the setup and teardown code
without worrying about the overall lifecycle:</p>
<pre><code class="language-hbs">{{#if this.isOpen}}
  &lt;div
    {{did-insert (action this.setupPopper)}}
    {{will-destroy (action this.teardownPopper)}}

    class=&quot;popover&quot;
  &gt;
    {{yield}}
  &lt;/div&gt;
{{/if}}
</code></pre>
<pre><code class="language-js">export default Component.extend({
  setupPopper(element) {
    this._popper = new Popper(document, element);
  },

  teardownPopper() {
    this._popper.destroy();
  }
});
</code></pre>
<p>The element that the modifiers are applied to is also passed to the function, so
there is no longer a need to use <code>querySelector</code>. Overall the end result is a
fair amount simpler, without the need for an additional component.</p>
<p>These same issues are also present for collections items within an <code>{{each}}</code>
loop, and the render modifiers can be used to solve them as well:</p>
<pre><code class="language-hbs">&lt;ul&gt;
  {{#each items as |item|}}
    &lt;li
      {{did-insert (action this.registerElement)}}
      {{will-destroy (action this.unregisterElement)}}
    &gt;
      ...
    &lt;/li&gt;
  {{/each}}
&lt;/ul&gt;
</code></pre>
<a class="header" href="print.html#tagless-components" id="tagless-components"><h3>Tagless Components</h3></a>
<p>Additionally, render hooks do not provide great support for tagless components
(<code>tagName: ''</code>). While the hooks fire when the component is rendered, they have
no way to target any of the elements which are in the component's template,
meaning users must use <code>querySelector</code> and setup some unique id or class to
target the element by:</p>
<pre><code class="language-js">export default Component.extend({
  tagName: '',

  listId: computed(function() {
    return generateId();
  }),

  didInsertElement() {
    let element = document.querySelector(`#${this.listId}`);

    // ...
  },

  willDestroyElement() {
    let element = document.querySelector(`#${this.listId}`);

// ...
  }
});
</code></pre>
<pre><code class="language-hbs">&lt;ul id={{listId}}&gt;
  ...
&lt;/ul&gt;

&lt;div&gt;
  ...
&lt;/div&gt;
</code></pre>
<p>The render modifiers can be used to add hooks to the appropriate main element in
tagless components:</p>
<pre><code class="language-js">export default Component.extend({
  tagName: '',

  didInsertList(element) {
    // ...
  },

  willDestroyList(element) {
    // ...
  }
});
</code></pre>
<pre><code class="language-hbs">&lt;ul
  {{did-insert (action this.didInsertList)}}
  {{will-destroy (action this.willDestroyList)}}
&gt;
  ...
&lt;/ul&gt;

&lt;div&gt;
  ...
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#reusable-helpers" id="reusable-helpers"><h3>Reusable Helpers</h3></a>
<p>Currently, the best ways to share element setup code are either via mixins,
which are somewhat opaque and can encourage problematic patterns, or standard JS
functions, which generally require some amount of boilerplate.</p>
<p>Developers will be able to define element modifiers in the future with modifier
managers provided by addons. However, the proposed modifier APIs are fairly
verbose (with good reason) and not stabilized.</p>
<p>However, the render modifiers can receive <em>any</em> function as their first
parameter, allowing users to share and reuse common element setup code with
helpers. For instance, a simple <code>scrollTo</code> helper could be created to set the
scroll position of an element:</p>
<pre><code class="language-js">// helpers/scroll-to.js
export default function scrollTo() {
  return (element, [scrollPosition]) =&gt; element.scrollTop = scrollPosition;
}
</code></pre>
<pre><code class="language-hbs">&lt;div
  {{did-insert (scroll-to) @scrollPosition}}
  {{did-update (scroll-to) @scrollPosition}}
  class=&quot;scroll-container&quot;
&gt;
  ...
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#official-addon" id="official-addon"><h3>Official Addon</h3></a>
<p>While these modifiers will be generally useful, modifiers are meant to be a more
generic API that can be used to create libraries for solving specific problems.
Unfortunately, the community hasn't had much time to experiment with modifiers,
since the public API for them hasn't been finalized.</p>
<p>The modifiers in this RFC will provide an basic stepping stone for users who
want to emulate lifecycle hooks and incrementally convert their applications to
modifiers while modifiers in general are being experimented with in the
community. In time, users should be able to pick and choose the modifiers that
suit their needs more directly and effectively, and they shouldn't have to
include these modifiers in the payload. These modifiers should also not be seen
as the &quot;Ember way&quot; - they are just another addon, a basic one supported by
the Ember core team, but one which may or may not be appropriate for a given
application.</p>
<a class="header" href="print.html#detailed-design-83" id="detailed-design-83"><h2>Detailed design</h2></a>
<p>This RFC proposes adding three element modifiers:</p>
<ul>
<li><code>{{did-insert}}</code></li>
<li><code>{{did-update}}</code></li>
<li><code>{{will-destroy}}</code></li>
</ul>
<p>Note that element modifiers do <em>not</em> run in SSR mode - this code is only run on
clients. Each of these modifiers receives a callback as it's first positional
parameter:</p>
<pre><code class="language-ts">type RenderModifierCallback = (element: Element, positionalArgs: [any], namedArgs: object): void;
</code></pre>
<p>The <code>element</code> argument is the element that the modifier is applied to,
<code>positionalArgs</code> contains any remaining positional arguments passed to the
modifier besides the callback, and <code>namedArgs</code> contains any named arguments
passed to the modifier. If the first positional argument is not a callable
function, the modifier will throw an error.</p>
<blockquote>
<p>Note: The timing semantics in the following section were mostly defined in the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md">element modifier manager RFC</a>
and are repeated here for clarity and convenience.</p>
</blockquote>
<a class="header" href="print.html#did-insert" id="did-insert"><h3><code>{{did-insert}}</code></h3></a>
<p>This modifier is activated only when The element is inserted in the DOM.</p>
<p>It has the following timing semantics when activated:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called after DOM insertion</li>
<li>called <em>after</em> any child element's <code>{{did-insert}}</code> modifiers</li>
<li>called <em>after</em> the enclosing component's <code>willRender</code> hook</li>
<li>called <em>before</em> the enclosing component's <code>didRender</code> hook</li>
<li>called in definition order in the template</li>
</ul>
</li>
<li><strong>May or May Not</strong>
<ul>
<li>be called in the same tick as DOM insertion</li>
<li>have the sibling nodes fully initialized in DOM</li>
</ul>
</li>
</ul>
<p>Note that these statements do not refer to when the modifier is <em>activated</em>,
only to when it will be run relative to other hooks and modifiers <em>should it be
activated</em>. The modifier is only activated on insertion.</p>
<a class="header" href="print.html#did-update" id="did-update"><h3><code>{{did-update}}</code></h3></a>
<p>This modifier is activated only on <em>updates</em> to it's arguments (both positional
and named). It does <em>not</em> run during or after initial render, or before
element destruction.</p>
<p>It has the following timing semantics when activated:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called after the arguments to the modifier have changed</li>
<li>called <em>after</em> any child element's <code>{{did-update}}</code> modifiers</li>
<li>called <em>after</em> the enclosing component's <code>willUpdate</code> hook</li>
<li>called <em>before</em> the enclosing component's <code>didUpdate</code> hook</li>
<li>called in definition order in the template</li>
</ul>
</li>
<li><strong>Never</strong>
<ul>
<li>called if the arguments to the modifier are constants</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#will-destroy" id="will-destroy"><h3><code>{{will-destroy}}</code></h3></a>
<p>This modifier is activated:</p>
<ol>
<li>immediately before the element is removed from the DOM.</li>
</ol>
<p>It has the following timing semantics when activated:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called <em>after</em> any child element's <code>{{will-destroy}}</code> modifiers</li>
<li>called <em>before</em> the enclosing component's <code>willDestroy</code> hook</li>
<li>called in definition order in the template</li>
</ul>
</li>
<li><strong>May or May Not</strong>
<ul>
<li>be called in the same tick as DOM removal</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#function-binding" id="function-binding"><h3>Function Binding</h3></a>
<p>Functions which are passed to these element modifiers will <em>not</em> be bound to any
context by default. Users can bind them using the <code>(action)</code> helper:</p>
<pre><code class="language-hbs">&lt;div {{did-insert (action this.setupElement)}}&gt;&lt;/div&gt;
</code></pre>
<p>Or by using the <code>@action</code> decorator provided by the
<a href="https://github.com/emberjs/rfcs/pull/408">Decorators RFC</a> to bind the function
in the class itself:</p>
<pre><code class="language-js">export default class ExampleComponent extends Component {
  @action
  setupElement() {
    // ...
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;div {{did-insert this.setupElement}}&gt;&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#how-we-teach-this-69" id="how-we-teach-this-69"><h2>How we teach this</h2></a>
<p>Element modifiers will be new to everyone, so we're starting with a mostly blank
slate. The only modifier that exists in classic Ember is <code>{{action}}</code>, and while
most existing users will be familiar with it, that familiarity may not translate
to the more general idea of modifiers.</p>
<p>The first thing we should focus on is teaching <em>modifiers in general</em>. Modifiers
should be seen as the place for any logic which needs to act directly on an
element, or when an element is added to or removed from the DOM. Modifiers can
be fully independent (for instance, a <code>scroll-to</code> modifier that transparently
manages the scroll position of the element) or they can interact with the
component (like the <code>did-insert</code> and <code>will-destroy</code> modifiers). In all cases
though, they are <em>tied to the render lifecycle of the element</em>, and they
generally contain <em>side-effects</em> (though these may be transparent and
declarative, as in the case of <code>{{action}}</code> or the theoretical <code>{{scroll-to}}</code>).</p>
<p>Second, we should teach the render modifiers specifically. We can do this by
illustrating common use cases which can currently be solved with render hooks,
and comparing them to using modifiers for the same solution. We should also
emphasize that these are an addon, not part of the core framework, and are
useful as solutions for <em>specific</em> problems. As more modifiers become available,
we should create additional guides that focus on using the <em>best</em> modifier for
the job, rather than these generic ones.</p>
<p>One thing we should definitely avoid teaching except in advanced cases is the
<em>ordering</em> of element modifiers. Ideally, element modifiers should be
commutative, and order should not be something users have to think about. When
custom element modifiers become widely available, this should be considered best
practice.</p>
<a class="header" href="print.html#example-scrolling-an-element-to-a-position" id="example-scrolling-an-element-to-a-position"><h3>Example: Scrolling an element to a position</h3></a>
<p>This sets the scroll position of an element, and updates it whenever the scroll
position changes.</p>
<p>Before:</p>
<pre><code class="language-hbs">{{yield}}
</code></pre>
<pre><code class="language-js">export default Component.extend({
  classNames: ['scroll-container'],

  didRender() {
    this.element.scrollTop = this.scrollPosition;
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">&lt;div
  {{did-insert this.setScrollPosition @scrollPosition}}
  {{did-update this.setScrollPosition @scrollPosition}}

  class=&quot;scroll-container&quot;
&gt;
  {{yield}}
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">export default class Component.extend({
  setScrollPosition(element, scrollPosition) {
    element.scrollTop = scrollPosition;
  }
})
</code></pre>
<a class="header" href="print.html#example-adding-a-class-to-an-element-after-render-for-css-animations" id="example-adding-a-class-to-an-element-after-render-for-css-animations"><h4>Example: Adding a class to an element after render for CSS animations</h4></a>
<p>This adds a CSS class to an alert element in a conditional whenever it renders
to fade it in, which is a bit of an extra hoop. For CSS transitions to work, we
need to append the element <em>without</em> the class, then add the class after it has
been appended.</p>
<p>Before:</p>
<pre><code class="language-hbs">{{#if shouldShow}}
  &lt;div class=&quot;alert&quot;&gt;
    {{yield}}
  &lt;/div&gt;
{{/if}}
</code></pre>
<pre><code class="language-js">export default Component.extend({
  didRender() {
    let alert = this.element.querySelector('.alert');

    if (alert) {
      alert.classList.add('fade-in');
    }
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{#if shouldShow}}
  &lt;div {{did-insert this.fadeIn}} class=&quot;alert&quot;&gt;
    {{yield}}
  &lt;/div&gt;
{{/if}}
</code></pre>
<pre><code class="language-js">export default Component.extend({
  fadeIn(element) {
    element.classList.add('fade-in');
  }
});
</code></pre>
<a class="header" href="print.html#example-resizing-text-area" id="example-resizing-text-area"><h4>Example: Resizing text area</h4></a>
<p>One key thing to know about <code>{{did-update}}</code> is it will not rerun whenever the
<em>contents</em> or <em>attributes</em> on the element change. For instance, <code>{{did-update}}</code>
will <em>not</em> rerun when <code>@type</code> changes here:</p>
<pre><code class="language-hbs">&lt;div {{did-update this.setupType}} class=&quot;{{@type}}&quot;&gt;&lt;/div&gt;
</code></pre>
<p>If <code>{{did-update}}</code> should rerun whenever a value changes, the value should be
passed as a parameter to the modifier. For instance, a textarea which wants to
resize itself to fit text whenever the text is modified could be setup like
this:</p>
<pre><code class="language-hbs">&lt;textarea {{did-update this.resizeArea @text}}&gt;
  {{@text}}
&lt;/textarea&gt;
</code></pre>
<pre><code class="language-js">export default Component.extend({
  resizeArea(element) {
    element.css.height = `${element.scrollHeight}px`;
  }
});
</code></pre>
<a class="header" href="print.html#example-ember-composability-tools-style-rendering" id="example-ember-composability-tools-style-rendering"><h4>Example: <code>ember-composability-tools</code> style rendering</h4></a>
<p>This is the type of rendering done by libraries like <code>ember-leaflet</code>, which use
components to control the <em>rendering</em> of the library, but without any templates
themselves. The underlying library for this is <a href="https://github.com/miguelcobain/ember-composability-tools">here</a>.
This is a simplified example of how you could accomplish this with Glimmer
components and element modifiers.</p>
<p>Node component:</p>
<pre><code class="language-js">// components/node.js
export default Component.extend({
  init() {
    super(...arguments);
    this.children = new Set();

    this.parent.registerChild(this);
  }

  willDestroy() {
    super(...arguments);

    this.parent.unregisterChild(this);
  }

  registerChild(child) {
    this.children.add(child);
  }

  unregisterChild(child) {
    this.children.delete(child);
  }

  didInsertNode(element) {
    // library setup code goes here

    this.children.forEach(c =&gt; c.didInsertNode(element));
  }

  willDestroyNode(element) {
    // library teardown code goes here

    this.children.forEach(c =&gt; c.willDestroyNode(element));
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;!-- components/node.hbs --&gt;
{{yield (component &quot;node&quot; parent=this)}}
</code></pre>
<p>Root component:</p>
<pre><code class="language-js">// components/root.js
import NodeComponent from './node.js';

export default NodeComponent.extend();
</code></pre>
<pre><code class="language-hbs">&lt;!-- components/root.hbs --&gt;
&lt;div
  {{did-insert (action this.didInsertNode)}}
  {{will-destroy (action this.willDestroyNode)}}
&gt;
  {{yield (component &quot;node&quot; parent=this)}}
&lt;/div&gt;
</code></pre>
<p>Usage:</p>
<pre><code class="language-hbs">&lt;Root as |node|&gt;
  &lt;node as |node|&gt;
    &lt;node /&gt;
  &lt;/node&gt;
&lt;/Root&gt;
</code></pre>
<a class="header" href="print.html#drawbacks-93" id="drawbacks-93"><h2>Drawbacks</h2></a>
<ul>
<li>
<p>Adding these modifiers means that there are more ways to accomplish similar
goals, which may be confusing to developers. It may be less clear which is the
conventional solution in a given situation.</p>
</li>
<li>
<p>Relying on users binding via <code>action</code> is somewhat unintuitive, and may feel
like it's getting in the way, especially considering sometimes methods will
work without binding (if they never access <code>this</code>).</p>
</li>
</ul>
<a class="header" href="print.html#alternatives-95" id="alternatives-95"><h2>Alternatives</h2></a>
<ul>
<li>Stick with only lifecycle hooks for these situations, and don't add generic
modifiers for them.</li>
</ul>
<ul>
<li>Start Date: 2018-12-13</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/416</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#glimmer-components" id="glimmer-components"><h1>Glimmer Components</h1></a>
<a class="header" href="print.html#summary-98" id="summary-98"><h2>Summary</h2></a>
<p>Glimmer components are a simpler, more ergonomic, and more declarative approach
to building components. They represent the sum of multiple years of design and
feature work by the community, which stemmed from the original RFCs and
discussions surrounding &quot;angle-bracket components&quot;.</p>
<p>This RFC proposes adding Glimmer components to Ember's public API, and making
them the default new app experience in Ember Octane.</p>
<a class="header" href="print.html#attribution" id="attribution"><h2>Attribution</h2></a>
<p>The Glimmer components API presented in this RFC was designed in cooperation
between @tomdale, @rwjblue, @krisselden, @pzuraq, and others.</p>
<a class="header" href="print.html#first-a-bit-of-history" id="first-a-bit-of-history"><h2>First, a Bit of History</h2></a>
<p>As components became the standard for Single Page Apps (SPAs) several years ago,
and the Ember community began adopting them in earnest and converting from Ember
1's primarily MVC oriented approach, there were many small and large issues that
cropped up with Ember's component API and usage: <code>{{curly-bracket}}</code> syntax felt
dated with the introduction of Web Components and other major frameworks; the
inability to specify or override HTML attributes led to explosions in API
complexity; the implicit wrapper element and customization fields (<code>tagName</code>,
<code>classNames</code>, et al.) felt burdensome and made templates difficult to read
compared to other frameworks; two way data-binding led to strange, hard to
predict data cycles within apps; and so on.</p>
<p>From this came the original <a href="https://github.com/emberjs/rfcs/blob/0b32059b3704836e52c906a0ead64ac186c844d8/active/0000-component-unification.md">Angle Bracket component
RFC</a>.
The idea was simple: switch to the superior <code>&lt;angle-bracket&gt;</code> syntax of web
components, and solve all the other problems! Seems easy enough, right?</p>
<p>As you can imagine, it was <em>not</em> that easy. There was a flurry of discussion on
the original RFC, and many ideas were thrown around. This was seen as the <em>one</em>
chance Ember had to &quot;fix&quot; its component API, and the community did not want to
get it wrong and lock us into yet <em>another</em> set of painful papercuts. After much
debate and lots of back and forth with the design, it was ultimately decided
that attempting to redesign components all at once, monolithically, was too
much. Instead, the individual ideas from that discussion could be broken out and
implemented in isolation, in a backwards compatible way, both incrementally
building a new, well thought out component API <em>and</em> laying the groundwork in
the framework for future redesigns.</p>
<p>A lot of the foundational work that arose from these discussions and paves the
way for Glimmer components has already landed in Ember, including: Angle-bracket
invocation, named arguments, element modifiers, and component managers.</p>
<p>Glimmer components represent the final piece of that's required to enable the
&quot;ember octane&quot; programming model. They include the last of the major features
that were discussed during the original Angle Brackets RFC, and holistically, we
feel those features make a much simpler and more ergonomic component API. Taken
alone, they are an incremental change. Their individual features aren't <em>that</em>
much more than what we currently have in Ember today. But as a whole they
represent the culmination of multiple years of design work and discussion by the
Ember community, and the collective attention to detail and care of all of our
community members.</p>
<a class="header" href="print.html#terminology-4" id="terminology-4"><h2>Terminology</h2></a>
<ul>
<li>The <strong>Glimmer VM</strong> is the underlying rendering engine which is used by
<em>Ember.js</em> and <em>Glimmer.js</em>.</li>
<li><strong>Glimmer.js</strong> is a thin wrapper on top of the <em>Glimmer VM</em> which exposes a
much simpler API compared to Ember. Historically it has been used to
experiment with ideas and implementations before bringing them into Ember via
RFC, and has been used to write applications which don't require the full
feature set of Ember.</li>
<li><strong>Glimmer components</strong> are a newly proposed component API which draw from the
experimental APIs provided in Glimmer.js, and Ember.js via
<a href="https://github.com/rwjblue/sparkles-component">sparkles-component</a>.</li>
<li><strong>Classic components</strong> refer to the standard component API at the time of this
RFC, which have been available in Ember in some form since v1.</li>
<li><strong>Tracked properties</strong> refer to a new method of change tracking which is being
proposed in a separate RFC, parallel to this one.</li>
</ul>
<a class="header" href="print.html#motivation-99" id="motivation-99"><h2>Motivation</h2></a>
<p><code>GlimmerComponent</code> is a simpler base component class that enables smaller class
definitions, stronger conventions for lifecycle hooks and properties, and
unidirectional data flow. We aim to design them to be easier understand in
isolation, and require less knowledge of the framework to use effectively.</p>
<p>This example shows a component written with the classic component API:</p>
<pre><code class="language-hbs">&lt;!-- templates/components/post.hbs --&gt;
{{#if (eq type 'image'}}
  &lt;img src={{post.imageUrl}} title={{post.imageTitle}}&gt;
{{/if}}

{{post.text}}
</code></pre>
<pre><code class="language-js">// components/post.js
export default Component.extend({
  tagName: 'section',
  classNames: ['post'],
  classNameBindings: ['type'],
  ariaRole: 'region',

  /* Arguments */
  post: null,

  type: readOnly('post.type'),

  didInsertElement() {
    this._super(...arguments);
    if (this.type === 'image') {
      setupImageOverlay(this.element.querySelector('img'));
    }
  }
});
</code></pre>
<p>And here is an equivalent component written with the Glimmer component API:</p>
<pre><code class="language-hbs">&lt;!-- templates/components/post.hbs --&gt;
&lt;section ...attributes role=&quot;region&quot; type={{@post.type}} class=&quot;post {{@post.type}}&quot;&gt;
  {{#if (eq @post.type 'image')}}
    &lt;img
      {{did-insert this.didInsertImage}}
      src={{@post.imageUrl}}
      title={{@post.imageTitle}}
    /&gt;
  {{/if}}

  {{@post.text}}
&lt;/section&gt;
</code></pre>
<pre><code class="language-js">// components/post.js
export default class PostComponent extends GlimmerComponent {
  @action
  didInsertImage(element) {
    setupImageOverlay(element);
  }
}
</code></pre>
<p>Glimmer components eliminate many of the common paper cuts that cause confusion
with classic components, and align more closely with modern template syntax and
features.</p>
<a class="header" href="print.html#outer-html-semantics" id="outer-html-semantics"><h3>Outer HTML Semantics</h3></a>
<p>The biggest change Glimmer components make is defaulting to outer HTML
semantics. In the classic component API, components had a implicit wrapper
element. Given this component template:</p>
<pre><code class="language-hbs">Hello, world!
</code></pre>
<p>The output by <em>default</em> would be something like:</p>
<pre><code class="language-html">&lt;!-- OUTPUT --&gt;
&lt;div id=&quot;ember-1234&quot; class=&quot;ember-view&quot;&gt;
  Hello, world!
&lt;/div&gt;
</code></pre>
<p>But we can't know that for sure unless we look at the component definition. If
we do, we might see that the outer wrapping element is actually a <code>section</code>, and
it has a <code>.hello-world</code> class:</p>
<pre><code class="language-js">export default Component.extend({
  tagName: 'section',
  classNames: ['hello-world']
});
</code></pre>
<pre><code class="language-html">&lt;!-- OUTPUT --&gt;
&lt;section id=&quot;ember-1234&quot; class=&quot;hello-world ember-view&quot;&gt;
  Hello, world!
&lt;/section&gt;
</code></pre>
<p>This behavior means that the template for a component is missing crucial
information and context. Even for the simplest component, users must check the
class definition to know with certainty what the full template of the component
is. And unlike bindings, there is no hint to the user that there may be
something dynamic that they should check on - without advanced knowledge of
Ember's APIs, there is no way of knowing about this behavior.</p>
<p>By contrast, Glimmer components have no wrapping outer element - What you see in
the template is what you get in the output. There is no need to define class
names, class name bindings, attribute bindings, or any other DOM element values
<em>from the component class</em>; developers can achieve the equivalent result using
the same techniques they're familiar with from working with <code>Ember.Component</code>
templates. The template is the single source of truth for the output of a
component, and any dynamic values are explicitly stated in it.</p>
<pre><code class="language-hbs">&lt;!-- template.hbs --&gt;
&lt;section class=&quot;hello-world&quot;&gt;
  Hello, world!
&lt;/section&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- OUTPUT --&gt;
&lt;section class=&quot;hello-world&quot;&gt;
  Hello, world!
&lt;/section&gt;
</code></pre>
<p>We can immediately see that this is a simple component with no bindings, no
dynamic values, and no meaningful state. Even if there was a component
definition, we know that it is not in any way affecting the output of this
template. Special element ids and classes are also not present, making the
output appear less magical.</p>
<p>This micro change makes a macro difference:</p>
<ul>
<li>
<p>Users can spend less time switching back and forth between reading template
and class code, and can get a better idea of the structure of an app from its
declarative templates.</p>
</li>
<li>
<p>Component customization code becomes less imperative and more declarative,
meaning users no longer need to keep the state of bindings, class names, and
other class code in their heads.</p>
</li>
<li>
<p>The gap between template-only components - which are analogous to React and
other frameworks' functional components - and components with a backing class
is reduced, making them a more viable pattern.</p>
</li>
</ul>
<a class="header" href="print.html#namespaced-arguments" id="namespaced-arguments"><h3>Namespaced Arguments</h3></a>
<p>In classic components, arguments are set as properties directly on the class
instance. This means that class methods and properties can be completely
overwritten by incoming arguments, which can have surprising and problematic
side effects. For example, let's say we have a component that has a <code>fullName</code>
computed property and expects <code>firstName</code> and <code>lastName</code> arguments:</p>
<pre><code class="language-js">// components/person.js
export default Component.extend({
  firstName: null,
  lastName: null,

  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
});
</code></pre>
<p>The public API of this component is <em>supposed</em> to just be those two arguements.
However, a developer may realize that they can pass <code>fullName</code> directly to the
component, overriding the computed property:</p>
<pre><code class="language-hbs">&lt;Person @fullName={{this.fullNameWithMiddle}}&gt;
</code></pre>
<p>This is clearly a bad pattern, but it shows that in effect that most details of
a component's implementation are not truly private, and any property or value
can be overriden from external contexts. In most common day-to-day scenarios
developers just have to be careful that they are following the intended public
API of a component, but this also has the potential for misuse and enables
antipatterns.</p>
<p>Glimmer components assign their arguments to the <code>args</code> property on their
instance, preventing namespace collisions from happening in the first place.
This allows component authors to define a clear public API for a component which
<em>cannot</em> be circumvented.</p>
<a class="header" href="print.html#immutable-arguments" id="immutable-arguments"><h3>Immutable Arguments</h3></a>
<p>In classic components argument values on the component are also <em>mutable</em>. This
can lead to some confusing behavior, because argument values in the <em>class</em> can
change, but named arguments in <em>templates</em> cannot. For instance, given this
component:</p>
<pre><code class="language-js">// components/welcome.js
export default Component.extend({
  firstName: 'Jen',
  lastName: 'Weber'
});
</code></pre>
<pre><code class="language-hbs">&lt;!-- templates/components/welcome.hbs  --&gt;
Hey there, {{@firstName}} {{@lastName}}!
</code></pre>
<p>And this invocation:</p>
<pre><code class="language-hbs">&lt;Welcome /&gt;
</code></pre>
<p>You might expect that the result would be:</p>
<pre><code class="language-hbs">Hey there, Jen Weber!
</code></pre>
<p>However, <code>{{@firstName}}</code> and <code>{{@lastName}}</code> would actually be empty values.
They refer <em>directly</em> to the arguments passed into the <em>invocation</em> of the
component, and to get the results we wanted, we would have to invoke it like so:</p>
<pre><code class="language-hbs">&lt;Welcome @firstName=&quot;Jen&quot; @lastName=&quot;Weber&quot; /&gt;
</code></pre>
<p>The advantage in this is that named arguments are fully transparent. When seen
in a template, users can know without a doubt that the named argument was a
value passed in from the invocation. Likewise, when they see a standard binding
to a value like <code>{{this.firstName}}</code> or <code>{{firstName}}</code>, they know this is a
value defined on the component - it could a computed property, it could come
from a service, it could be a random value, but it is <em>not</em> an argument.</p>
<p>Glimmer components align their argument access with named args by making
arguments available exclusively on a (shallow) frozen object, <code>this.args</code>.
Attempting to modify <code>this.args</code> will hard error, meaning that like templates,
users will always be able to refer to <code>this.args</code> as the canonical state of the
values passed to the component invocation.</p>
<p>Immutable arguments make reasoning about the state of a component simpler (&quot;Was
that a user provided value or a default/mutated/computed value?&quot; becomes &quot;Was it
an argument or not?&quot;), and encourages use of <code>{{@arg}}</code> syntax in templates
where appropriate. At scale, this makes reading templates even easier, since
more information is encoded in the template itself. One way data flow also
encourages the Data Down, Actions Up pattern, and normalizes the way that data
flows through apps, making reasoning about app state easier.</p>
<a class="header" href="print.html#minimal-classes" id="minimal-classes"><h3>Minimal Classes</h3></a>
<p>Classic components are large classes, with lots of built up functionality and
debt from over the years. The total list of default properties and hooks
(including inherited ones) includes:</p>
<ul>
<li><strong>13</strong> Standard lifecycle hooks, such as
<code>didInsertElement</code>/<code>willDestroyElement</code> and <code>didUpdate</code>.</li>
<li><strong>29</strong> Event handlers, such as <code>click</code>, <code>mouseEnter</code>, and <code>dragStart</code>.</li>
<li><strong>9</strong> element/element customization properties, such as <code>element</code> and
<code>tagName</code>.</li>
<li><strong>21</strong> standard framework functions, such as <code>get</code>/<code>set</code>,
<code>addObserver</code>/<code>removeObserver</code> and <code>toggleProperty</code>.</li>
</ul>
<p>Coming from a class hierarchy that is 4 levels deep (<code>Component</code> -&gt; <code>CoreView</code>
-&gt; <code>EmberObject</code> -&gt; <code>CoreObject</code>, with about 19 mixins included along the way).</p>
<p>This is a large API surface to become acquainted with, and namespace
collisions are possible with new Ember users - collisions on <code>destroy</code>
were the original reason for adding the <code>actions</code> object to classes, and every
so often a user will pop in on <code>#help</code> wondering why their <code>click</code> or <code>submit</code>
methods trigger automagically, or why their component disappeared when they
added an <code>isVisible</code> property. Even putting aside the possibility of collisions,
the sheer amount of choice can sometimes be overwhelming: Do I put my
initialization logic in <code>init</code> or <code>didInsertElement</code>? Do I use an action or the
<code>click</code> handler? Which update method should I use - <code>didRender</code>, <code>didUpdate</code>,
<code>didReceiveAttrs</code>?</p>
<p>Glimmer components have a constructor, <strong>2</strong> lifecycle hooks, and <strong>3</strong>
properties. They only extend from the Glimmer Component base class -- a simple
ES6 class that does not extend from <code>EmberObject</code>. They don't have any
element/DOM based properties, hooks, event handler functions, whose
responsibilities have been passed on to element modifiers. This <em>dramatically</em>
simplifies what users need to learn in order to start using the bread-and-butter
class of Ember, and enforces a single conventional location for each of the
possible hooks in classic components, allowing users to focus on productivity
out of the box.</p>
<a class="header" href="print.html#glimmerjs-compatibility" id="glimmerjs-compatibility"><h3>Glimmer.js Compatibility</h3></a>
<p>One of the goals for future versions of Ember, post Ember Octane, will be to
enable lighter-weight applications to be built using the framework. Breaking
Ember apart into smaller, fully independent and optional pieces is the core idea
behind the &quot;install your way to Ember&quot; goal, which will enable Ember to be used
in more constrained environments that smaller frameworks such as React, Preact,
Vue, and more excel in. It will also allow users who are size-conscious to adopt
Ember incrementally, adding functionality when it is <em>needed</em> rather than having
all-or-nothing.</p>
<p>This will take time though. Progress has been made, but parts of Ember are still
monolithic. And while it isn't Ember, Glimmer.js is a lightweight wrapper of the
Glimmer VM that enables users to drop that weight and begin writing much more
minimal apps today.</p>
<p>Glimmer components aren't just based on the Glimmer.js component API - they are
one and the same. They will be a shared package, which will be importable and
usable by the users of both frameworks. Not only will users be able to write
better components in Ember, those components will also be cross-compatible with
Glimmer apps (assuming they don't use Ember specific functionality).</p>
<p>It is important to note that while Glimmer components will be versioned
independently from Glimmer and Ember <strong><em>they will abide by the Ember RFC process
for any and all changes to user APIs</em></strong>. The implementations for their component
managers in Glimmer and Ember may change to keep them compatible, but they will
not make major changes without first getting community input, and will be
considered part of the public API of Ember.</p>
<a class="header" href="print.html#prior-art-3" id="prior-art-3"><h2>Prior Art</h2></a>
<p>Part of the challenge in the original Angle Bracket components RFC was
attempting to design without implementation, testing, usage, and feedback.
Glimmer.js provided an early method to experiment, but because it was not widely
adopted there wasn't much feedback from larger-scale usage. This in part
motivated the <a href="https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md">component manager
RFC</a>,
which enabled experimentation in Ember directly, and set us up for having
multiple implementations of component APIs which were interchangeable.</p>
<p>As such, we now have two reference implementations which can be referred to:</p>
<ul>
<li><a href="https://glimmerjs.com/">Glimmer.js</a>, the framework that this component API is
based on, and will be cross-compatible with.</li>
<li><a href="https://github.com/rwjblue/sparkles-component">sparkles-component</a>, an an
implementation of the Glimmer.js component API using Ember's component
managers. It is usable in Ember today.</li>
</ul>
<p>Both of these have minor differences from the API proposed in this RFC, mainly
because they were made before the <a href="https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md">element modifier manager
RFC</a>
was accepted and opened up additional design possibilities. However, they serve
as valuable data points for the viability of a simpler component API, and inform
the design accordingly.</p>
<a class="header" href="print.html#detailed-design-84" id="detailed-design-84"><h2>Detailed design</h2></a>
<p>Glimmer components have the following interface:</p>
<pre><code class="language-ts">interface GlimmerComponent&lt;T = object&gt; {
  args: T;

  isDestroying: boolean;
  isDestroyed: boolean;

  constructor(owner: Opaque, args: T): void;
  willDestroy(): void;
}
</code></pre>
<p>This class will be importable from <code>@glimmer/component</code>;</p>
<pre><code class="language-js">import Component from '@glimmer/component';
</code></pre>
<a class="header" href="print.html#constructor" id="constructor"><h3>Constructor</h3></a>
<p>The constructor for Glimmer components receives two arguments: The owner
instance and the named arguments object. Both of these arguments should
conventionally be passed to <code>super</code> immediately, and then accessed through
decorated service properties, <code>getOwner</code>, and <code>this.args</code>:</p>
<pre><code class="language-js">class PersonComponent extends GlimmerComponent {
  @service profile;

  constructor() {
    super(...arguments);

    let owner = getOwner(this);
    let profileService = this.profile;

    let firstName = this.args.firstName;
  }
}
</code></pre>
<p>These arguments are passed to the constructor so that they can be used for
initial setup of the component. Service injections and args being available in
this way also makes them available to class field initializers, which run
immediately <em>after</em> the call to <code>super</code>:</p>
<pre><code class="language-js">class PersonComponent extends GlimmerComponent {
  @service time;

  // Use the values of args in an initializer
  fullName = `${this.args.firstName} ${this.args.lastName}`;

  // Access a service in an initializer
  currentTime = this.time.now();
}
</code></pre>
<p>The <code>args</code> argument will be shallow-frozen (in development mode only) to prevent
users from modifying them.</p>
<a class="header" href="print.html#type-injections" id="type-injections"><h4>Type Injections</h4></a>
<p>Ember's dependency injection system allows defining injections across an entire
type via
<a href="https://www.emberjs.com/api/ember/3.5/classes/ApplicationInstance/methods/inject?anchor=inject">RegistryProxy#inject</a> - for
instance, Ember Data's store, which is available by default as
<code>this.store</code> on all Routes and Controllers. These injections add a layer of
implicit state to objects, since users must know what the default injections are
ahead of time.</p>
<p>By contrast, service getters (decorated with <code>@service</code>) clearly and explicitly
state the dependencies of a class within its definition. The benefit of having
an explicit dependencies list within each class has proven to be invaluable in
practice since <code>inject.service()</code> was introduced.</p>
<p>Glimmer components will only receive the owner directly, and as such will <em>not</em>
support type injections. This cuts down on the implicit knowledge developers
must have when writing a component.</p>
<a class="header" href="print.html#properties" id="properties"><h3>Properties</h3></a>
<p>Glimmer components have 3 properties: <code>args</code>, <code>isDestroying</code>, and <code>isDestroyed</code>.</p>
<a class="header" href="print.html#args" id="args"><h4><code>args</code></h4></a>
<p>As discussed in the motivation section, <code>args</code> is an object with the values of
the named arguments passed to the component. This property will be updated
whenever the arguments change. It will be shallow-frozen in development mode to
prevent users from setting values on it.</p>
<a class="header" href="print.html#isdestroying" id="isdestroying"><h4><code>isDestroying</code></h4></a>
<p>This property will be set to <code>true</code> when component teardown has been initiated,
<em>before</em> the component's <code>willDestroy</code> hook is run, along with any other
components which are currently being torn down. This allows the entire component
tree to be marked before user code is run. It can be used by users to
conditionally prevent asynchronous code from running, and to check on the
teardown state of the component in general.</p>
<a class="header" href="print.html#isdestroyed" id="isdestroyed"><h4><code>isDestroyed</code></h4></a>
<p>This property will be set after any <code>willDestroy</code> hooks have run, and the
component has been fully torn down. It can be used by users to conditionally
prevent asynchronous code from running, and to check on the teardown state of
the component in general.</p>
<a class="header" href="print.html#lifecycle-hooks" id="lifecycle-hooks"><h3>Lifecycle Hooks</h3></a>
<p>Classic components have 13 major lifecycle hooks that run during 3 major phases
of the component lifecycle, with some hooks running during multiple phases:</p>
<ol>
<li>
<p><strong>Initialization and Initial Render:</strong></p>
<ul>
<li><code>init</code></li>
<li><code>willInsertElement</code></li>
<li><code>didInsertElement</code>,</li>
<li><code>didReceiveAttrs</code></li>
<li><code>willRender</code></li>
<li><code>didRender</code>.</li>
</ul>
</li>
<li>
<p><strong>Rerenders and Updates:</strong></p>
<ul>
<li><code>didReceiveAttrs</code></li>
<li><code>didUpdateAttrs</code></li>
<li><code>willUpdate</code></li>
<li><code>didUpdate</code></li>
<li><code>willRender</code></li>
<li><code>didRender</code></li>
</ul>
</li>
<li>
<p><strong>Destruction:</strong></p>
<ul>
<li><code>willDestroyElement</code></li>
<li><code>didDestroyElement</code></li>
<li><code>destroy</code></li>
<li><code>willDestroy</code></li>
</ul>
</li>
</ol>
<p>Many of these hooks have overlapping or redundant functionality, and it's fairly
confusing when to use which and what the differences are. We can simplify this
cycle in a number of ways:</p>
<ul>
<li>
<p>Hooks that run during multiple phases such as <code>didRender</code> and
<code>didRecieveAttrs</code> can be convenient at times, but also add mental overhead and
redundancy. We can remove these in favor of clearly delineated hooks which
only run during <em>one</em> phase.</p>
</li>
<li>
<p>&quot;Bookend&quot; methods (<code>did*</code> and <code>will*</code>) can be confusing, since they require
some specific knowledge of what the &quot;bookended&quot; functionality is. For
instance, users almost <em>always</em> want to use <code>didInsertElement</code> and
<code>willDestroyElement</code>, but the existence of their opposite bookends can make
this confusing. Additionally, the fact that <code>didReceiveAttrs</code> and
<code>didUpdateAttrs</code> do <em>not</em> have opposing bookends is inconsistent with this
pattern.</p>
</li>
<li>
<p>Hooks that are used to update derived state, such as <code>didUpdate</code> and
<code>didUpdateAttrs</code>, can be generally be replaced with tracked or computed
properties that pull the required values as they are used, rather than eagerly
as they are updated. This is more inline with Glimmer's pull-based change
tracking system, and encourages better practices that are easier to optimize.</p>
</li>
<li>
<p>Hooks which are used to manipulate elements or the DOM in general can be
removed in favor of element modifiers, which are discussed in detail in the
next section.</p>
</li>
</ul>
<p>Based on these considerations, we can reduce these hooks to just a setup and
teardown method: <code>constructor</code> and <code>willDestroy</code>.</p>
<a class="header" href="print.html#constructor-1" id="constructor-1"><h4><code>constructor</code></h4></a>
<p>The native <code>constructor</code> method for the class can be used for initial setup of
the component. This effectively replaces <code>init</code>, and allows users to setup state
before <em>any</em> renders occur. It has the following timing semantics:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called when a component is created</li>
<li>called <em>before</em> any child components are created</li>
<li>called <em>before</em> any element modifiers with install hooks in the component's
template</li>
</ul>
</li>
</ul>
<p>In many cases, using the <code>constructor</code> directly will not be necessary due to
class fields, whose initializers run during instance construction.</p>
<pre><code class="language-js">class Person {
  constructor() {
    this.name = 'Tomster';
  }
}
</code></pre>
<p>Is the same as:</p>
<pre><code class="language-js">class Person {
  name = 'Tomster';
}
</code></pre>
<p>Class fields are assigned <em>after</em> the call to <code>super</code> in the constructor, but
<em>before</em> any of the user's code runs, allowing their values to be accessed by
users as well.</p>
<a class="header" href="print.html#willdestroy" id="willdestroy"><h4><code>willDestroy</code></h4></a>
<p>This hook runs when the component is being destroyed, and can be used for
cleanup code. It has the following timing semantics:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called when a component is removed</li>
<li>called <em>after</em> any child component <code>willDestroy</code> hooks</li>
<li>called <em>after</em> any element modifiers with destroy hooks in the component's
template</li>
<li>called <em>after</em> <code>isDestroying</code> has been set to <code>true</code>, and <em>before</em>
<code>isDestroyed</code> has been set to <code>true</code></li>
<li>called <em>after</em> the DOM has been fully removed and is inaccessible</li>
</ul>
</li>
<li><strong>May or May Not</strong>
<ul>
<li>be called in a stable order relative to sibling component <code>willDestroy</code>
hooks</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#element-modifiers" id="element-modifiers"><h3>Element Modifiers</h3></a>
<p>DOM manipulation is a hard problem for component-oriented frameworks. We spend a
lot of time crafting elegant, functional, template oriented abstractions that
work very well, up until the point where we have to use an imperative native API
like <code>addEventListener</code> or <code>MutationObserver</code>. This is not a problem unique to
Ember - the recent introduction of the React Hooks API, and the <a href="https://nikgraf.github.io/react-hooks/">various flavors
of hooks that exist</a>, many of which
accomplish the same thing in slightly different ways, suggests that this is a
<em>fundamentally difficult problem</em> no matter how you tackle it.</p>
<p>This is also evidenced by the sheer <em>number</em> of hooks which have been added to
classic Ember components over time to handle various different use cases, and
the fact that there does not appear to be a general consensus on best practices
for using these hooks. In our audit, we observed the following:</p>
<ol>
<li><code>didInsertElement</code> was commonly used for setting up component state which had
nothing to do with the element and could have been accomplished in <code>init</code>.</li>
<li><code>didRender</code> was often used for setting up DOM state once on initial render
only, instead of <code>didInsertElement</code>.</li>
<li><code>didRender</code> and <code>didReceiveAttrs</code> (or <code>didUpdate</code> and <code>didUpdateAttrs</code>) were
used interchangeably for setting up and updating DOM state based on incoming
argument changes, without strong conventions on when to use one or the other,
or consideration for which ones fire in SSR (<code>didReceiveAttrs</code> and
<code>didUpdateAttrs</code>) and which do not.</li>
<li>Libraries like
<a href="https://github.com/ember-lifeline/ember-lifeline">ember-lifeline</a> were not
uncommon for managing the extra state that using hooks inevitably creates,
and imply that it is not always intuitive or well understood that you must
clean up that state.</li>
<li>Guards for SSR appear sporadically throughout various hooks, since some
(<code>didInsertElement</code>, <code>willDestroyElement</code>) do <em>not</em> run in SSR, but others
(<code>didReceiveAttrs</code>, <code>didUpdateAttrs</code>) do. This adds <em>another</em> layer of state
that developers must be aware of as they are using lifecycle hooks. Often
times these guards occured even in hooks which <em>did not run</em> in SSR, implying
that it is difficult to remember which hooks are best to use in either
situation.</li>
<li>Hooks such as <code>didRender</code> had many different potential use cases. It was used
for reacting to changes to component arguments in some cases, but in others
it was used as a more general purpose &quot;bloom filter&quot;, allowing the component
to react to <em>any</em> changes to the DOM subtree. The variety of use cases seemed
to add to the confusion about which hooks should be used in which
circumstances.</li>
<li>Another disadvantage of the flexibility of these hooks was that often
developers had to add additional validation steps for their specific use
case. For instance, if a developer wanted to react to a change to a specific
argument in <code>didRender</code> or <code>didReceiveAttrs</code>, they had to add cacheing and
comparison logic manually to do so for each property.</li>
</ol>
<p>In summary, lifecycle hooks attempted to provide on general solution to the
problem of DOM manipulation for <em>all</em> use-cases, and in doing so provided a
solution that solves each individual problem and use-case in a mediocre way.
Rather than continue these patterns in Glimmer components, we believe that they
should lean instead on <em>Element Modifiers</em>.</p>
<p>Modifiers provide a single unified way to define multiple <em>different</em> APIs for
interacting with the DOM. Individual modifiers can be targeted toward specific
use cases, such as adding an event listener or <code>MutationObserver</code>, triggering a
callback during certain lifecycle events, capturing element references for use
in components, and more. Importantly, modifiers are <em>easy to compose</em> and
<em>self-contained</em>, meaning that it will be possible for general purpose addons to
be built for various use cases, and for them all to be used together without
difficulty.</p>
<a class="header" href="print.html#conversion-and-path-forward" id="conversion-and-path-forward"><h4>Conversion and Path Forward</h4></a>
<p>Modifiers may be the general purpose solution for writing DOM APIs, but average
Ember developers should not have to <em>write</em> a modifier very often. This is a key
distinction - it means that beginner Ember developers will not need to learn the
ins and outs of modifiers as soon as they need to use DOM, and that they will be
able to instead rely on established patterns from established libraries, similar
to helpers. This combined with the fact that DOM manipulation was on average a
<em>rare</em> occurence in our audits means they won't be overwhelming to learn.</p>
<p>However, while we have merged the <a href="https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md">Modifier Manager
RFC</a>,
the final API for modifiers themselves is still in RFC, and the community hasn't
had a chance to experiment with them and develop patterns yet. We also want to
be able to provide straightforward upgrade and migration guides for users who
want to convert from classic component lifecycle hooks to modifiers. In order to
cover this gap while the community is still absorbing the new APIs, the
modifiers proposed in the <a href="https://github.com/emberjs/rfcs/pull/415">Render Element Modifiers
RFC</a> will be released as an official
Ember addon. These essentially expose the three hooks of modifiers to users
directly, allowing them to pass callbacks from their components:</p>
<pre><code class="language-hbs">&lt;div
  {{did-insert this.setupElement @arg1 @arg2}}
  {{did-update this.updateElement @arg1 @arg2}}
  {{will-destroy this.teardownElement}}
&gt;
  ...
&lt;/div&gt;
</code></pre>
<p>These modifiers should allow users to approximate most of the existing lifecycle
hooks, and in most cases should be pretty straightforward to update to. The
Ember guides will provide migration examples for a variety of use cases to
assist in converting to these modifiers. Over time, as addons and libraries are
released that target specific use cases, the guides should be updated to include
popular patterns and demonstrate the most effective and conventional ways to
solve <em>specific</em> problems with DOM manipulation.</p>
<a class="header" href="print.html#lifecycle-hook-audit" id="lifecycle-hook-audit"><h3>Lifecycle Hook Audit</h3></a>
<p>In the design process of this RFC, we wanted to provide the minimal set of
functionality that covered the previous use cases of classic components. The
final API of Glimmer components as proposed in this RFC is very small, cutting
out almost all existing hooks in favor of a handful of conventional hooks and
element modifiers.</p>
<p>In order to be sure that these hooks and modifiers would cover existing use
cases, we did an audit of a few popular addons: <a href="https://miguelcobain.github.io/ember-paper/">Ember
Paper</a>,
<a href="https://github.com/sandydoo/ember-google-maps">ember-google-maps</a>, and
<a href="https://github.com/ember-animation/liquid-fire">liquid-fire</a>. These libraries
were chosen because they represent a large mix of both common use cases and edge
cases, and give us a decent cross-section of what the hooks are used for today.</p>
<p>We also did a less formal audit of a variety of addons and open source apps,
including <a href="https://github.com/miguelcobain/ember-leaflet">ember-leaflet</a>,
<a href="https://github.com/cibernox/ember-power-select">ember-power-select</a>,
<a href="https://github.com/cibernox/ember-basic-dropdown">ember-basic-dropdown</a>,
<a href="https://github.com/Addepar/ember-table">ember-table</a>,
<a href="https://github.com/html-next/vertical-collection">vertical-collection</a>,
<a href="https://github.com/miguelcobain/ember-composability-tools">ember-composablity-tools</a>,
<a href="https://github.com/travis-ci/travis-web">Travis Web</a>, <a href="https://github.com/TryGhost/Ghost-Admin">the Ghost admin
app</a>, and <a href="https://github.com/HospitalRun/hospitalrun-frontend">Hospital
Run</a>, along with general
code searches through Ember Observer.</p>
<p>In all of these, the only use case we found that was <em>not</em> covered was the
ability to run a hook whenever a render occurs in the subtree of a component
using <code>didRender</code> or <code>didUpdate</code>. The only instance we found of this was in
<a href="https://github.com/sandydoo/ember-google-maps/blob/d901864e9198c1d4956d5ba9629147f64e4ae6b7/addon/templates/components/g-map/overlay.hbs#L6">ember-google-maps</a>,
where it was used detect when an
<a href="https://ember-google-maps.sandydoo.me/docs/overlays">overlay</a> component has
rendered and needs to be repositioned. For this rare case, we believe a
<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a>
set to detect mutations to the DOM subtreemay be more appropriate.
Alternatively, a component can be defined with a custom component manager, which
still retains this ability.</p>
<p>The usages from the audit and their equivalent solution in Glimmer components
have been included in this RFC in an appendix.</p>
<a class="header" href="print.html#actions-1" id="actions-1"><h3>Actions</h3></a>
<p>In classic components, actions are defined on the <code>actions</code> hash, and can be
referenced in templates using strings passed to the <code>{{action}}</code> helper:</p>
<pre><code class="language-js">export default Component.extend({
  actions: {
    buttonPressed() {
      // ...
    }
  }
})
</code></pre>
<pre><code class="language-hbs">&lt;button onclick={{action 'buttonPressed'}}&gt;Press Me!&lt;/button&gt;
</code></pre>
<p>This form of action sending is based on the <code>ActionHandler</code> mixin and requires
that the component class have a <code>send</code> method. Glimmer components will <em>not</em>
implement this API, and as such will not support string based action helpers.
In development mode a special error will be thrown instead, informing users of
alternatives.</p>
<p>Instead, users should use helpers or decorators to bind functions to the
component instance. The <code>action</code> helper and modifier do this in templates, as
does the <code>bind</code> helper provided by the <a href="https://github.com/Serabe/ember-bind-helper">ember-bind-helper</a> addon:</p>
<pre><code class="language-js">export default class ButtonComponent extends Component {
  buttonPressed() {
    // ...
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;button onclick={{action this.buttonPressed}}&gt;Press Me!&lt;/button&gt;
</code></pre>
<p>Alternatively, a decorator could be used to bind the helper to the instance,
such as the <code>@action</code> decorator proposed in the <a href="https://github.com/emberjs/rfcs/pull/408">Decorators RFC</a>.</p>
<pre><code class="language-js">export default class ButtonComponent extends Component {
  @action
  buttonPressed() {
    // ...
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;button onclick={{this.buttonPressed}}&gt;Press Me!&lt;/button&gt;
</code></pre>
<p>However, one method for binding methods which should be discouraged is assigning
an arrow function to class fields:</p>
<pre><code class="language-js">export default class ButtonComponent extends Component {
  buttonPressed = () =&gt; {
    // ...
  }
}
</code></pre>
<p>This is messy for a few reasons:</p>
<ul>
<li>The method is no longer available on the prototype, making it difficult to
mock</li>
<li>It breaks <code>super</code> and inheritance, meaning subclasses have no way to override
the arrow function</li>
<li>Values such as <code>arguments</code> will not be set since it is an arrow function</li>
</ul>
<p>For more details, see <a href="https://github.com/tc39/proposal-decorators/blob/master/bound-decorator-rationale.md">this document explaining the rationale for decorators</a>
over class fields for binding.</p>
<a class="header" href="print.html#dependencies" id="dependencies"><h2>Dependencies</h2></a>
<p>In it's current form this RFC is dependent on 2 of 3 open RFCs being accepted:</p>
<ul>
<li>
<p>The <a href="https://github.com/emberjs/rfcs/pull/408">Decorators RFC</a> must be
accepted, because Glimmer components cannot be defined using classic class
syntax. If it is not accepted this RFC will have to be amended to add a way
for users to define Glimmer components with classic classes.</p>
</li>
<li>
<p>The <a href="https://github.com/emberjs/rfcs/pull/415">Render Element Modifiers RFC</a>
must be accepted, since Glimmer components currently do not have any render
lifecycle hooks or ways to interact with the DOM.</p>
<p>If it is not accepted, this RFC will have to explore some of the alternatives
listed below (<code>{{capture-element}}</code>, <code>bounds</code>, and render hooks).</p>
</li>
</ul>
<a class="header" href="print.html#how-we-teach-this-70" id="how-we-teach-this-70"><h2>How we teach this</h2></a>
<p>Teaching Glimmer components is intrinsically tied to a wider shift in the Ember
programming model - the Ember Octane edition. From a teaching perspective, this
edition will be completely overhauling the guides and updating all of the best
practices as they stand. New users should see Glimmer components as the
<em>default</em>, and should not ever have to write a classic component or see one in
the main guides.</p>
<p>Classic components will of course be widely used for some time however, so a
classic section which includes conversion guides and relevant codemods should be
made available in the guides, and maintained for as long as classic components
are supported by Ember.</p>
<p>Breaking down the public API of Glimmer components, we need to cover:</p>
<ul>
<li>Native class syntax, including the <code>constructor</code> and class fields</li>
<li>Arguments</li>
<li>Lifecycle hooks and properties</li>
<li>Element modifiers</li>
</ul>
<a class="header" href="print.html#native-class-syntax" id="native-class-syntax"><h3>Native class syntax</h3></a>
<p>One of the benefits of native class syntax is that it is used outside of Ember,
so as time goes on we will be able to assume there is more general knowledge of
it, and provide links to documentation for it for users who are not familiar.
During this transitionary period though we should add a more thorough primer of
the syntax to our guides, and explicitly call out the differences between
classic class syntax and native class syntax, including:</p>
<ul>
<li>
<p>Usage of <code>constructor</code> in classes which <em>do not</em> extend from classic classes.
Otherwise, always use <code>init</code>. This will be tricky, because even when using
native classes to extend from classic classes, you should still use <code>init</code>.</p>
</li>
<li>
<p>Nuances of class fields - they run <em>after</em> <code>super</code>, and <em>before</em> user code.</p>
</li>
<li>
<p>Benefits of class field initializers, and how they can be used to do much of
the work that would otherwise be done in the <code>constructor</code> or <code>init</code></p>
</li>
<li>
<p>Expense of class fields - new objects and functions are created for every
instance, so users should also be careful with them.</p>
</li>
<li>
<p>What ends up on the prototype and what's on the instance</p>
</li>
<li>
<p>How do property initializers work</p>
</li>
<li>
<p>What's the default behavior of a constructor, as it pertains to <code>super()</code> and passing arguments</p>
</li>
<li>
<p>The risks of anonymous classes and class factories (i.e, you get poor stack traces)</p>
</li>
<li>
<p>How to implement &quot;default values&quot; in ES6</p>
</li>
<li>
<p>The risks of writing decorators in user-land code (until TC39 stage 4)</p>
</li>
<li>
<p>Methods vs arrow function member values</p>
</li>
<li>
<p>Getting ahold of prototypes if/when you need them</p>
</li>
</ul>
<a class="header" href="print.html#arguments-1" id="arguments-1"><h3>Arguments</h3></a>
<p>For arguments, namespacing makes sense in general as an API choice and is common
in other frameworks (<code>props</code> in React, etc.). We should be sure to cover this
thoroughly for users who are used to classic components, but it shouldn't
require too much explaining.</p>
<p>Immutability will be a bigger sticking point in general, in particular the
inability to provide default argument values. This is easy enough to work around
using an <code>{{or}}</code> helper in templates:</p>
<pre><code class="language-hbs">Hello, {{or @firstName &quot;friend&quot;}}!
</code></pre>
<p>Or a defaulting alias getter in the class:</p>
<pre><code class="language-hbs">Hello, {{this.firstName}}!
</code></pre>
<pre><code class="language-js">export default class Greeting extends GlimmerComponent {
  @tracked
  get firstName() {
    return this.args.firstName || 'friend';
  }
}
</code></pre>
<p>But does add a bit of boilerplate to components. Users will also have to be
careful when attempting to override these &quot;defaults&quot; in subclasses, since it is
not as simple as overriding a class field or property. We can guide users to
use template-only components to &quot;partially applied&quot; components when trying to
provide defaults in subclasses instead, leveraging the outer HTML semantics of
Glimmer components:</p>
<pre><code class="language-hbs">&lt;!-- components/button.hbs --&gt;
&lt;button class=&quot;button {{@type}}&quot;&gt;
  &lt;i class=&quot;icon {{@type}}&quot;&gt;&lt;/i&gt;
  {{yield}}
&lt;/button&gt;
</code></pre>
<pre><code class="language-hbs">&lt;!-- component/success-button.hbs --&gt;
&lt;Button @type=&quot;success&quot;&gt;{{yield}}&lt;/Button&gt;
</code></pre>
<pre><code class="language-hbs">&lt;!-- component/danger-button.hbs --&gt;
&lt;Button @type=&quot;danger&quot;&gt;{{yield}}&lt;/Button&gt;
</code></pre>
<p>Or to explore possibilities using decorators, such as those in the
<a href="https://github.com/gossi/sparkles-decorators">sparkles-decorators</a> addon.</p>
<a class="header" href="print.html#lifecycle-hooks-and-properties" id="lifecycle-hooks-and-properties"><h4>Lifecycle hooks and properties</h4></a>
<p>For users without framework experience, and users of other frameworks, lifecycle
hooks will be very minimal and fairly easy to understand. The lack of render
hooks may be the more difficult part to understand, and we'll have to lean on
the documentation for element modifiers and make sure that is <em>really</em> excellent
to get the concepts there across.</p>
<p>For existing users, who are used to having a variety of hooks to choose from
when coordinating lifecycle events, the hooks may be fairly confusing. The
bullet points here are:</p>
<ul>
<li>Tracked properties/computed properties are the primary place to react to
argument changes for any values that can be computed directly via getters.
Ideally, most logic for derived state is conventionally in tracked or computed
properties.</li>
<li><code>willDestroy</code> is the correct place for all teardown code, like in classic
components.</li>
<li><code>didReceiveAttrs</code>, <code>willRender</code>, and <code>didRender</code> code should be extracted into
functions which are then passed to <code>{{did-insert}}</code> and <code>{{did-update}}</code></li>
<li><code>willDestroyElement</code> code should be extracted into functions which are then
passed to <code>{{will-destroy}}</code></li>
</ul>
<p>Additionally, we should make sure we cover <code>isDestroying</code> and <code>isDestroyed</code>
pretty thoroughly. Users should know that they can (and probably should) check
these flags if they are doing anything asynchronous that could happen after the
component has been torn down.</p>
<a class="header" href="print.html#element-modifiers-1" id="element-modifiers-1"><h4>Element modifiers</h4></a>
<p>The render element modifiers will be the most different part of Glimmer
components for users. The strategy for teaching these is <a href="https://github.com/emberjs/rfcs/blob/b9f390cb98f560d9cf876e3b1d67226fe0e1613b/text/0000-render-element-modifiers.md#how-we-teach-this">included in their
RFC</a>,
but the key points are:</p>
<ol>
<li>
<p>Teaching modifiers as a concept first, so users understand that what they're
looking at is a <em>general</em> tool, and that the render modifiers are an official
addon provided by Ember.</p>
</li>
<li>
<p>Providing <em>lots</em> of examples for various use cases, especially for users
transitioning from classic components.</p>
</li>
</ol>
<a class="header" href="print.html#template-only-components-1" id="template-only-components-1"><h3>Template-Only Components</h3></a>
<p><a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">Template-only components</a>
are not strictly speaking related to the <code>GlimmerComponent</code> class proposed in
this RFC. However, conceptually they will probably be much easier to teach in
relation to Glimmer components, and will be an important part of Octane that we
should be sure to cover in depth. Additionally, the name of the optional feature
flag, <code>template-only-glimmer-components</code>, would make teaching the differences
between Glimmer components and template-only components much more difficult and
confusing.</p>
<p>As such, when writing the documentation for Glimmer components, we should ensure
that we cover template-only components in some detail as well.</p>
<a class="header" href="print.html#drawbacks-94" id="drawbacks-94"><h2>Drawbacks</h2></a>
<a class="header" href="print.html#multiple-component-apis" id="multiple-component-apis"><h3>Multiple component APIs</h3></a>
<p>One major drawback to Glimmer components is that they add a separate API for
components, meaning that for the forseeable future Ember users will likely
need to learn how to use both interchangeably. This introduces a fair amount of
mental overhead for users, but the benefits of Glimmer components and their
simplicity should make this less problematic.</p>
<a class="header" href="print.html#heavy-reliance-on-element-modifiers" id="heavy-reliance-on-element-modifiers"><h3>Heavy reliance on element modifiers</h3></a>
<p>Glimmer components as proposed in this RFC are heavily reliant on element
modifiers for element manipulation. Element modifiers are a relatively new
concept in Ember, and as such will likely be unfamiliar to users and require
more learning than normal to get used to. This also means that users will not
be able to rely on well established patterns, and will have to develop new ones
for dealing with element manipulation.</p>
<a class="header" href="print.html#lack-of-positional-parameter-support" id="lack-of-positional-parameter-support"><h3>Lack of positional parameter support</h3></a>
<p>Glimmer components are meant to cover <em>most</em> common use cases, but are also
meant to be as minimal as possible. As such, they do <em>not</em> have support for
positional parameters. Positional parameters are already unusable with any
component invoked using angle bracket syntax, but Glimmer components will also
not support them even when using curly bracket invocation.</p>
<p>The use cases for positional parameters are very uncommon, so it doesn't make
sense to add them to the main component class as an option. Instead, we should
make alternative component classes which support positional parameters, perhaps
exclusively (e.g. asserting if positional parameters are <em>not</em> defined).</p>
<a class="header" href="print.html#alternatives-96" id="alternatives-96"><h2>Alternatives</h2></a>
<a class="header" href="print.html#render-lifecycle-hooks" id="render-lifecycle-hooks"><h3>Render lifecycle hooks</h3></a>
<p>The ommission of <code>didRender</code>,  <code>didUpdate</code>, <code>didInsertElement</code>,
<code>willDestroyElement</code>, and other render oriented hooks could be confusing to
users. These were staples of classic components, are common in other frameworks,
and make it easy for users to orient themselves when looking at a component
class. They are part of the &quot;standard lifecycle&quot; that make up many component
rendering systems, and make components easier to teach. They also allow users to
place most of their element manipulation logic inside their components, which is
a benefit for users who prefer lighter templates with less logic in them.</p>
<p>Element modifiers, by contrast, are a very new concept in Ember and will require
users to learn a fair amount more just to get started. They force more logic
into the template, and mean users have to look at the template to know if a
method is an element lifecycle hook or an internal method.</p>
<p>Adding the standard element lifecycle hooks would allow users to follow the
patterns they are currently used to, and that are used in other frameworks. If
added without <code>{{capture-element}}</code> or <code>bounds</code> (see below), they could be used
with <code>{{did-insert}}</code> and <code>{{will-destroy}}</code> for registering elements:</p>
<pre><code class="language-hbs">&lt;div {{did-render this.registerElement}}&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">class ExampleComponent extends Component {
  @action
  registerElement(element) {
    this.element = element;
  }

  didRender() {
    setupElement(this.element);
  }
}
</code></pre>
<a class="header" href="print.html#add-a-capture-element-modifier" id="add-a-capture-element-modifier"><h3>Add a <code>{{capture-element}}</code> modifier</h3></a>
<p>This alternative would go hand in hand with having render lifecycle hooks.
Rather than relying solely on element modifiers for DOM manipulation, we could
add a modifier that allows users to specify elements which they want to
reference in their component class:</p>
<pre><code class="language-hbs">&lt;div {{capture-element this}}&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">class ExampleComponent extends Component {
  didRender() {
    setupElement(this.elements.main);
  }
}
</code></pre>
<p>This would have to take into account multiple usages, and variations of usages.
For instance, how would using <code>capture-element</code> in an <code>if</code> or <code>each</code> work?</p>
<pre><code class="language-hbs">&lt;div {{capture-element this}}&gt;
  {{#if someBool}}
    &lt;div {{capture-element this 'conditionalElement'}}&gt;
  {{/if}}

  {{#each items as |item|}}
    &lt;div {{capture-element this 'itemElements'}}&gt;
  {{/each}}
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">class ExampleComponent extends Component {
  didRender() {
    this.elements.main; // the main outer div
    this.elements.conditionalElement; // the conditional element
    this.elements.itemElements; // An array of all the items that are rendered
  }
}
</code></pre>
<p>This would also mean a fair amount of additional code would need to be added for
reacting to changes in the DOM compared to <code>{{did-insert}}</code> and
<code>{{will-destroy}}</code>. For instance, if the case of conditionally captured element,
additional validation code will have to exist in <code>didRender</code>:</p>
<pre><code class="language-js">class ExampleComponent extends Component {
  didRender() {
    let { conditionalElement } = this.elements;

    if (conditionalElement) {
      this._previousConditionalElement = conditionalElement;

      setupPlugin(conditionalElement);
    } else {
      teardownPlugin(this._previousConditionalElement);
    }
  }
}
</code></pre>
<p>This problem is compounded in collections, where any number of elements may be
added or removed.</p>
<a class="header" href="print.html#add-element-or-bounds-on-the-component" id="add-element-or-bounds-on-the-component"><h3>Add <code>element</code> or <code>bounds</code> on the component</h3></a>
<p>We could attempt to add DOM references back to the component, instead of adding
the <code>{{did-insert}}</code> and <code>{{will-destroy}}</code> modifiers. This would require us to
handle a number of edge-cases (0 element, multi element), and would open up some
intimate details of the Glimmer VM to user code (<code>bounds</code> nodes). If in the
future the VM wanted to change these details, it could be problematic.</p>
<p>Element modifiers are less invasive, more declarative, and handle a lot of
boilerplate type code (checking to see if an element exists, for instance).
However, they are also very new to Ember users as a concept (aside from
<code>{{action}}</code>) and could be difficult to teach.</p>
<a class="header" href="print.html#init-vs-constructor" id="init-vs-constructor"><h3><code>init</code> vs <code>constructor</code></h3></a>
<p>Recent changes to the way native classes extend from <code>EmberObject</code> made it so
users have to use <code>init</code> instead of the <code>constructor</code>. This is a pretty
universal caveat currently, so it's fairly teachable - there is a <code>constructor</code>,
but use <code>init</code> instead (see the <a href="https://github.com/emberjs/rfcs/blob/master/text/0337-native-class-constructor-update.md">Native Class Constructor
RFC</a>)</p>
<p>With the current design of Glimmer components, we are introducing the first base
class which doesn't extend from <code>EmberObject</code>, and requires users to use
<code>constructor</code> instead. This could be confusing, and will have to be <em>very</em>
clearly documented at the least.</p>
<p>We could alternatively include an <code>init</code> hook, or have both. This would allow
users to follow one rule for object initialization, but would also lock us into
the supporting the <code>init</code> hook for the forseeable future.</p>
<a class="header" href="print.html#no-owner-in-constructor" id="no-owner-in-constructor"><h3>No owner in constructor</h3></a>
<p>Sparkles components do not provide access to the owner or injections in the
constructor, though it is a requested feature. Instead of passing the owner to
the constructor, we could add a <code>willCreate</code> or <code>init</code> hook which allows users
to setup the instance after the owner has been assigned.</p>
<p>Alternatively, the exact method by which the owner is passed to the constructor
can be changed (on an object vs directly) or all injections could be passed,
enabling typed injections.</p>
<a class="header" href="print.html#appendix-lifecycle-hook-audit" id="appendix-lifecycle-hook-audit"><h2>Appendix: Lifecycle Hook Audit</h2></a>
<a class="header" href="print.html#a-hrefhttpsmiguelcobaingithubioember-paperember-papera" id="a-hrefhttpsmiguelcobaingithubioember-paperember-papera"><h3><a href="https://miguelcobain.github.io/ember-paper/">ember-paper</a></h3></a>
<a class="header" href="print.html#didupdateattrs-1" id="didupdateattrs-1"><h4><code>didUpdateAttrs</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-autocomplete-trigger.js#L37">link</a></td><td>Setup component state based on incoming arguments</td><td>Tracked properties</td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-tile.js#L41">link</a></td><td>Setup component state based on incoming arguments</td><td>Tracked properties</td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L69">link</a></td><td>Element setup/update code based on incoming arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L75">link</a></td><td>Element setup/update code based on incoming arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L65">link</a></td><td>Element setup/update code based on incoming arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
</tbody></table>
<a class="header" href="print.html#didreceiveattrs-1" id="didreceiveattrs-1"><h4><code>didReceiveAttrs</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-autocomplete.js#L93">link</a></td><td>Setup component state based on incoming arguments</td><td>Tracked properties and <code>constructor</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-card-actions.js#L17">link</a></td><td>Setup component state based on incoming arguments</td><td>Tracked properties and <code>constructor</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L76">link</a></td><td>Setup component state based on incoming arguments, validate incoming arguments</td><td>Tracked properties and <code>constructor</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L126">link</a></td><td>Animate based on incoming arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select.js#L40">link</a></td><td>Trigger validations</td><td>Tracked properties and <code>constructor</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-sidenav-inner.js#L55">link</a></td><td>Element update code and sending an action</td><td>Tracked properties and <code>{{did-insert}}</code> with args</td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L131">link</a></td><td>Updating logic and element update code</td><td>Tracked properties and <code>{{did-insert}}</code> with args</td></tr>
</tbody></table>
<a class="header" href="print.html#willinsertelement" id="willinsertelement"><h4><code>willInsertElement</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L91">link</a></td><td>Container setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
</tbody></table>
<a class="header" href="print.html#didinsertelement" id="didinsertelement"><h4><code>didInsertElement</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog-inner.js#L39">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog.js#L64">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L52">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L89">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-menu-content-inner.js#L26">link</a></td><td>Set focus after initial render</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L118">link</a></td><td>Setup animation based on arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select-menu-inner.js#L29">link</a></td><td>Set focus after initial render</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select-options.js#L14">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-sidenav-inner.js#L48">link</a></td><td>Element setup code on initialization (partially based on args)</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L62">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L56">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tab.js#L44">link</a></td><td>Measure element on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L71">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L58">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L96">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip-inner.js#L24">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip.js#L67">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat-scroller.js#L8">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L8">link</a></td><td>Measure element on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/ripple-mixin.js#L8">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/translate3d-mixin.js#L8">link</a></td><td>Element animation on setup</td><td><code>{{did-insert}}</code></td></tr>
</tbody></table>
<a class="header" href="print.html#willdestroyelement" id="willdestroyelement"><h4><code>willDestroyElement</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog-inner.js#L51">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog.js#L79">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L64">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L104">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L153">link</a></td><td>Teardown animations on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L81">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L70">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L102">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L77">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L118">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip.js#L110">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat-scroller.js#L17">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/child-mixin.js#L30">link</a></td><td>Unregister child class from parent</td><td><code>willDestroy</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/translate3d-mixin.js#L30">link</a></td><td>Teardown animations on destruction</td><td><code>{{will-destroy}}</code></td></tr>
</tbody></table>
<a class="header" href="print.html#didupdate" id="didupdate"><h4><code>didUpdate</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L57">link</a></td><td>Reapply styles based on changes to args</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
</tbody></table>
<a class="header" href="print.html#didrender" id="didrender"><h4><code>didRender</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L97">link</a></td><td>Resize component based on changes to args</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code>, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-speed-dial-action-action.js#L34">link</a></td><td>Animate component based on changes to arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-speed-dial.js#L32">link</a></td><td>Set <code>elementDidRender</code> boolean on instance</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tab.js#L52">link</a></td><td>Measure component on render</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code>, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L96">link</a></td><td>Resize component based on changes to size</td><td><code>{{did-insert}}</code> with args, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L156">link</a></td><td>Measure element sizes based on changes to args</td><td><code>{{did-insert}}</code> with args</td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefhttpsgithubcomsandydooember-google-mapsember-google-mapsa" id="a-hrefhttpsgithubcomsandydooember-google-mapsember-google-mapsa"><h3><a href="https://github.com/sandydoo/ember-google-maps">ember-google-maps</a></h3></a>
<a class="header" href="print.html#didupdateattrs-2" id="didupdateattrs-2"><h4><code>didUpdateAttrs</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map.js#L103">link</a></td><td>Synchronize options with Google maps</td><td>Refactor to use actions to modify data, or use a modifier</td></tr>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L54">link</a></td><td>Update component based on changes to arguments</td><td>Refactor to use actions to modify data, or use a modifier</td></tr>
</tbody></table>
<a class="header" href="print.html#didreceiveattrs-2" id="didreceiveattrs-2"><h4><code>didReceiveAttrs</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/waypoint.js#L20">link</a></td><td>Register component with parent</td><td><code>constructor</code></td></tr>
</tbody></table>
<a class="header" href="print.html#didinsertelement-1" id="didinsertelement-1"><h4><code>didInsertElement</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L46">link</a></td><td>Register component with parent and initialize</td><td><code>constructor</code> and parent component <code>{{did-insert}}</code></td></tr>
</tbody></table>
<a class="header" href="print.html#willdestroyelement-1" id="willdestroyelement-1"><h4><code>willDestroyElement</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L60">link</a></td><td>Element teardown code on destruction (and potentially destruction of parent)</td><td><code>willDestroy</code> and parent component <code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/waypoint.js#L26">link</a></td><td>Unregister element from parent</td><td><code>willDestroy</code> and parent component <code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/mixins/process-options.js#L26">link</a></td><td>Teardown class state</td><td><code>willDestroy</code></td></tr>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/mixins/register-events.js#L26">link</a></td><td>Teardown class state</td><td><code>willDestroy</code></td></tr>
</tbody></table>
<a class="header" href="print.html#didrender-1" id="didrender-1"><h4><code>didRender</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/master/addon/templates/components/g-map/overlay.hbs#L6">link</a></td><td>Detect changes to subtree and reposition overlay</td><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a> or custom component that can trigger actions on subtree rerenders</td></tr>
</tbody></table>
<a class="header" href="print.html#a-hrefhttpsgithubcomember-animationliquid-fireliquid-firea" id="a-hrefhttpsgithubcomember-animationliquid-fireliquid-firea"><h3><a href="https://github.com/ember-animation/liquid-fire">liquid-fire</a></h3></a>
<a class="header" href="print.html#didreceiveattrs-3" id="didreceiveattrs-3"><h4><code>didReceiveAttrs</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/illiquid-model.js#L7">link</a></td><td>Capture argument as component state</td><td><code>constructor</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-outlet.js#L23">link</a></td><td>Capture argument as component state</td><td><code>constructor</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-versions.js#L15">link</a></td><td>Run update code for changing versions (and animating)</td><td><code>constructor</code> and tracked properties or element modifiers</td></tr>
</tbody></table>
<a class="header" href="print.html#didinsertelement-2" id="didinsertelement-2"><h4><code>didInsertElement</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-child.js#L12">link</a></td><td>Trigger animation</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-container.js#L44">link</a></td><td>Set did render</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-measured.js#L15">link</a></td><td>Element setup code on insertion</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-spacer.js#L11">link</a></td><td>Element setup code on insertion</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-sync.js#L8">link</a></td><td>Pause animations on insertion (continue later via action)</td><td><code>{{did-insert}}</code></td></tr>
</tbody></table>
<a class="header" href="print.html#willdestroyelement-2" id="willdestroyelement-2"><h4><code>willDestroyElement</code></h4></a>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-measured.js#L37">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
</tbody></table>
<ul>
<li>Start Date: 2018-19-12</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/418</li>
<li>Tracking Issue: https://github.com/emberjs/rfc-tracking/issues/30</li>
</ul>
<a class="header" href="print.html#deprecate-route-render-apis" id="deprecate-route-render-apis"><h1>Deprecate Route render APIs</h1></a>
<a class="header" href="print.html#summary-99" id="summary-99"><h2>Summary</h2></a>
<p>This RFC proposses the deprecation of <a href="https://emberjs.com/api/ember/3.6/classes/Route/methods/render?anchor=render"><code>Route#render</code></a>, <a href="https://emberjs.com/api/ember/3.6/classes/Route/methods/render?anchor=renderTemplate"><code>Route#renderTemplate</code></a> and named <code>{{outlet}}</code> APIs. The following deprecation message will be emitted upon usage of <code>render</code> or <code>renderTemplate</code>:</p>
<pre><code>The usage of `renderTemplate` is deprecated. Please see the following deprecation guide to migrate.
</code></pre>
<p>and</p>
<pre><code>The usage of `render` is deprecated. Please see the following deprecation guide to migrate.
</code></pre>
<p>The following will be compile time deprecation for named outlets:</p>
<pre><code>Please refactor `{{outlet &lt;NAME&gt;}}` to a component &lt;SOURCE_INFO&gt;.
</code></pre>
<a class="header" href="print.html#motivation-100" id="motivation-100"><h2>Motivation</h2></a>
<p>These APIs are largely holdovers from a time where components where not as prominent in your typical Ember application. While they are still documented, these APIs created an interesting coupling between the <code>Route</code> and the template. These APIs are also prone to breaking conventional naming conventions, which can lead to confusion for developers. Another issue is that it is unclear how something like this works with route based tree shaking, as there are no strong conventions or direct imports as to what is actually being used.</p>
<a class="header" href="print.html#transition-path-15" id="transition-path-15"><h2>Transition Path</h2></a>
<p>The migration plan here is going to be somewhat situational based on the UI that was being constructed. For cases where named outlets were being used it is likely that they should just be moved to components. For cases where you were escaping the existing DOM hierarchy to render a template somewhere else in the DOM, one should use the built-in <a href="https://github.com/emberjs/rfcs/blob/master/text/0287-promote-in-element-to-public-api.md"><code>{{in-element}}</code></a> helper or an addon like <a href="https://github.com/ef4/ember-elsewhere">ember-elsewhere</a>. Below are some example of how a migration would look.</p>
<p><strong>Migrating Named Outlets</strong></p>
<p>Given:</p>
<pre><code class="language-js">Ember.Route.extend({
  // ...

  renderTemplate() {
    this.render('cart', {
      into: 'checkout',
      outlet: 'cart',
      controller: 'cart'
    })
  }
})
</code></pre>
<pre><code class="language-hbs">{{! checkout.hbs}}
&lt;section id=&quot;items&quot;&gt;
  {{outlet}}
&lt;/section&gt;
&lt;aside&gt;
  {{outlet &quot;cart&quot;}}
&lt;/aside&gt;
</code></pre>
<p>This would tell Ember to render <code>cart.hbs</code> into <code>checkout.hbs</code> at the <code>{{outlet &quot;cart&quot;}}</code> and use the <code>cart</code> controller to back the <code>cart.hbs</code> template. This is pretty confusing pattern and creates this implicit coupling that is spread between the <code>Route</code> and template.</p>
<p>Luckily, we can express this entire concept with components.</p>
<pre><code class="language-hbs">{{! checkout.hbs}}
&lt;section id=&quot;items&quot;&gt;
  {{outlet}}
&lt;/section&gt;
&lt;aside&gt;
  &lt;Cart /&gt;
&lt;/aside&gt;
</code></pre>
<p>In the event you were using <code>model</code> to derive what to render, you can us the <code>{{component}}</code> helper to dynamically render a component.</p>
<p><strong>Migrating Hiearchy Escaping</strong></p>
<p>Given:</p>
<pre><code class="language-hbs">{{! app/templates/authenticated.hbs}}

&lt;nav&gt;
  &lt;h1&gt;ACME Corp.&lt;/h1&gt;
  &lt;section&gt;
    {{outlet &quot;account&quot;}}
  &lt;/section&gt;
&lt;/nav&gt;

&lt;section id=&quot;content&quot;&gt;
  {{outlet}}
&lt;/section&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/account.hbs }}
{{#link-to 'account'}}
  &lt;img src=&quot;{{this.img}}&quot; alt=&quot;{{this.name}} /&gt;
{{/link-to}}
</code></pre>
<pre><code class="language-js">// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  // ...
  user: service('user'),
  renderTemplate() {
    if (this.user.isLoggedIn) {
      this.render('account', {
        into: 'applcation',
        outlet: 'account',
        controller: 'account'
      });
    } else {
      this.transitionTo('login')
    }
  }
});
</code></pre>
<p>One way this could be migrated is like the following:</p>
<pre><code class="language-hbs">{{! app/templates/authenticated.hbs}}

&lt;nav&gt;
  &lt;h1&gt;ACME Corp.&lt;/h1&gt;
  &lt;section id=&quot;account-placeholder&quot;&gt;&lt;/section&gt;
&lt;/nav&gt;

&lt;section id=&quot;content&quot;&gt;
  {{outlet}}
&lt;/section&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/authenticated/campaigns.hbs }}

{{outlet}}

{{#in-element this.accountPlaceholder}}
  {{#link-to 'account'}}
    &lt;img src=&quot;{{this.account.img}}&quot; alt=&quot;{{this.account.name}} /&gt;
  {{/link-to}}
{{/in-element}}
</code></pre>
<pre><code class="language-js">// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  //...
  user: service('user'),
  beforeModel() {
    if (!this.user.isLoggedIn) {
      this.transitionTo('login')
    }
  }
});
</code></pre>
<pre><code class="language-js">// app/controller/authenticated/campaigns.js
import Route from '@ember/route';
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { inject as controller } from '@ember/controller';

export default Controller.extend({
  //...
  account: controller('account')
  init() {
    this._super(...arguments);
    this.accountPlaceholder = document.getElementById('account-placeholder');
  }
});
</code></pre>
<p>If you want to do this with components you could do the same thing as the following:</p>
<pre><code class="language-hbs">{{! app/templates/authenticated.hbs}}

&lt;nav&gt;
  &lt;h1&gt;ACME Corp.&lt;/h1&gt;
  &lt;section id=&quot;account-placeholder&quot;&gt;&lt;/section&gt;
&lt;/nav&gt;

&lt;section id=&quot;content&quot;&gt;
  {{outlet}}
&lt;/section&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/authenticated/campaigns.hbs }}
{{outlet}}

&lt;UserAccount /&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/components/user-account.hbs }}
{{#in-element this.accountPlaceholder}}
  {{#link-to 'account'}}
    &lt;img src=&quot;{{this.account.img}}&quot; alt=&quot;{{this.account.name}} /&gt;
  {{/link-to}}
{{/in-element}}
</code></pre>
<pre><code class="language-js">// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  //...
  user: service('user'),
  beforeModel() {
    if (!this.user.isLoggedIn) {
      this.transitionTo('login')
    }
  }
});
</code></pre>
<pre><code class="language-js">// app/components/user-account.js
import Component from '@ember/route';
import { inject as controller } from '@ember/controller';

export default Component.extend({
  // ...
  account: controller('account'),
  init() {
    this._super(...arguments);
    this.accountPlaceholder = document.getElementById('account-placeholder');
  }
});
</code></pre>
<a class="header" href="print.html#how-we-teach-this-71" id="how-we-teach-this-71"><h1>How We Teach This</h1></a>
<p>These APIs not been a mainline API for quite some time now. The guides briefly mention this functionality. In those cases we should mirgate the guides should link to the <code>{{in-element}}</code> documentation and the component documentation. The above &quot;Transition Path&quot; will serve as the deprecation guide.</p>
<a class="header" href="print.html#role-out-plan" id="role-out-plan"><h1>Role Out Plan</h1></a>
<p>Prior to adding the deprecation we must first do the following items</p>
<ul>
<li>[ ] The <code>{{in-element}}</code> helper implementation remains incomplete. It should be completed.
<ul>
<li>[ ] The <a href="https://github.com/emberjs/rfcs/blob/master/text/0287-promote-in-element-to-public-api.md#small-proposed-changes">small changes</a> section of the <code>{{in-element}}</code> RFC needs to be implemented. Specifically the helper should &quot;replace all the content of the destination&quot;.</li>
<li>[ ] The <code>{{in-element}}</code> helper should be documented in the <a href="https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers">API docs</a>.</li>
<li>[ ] Adding <code>{{in-element}}</code> usage to the guides can be considered.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#drawbacks-95" id="drawbacks-95"><h2>Drawbacks</h2></a>
<p>The drawback of this is that it is churn for applications that are relying heavily of these imperative APIs to construct their UI. They will need to encapsulate and use the existing declarative APIs.</p>
<a class="header" href="print.html#alternatives-97" id="alternatives-97"><h2>Alternatives</h2></a>
<p>No real alternatives as we want to move away from these style of imperative APIs in favor of declarative ones.</p>
<a class="header" href="print.html#unresolved-questions-66" id="unresolved-questions-66"><h2>Unresolved questions</h2></a>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
<ul>
<li>Start Date: 2018-19-12</li>
<li>Relevant Team(s): Ember.js</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/421</li>
<li>Tracking: https://github.com/emberjs/ember.js/issues/17569</li>
</ul>
<a class="header" href="print.html#deprecate-application-controller-router-properties" id="deprecate-application-controller-router-properties"><h1>Deprecate Application Controller Router Properties</h1></a>
<a class="header" href="print.html#summary-100" id="summary-100"><h2>Summary</h2></a>
<p>This RFC proposes the deprecation of <code>ApplicationController#currentPath</code> and <code>ApplicationController#currentRouteName</code>.</p>
<a class="header" href="print.html#motivation-101" id="motivation-101"><h2>Motivation</h2></a>
<p>These APIs are no longer needed as the <code>RouterService</code> now has <code>RouterService#currentPath</code> and <code>RouterService#currentRouteName</code>.
These fields are only ever present on the application controller which is a weird special casing that we would like to remove.
Additionally, it's likely that there are very few if any consumers of this API as it is not documented.</p>
<a class="header" href="print.html#transition-path-16" id="transition-path-16"><h2>Transition Path</h2></a>
<p>If you are reliant on <code>ApplicationController#currentPath</code> and <code>ApplicationController#currentRouteName</code> you can get the same functionality from the <code>RouterService</code> to migrate, inject the <code>RouterService</code> and read the <code>currentRouteName</code> or <code>currentPath</code> off of it.</p>
<p>Before:</p>
<pre><code class="language-js">// app/controllers/application.js
import Controller from '@ember/controller';
import fetch from 'fetch';

export default Controller.extend({
  store: service('store'),

  actions: {
    sendPayload() {
      fetch('/endpoint', {
        method: 'POST',
        body: JSON.stringify({
          route: this.currentRouteName
        })
      });
    }
  }
})
</code></pre>
<p>After:</p>
<pre><code class="language-js">// app/controllers/application.js
import Controller from '@ember/controller';
import fetch from 'fetch';

export default Controller.extend({
  store: service('store'),
  router: service('router'),

  actions: {
    sendPayload() {
      fetch('/endpoint', {
        method: 'POST',
        body: JSON.stringify({
          route: this.router.currentRouteName
        })
      });
    }
  }
})
</code></pre>
<a class="header" href="print.html#how-we-teach-this-72" id="how-we-teach-this-72"><h2>How We Teach This</h2></a>
<p>There is likely very few consumers of this functionality and migration path is covered by existing documentation.</p>
<a class="header" href="print.html#drawbacks-96" id="drawbacks-96"><h2>Drawbacks</h2></a>
<p>This may introduce churn that we are not aware of.</p>
<a class="header" href="print.html#alternatives-98" id="alternatives-98"><h2>Alternatives</h2></a>
<p>No real alternative other than keep setting the properties.</p>
<a class="header" href="print.html#unresolved-questions-67" id="unresolved-questions-67"><h2>Unresolved questions</h2></a>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
<ul>
<li>Start Date: 2018-01-13</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/431</li>
<li>Tracking Issue: https://github.com/emberjs/rfc-tracking/issues/29</li>
</ul>
<a class="header" href="print.html#restructuring-the-guides-table-of-contents" id="restructuring-the-guides-table-of-contents"><h1>Restructuring the Guides Table of Contents</h1></a>
<a class="header" href="print.html#summary-101" id="summary-101"><h2>Summary</h2></a>
<p>As our favorite framework has grown and changed a lot over the past few years, so have our <a href="https://guides.emberjs.com">Ember.js Guides</a>! This project aims to use the excellent work that has been done by hundreds of contributors and arrange it in a way that provides a natural learning flow for today’s Ember.js developers.</p>
<a class="header" href="print.html#motivation-102" id="motivation-102"><h2>Motivation</h2></a>
<p>With Octane coming down the line, and an influx of fresh attention, it’s more important than ever to consider Ember's overall learning experience. It's time for a shift. The current structure and flow of the guides reflects the past, not the present experience for Ember. It’s time to fix that.</p>
<p>When the Guides were originally written, things like object-oriented programming in JavaScript, components, routing, and Single-Page Applications (<a href="https://en.wikipedia.org/wiki/Single-page_application">SPA</a>) in general were new ideas. For example, they start by teaching the “Ember Objects” programming concept, necessary background information at the time. It would have been an unfamiliar pattern at the time. Now, the learning hierarchy needs have shifted from “learn these unique web development concepts” to “learn how familiar pieces fit together so you can build great apps quickly.”</p>
<a class="header" href="print.html#detailed-design-85" id="detailed-design-85"><h2>Detailed design</h2></a>
<p>The focus of this RFC is not to write new content, but make better use of what is already there by presenting it in a different order. We aim to rearrange the table of contents without breaking any URLs, with refactors necessary to fix the transitions between topics, and with the minimal <em>new</em> content needed to teach Octane. We take care to not make it look like there is “more to learn.”</p>
<p>The overall learning strategy is to establish a common core of sequential knowledge, and then later topics can be read standalone, skipping around. What this means is that if beginners read through to routes, they could skip around the topics lower down the chain successfully.</p>
<p>Finally, it is important to acknowlegde that the Guides are intended to represent the &quot;Happy Path&quot; of using Ember. It is not possible to have something that is a perfect fit for everyone's app needs, nor should they cover our entire API surface.</p>
<a class="header" href="print.html#process-and-preparation" id="process-and-preparation"><h3>Process and preparation</h3></a>
<p>This Table of Contents plan was developed over the course of many months, meetings, and writing sessions. It includes input from many people in the community. Here are the sources of inspiration, information, and planning:</p>
<ul>
<li>Chris Garrett's (<a href="https://github.com/pzuraq">@pzuraq</a>) 2018 Roadmap Blog Post, <a href="https://medium.com/@pzuraq/emberjs-2018-ember-as-a-component-service-framework-2e49492734f1">Ember as a Component-Service Framework</a></li>
<li>My own Roadmap blog post reflections, <a href="https://gist.github.com/jenweber/a9fbea98478fc3841fb8b24f7dc961c8">Be loud and be ready</a></li>
<li>Extensive discussion in Ember Learning Team Meetings, which are held weekly and open to the public</li>
<li>The <a href="https://github.com/emberjs/rfcs/blob/26c4d83fb66568e1087a05818fb39a307ebf8da8/text/0000-roadmap-2018.md">2018 Roadmap RFC</a> by <a href="https://github.com/tomdale">Tom Dale</a></li>
<li>The Octane Strike Team meetings and followup conversations</li>
<li>Hands-on writing of a mini guide for Octane</li>
<li>Ember.js Framework Core Team meetings</li>
<li>A <a href="https://twitter.com/jwwweber/status/1081352702083452928">Twitter poll</a>, &quot;Name two things you think the guides should do well/better&quot;</li>
<li>Discussion on Discord of the initial Table of Contents draft with some key contributors and content creators</li>
<li><a href="https://github.com/cah-danmonroe">Dan Monroe</a>'s trailblazing work to <a href="https://github.com/ember-learn/guides-source/pull/357">convert the Guides to use Angle Brackets</a></li>
<li>Countless hours of Q&amp;A on Stack Overflow and Discord</li>
<li>Experience training new Ember developers in-house</li>
<li>Public Ember 101 workshops run in Boston, Massachusetts, USA</li>
<li>Studying the guides and tutorials of other JavaScript libraries</li>
<li>The successful restructure and rewrite of the <a href="https://cli.emberjs.com">Ember CLI Guides</a> (a far more drastic project than this RFC aims to be)</li>
<li>Attempting to reorder the Guides in a branch, as an experiment</li>
</ul>
<p>We are confident that this is possible thanks to the incredible response and effort shared by the community for the CLI Guides work.</p>
<a class="header" href="print.html#audience" id="audience"><h3>Audience</h3></a>
<p>There are many different types of documentation within Ember, so it's important to identify a target audience for each, in order to guide decision making and provide a learning flow that grows with the reader.</p>
<p>There are 3 main audiences for our resources:</p>
<ol>
<li>newcomers</li>
<li>upgraders</li>
<li>specific-answer-seekers</li>
</ol>
<p>A huge challenge within the Guides is that they somewhat serve all three, and we'd like to have cleaner distinctions between sections and resources. For example, the Quickstart and Tutorials are distinct resources from the rest of the guides, and they clearly target new users. Upgraders could be served by adding 1 section to the guides as they are today. Specific-answer-seekers must lean on both the API docs and the Guides to find what they need.</p>
<p>We propose that the Guides should focus on the following audience - newcomers who have done the tutorial, and want to build real apps. It will show the &quot;happy path&quot; and how the parts of Ember interact to form good, useful patterns, in a way that would be out of scope for an API documentation block.</p>
<p>Along these lines, anything that can be offloaded to the API docs, should. For example, the Guides should show using a Computed Property/tracked property to solve a problem in a Component or Controller. They should not get into the depths of syntax option for one aspect of an API surface, but rather link to them.</p>
<p>We also have the current hypothesis to inform intro sections, as suggested by <a href="https://github.com/mike-north">Mike North</a>: &quot;People want to get the smallest understandable atom that they can jump in on.&quot; This will help us refactor how we present different topics.</p>
<a class="header" href="print.html#table-of-contents-1" id="table-of-contents-1"><h3>Table of Contents</h3></a>
<p>The following Table of Contents will be applied iteratively over the course of many months. It is not considered a blocker for the release of the Octane edition. The quick wins and urgent Octane refactors will be applied ASAP, and are described in the Implementation section of this RFC. Justification for the ordering is provided following the topics list.</p>
<p><strong>Core Concepts</strong></p>
<ul>
<li>What is Ember?</li>
<li>Getting Started</li>
<li>Anatomy of an app (future new content)</li>
</ul>
<p><strong>Fundamentals</strong></p>
<ul>
<li>Templating</li>
<li>Working with JavaScript</li>
<li>Components</li>
<li>Routing (includes Routes, Router, and Controllers)</li>
<li>State management (aka computed properties)</li>
<li>Services</li>
</ul>
<p><strong>Leveling up</strong></p>
<ul>
<li>Data management (future new content that references separate Ember Data guides)</li>
<li>Addons and dependencies</li>
<li>Testing</li>
<li>Configuration</li>
<li>Deploying</li>
<li>Upgrading (will contain links to upgrade resources, Editions, Deprecations)</li>
<li>Developer Tools (currently named Ember Inspector)</li>
<li>Reference
<ul>
<li>Accessibility</li>
<li>Syntax conversion guide</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#topic-naming" id="topic-naming"><h3>Topic naming</h3></a>
<p>As much as possible, we aim for the topics to be named after their general web development concepts, and not the Ember-specific implementation of them.</p>
<a class="header" href="print.html#logic-for-ordering-and-grouping" id="logic-for-ordering-and-grouping"><h3>Logic for ordering and grouping</h3></a>
<p>In this section, we will cover why this order and grouping is being proposed.</p>
<a class="header" href="print.html#groupings" id="groupings"><h4>Groupings</h4></a>
<p>Groupings are added for the benefit of new learners. They break up the content visually and gives them a clue about which sections to pay the most attention to.</p>
<p>Just because something is included in &quot;Leveling up&quot; does not automatically make it an &quot;advanced&quot; topic. The main logic for the division between &quot;Fundamentals&quot; and &quot;Leveling up&quot; are the following tests: Can someone ignore this section and still use Ember effectively? Can it be learned in any order if someone knows the basics? If so, it goes in &quot;Leveling up.&quot;</p>
<p>As we look at each topic, we also ask: Does someone need prior knowledge of another topic in order to understand this section? Whatever those &quot;prior knowledge&quot; topics are, we add them as Fundamentals.</p>
<a class="header" href="print.html#anatomy-of-an-app" id="anatomy-of-an-app"><h4>Anatomy of an app</h4></a>
<p>The most common points of confusion for new devs have become things like “how does everything fit together? Why can't I call a sibling component's actions directly?” The faster we can get the “Mental Model” of Ember across, the better. The Super Rentals tutorial covers the bases well for using the CLI and adding basic interactions. Anecdotally, thanks to the Tutorial, it seems that the missing pieces in the guides are mostly architectural. &quot;Anatomy of an app&quot; is the main area of new content, where we attempt to give an overview of the topics a web developer has to care about, the parts of Ember that address them, and the file structure. Current Ember developers will reference this section while learning new features.</p>
<a class="header" href="print.html#templates--template-helpers" id="templates--template-helpers"><h4>Templates &amp; Template helpers</h4></a>
<p>Templates come before components, since it is possible for someone to not know JavaScript/Handlebars and still contribute to Ember apps. For example, designers could effectively work in only templates, using plain HTML. To make Templates work as the opening topic, additions are necessary in the introduction.</p>
<p>Template Syntax will cover Ember Handlebars basics and built-in features like <code>{{#each}}</code> and <code>{{#if}}</code>. It will take care to make it clear that Ember uses its own implementation of Handlebars. It will clearly differentiate between control structures (loops and conditionals), inline vs block styles, component invocation, and helpers.</p>
<p>Template helpers are split out and moved to &quot;Leveling Up&quot; because developers do not need to use them to write basic Ember apps (they are not a prerequisite). This section includes writing custom Helpers and using built-in helpers like <code>get</code>, <code>let</code>, and <code>array</code>. Although helpers themselves are not considered a difficult topic, they are used most often when developers understand their app's architecture and the flow of data. Also, template helpers have more in common with JavaScript functions than concerns relating to layout and data flow.</p>
<p>Lastly, another reason to split out Template syntax from Template Helpers is because the syntax section is expected to expand with the addition of Octane content.</p>
<p>An alternative to this split is to reduce the documentation of helpers themselves in the Guides, and lean on the API docs instead, however great care should be taken in removing documentation. Without a strong case for it, we lean towards leaving them in the Guides.</p>
<a class="header" href="print.html#working-with-javascript" id="working-with-javascript"><h4>Working with JavaScript</h4></a>
<p>A common concern of new learners is, what is JavaScript and what is special to Ember? The Working with JavaScript section incorporates the existing JavaScript Primer and new content that will help make the distinctions clearer. Ember.js has proactively adopted JavaScript APIs as they become available, such as Classes and Decorators, in some cases before the larger JavaScript community becomes familiar with them. Key people in the Ember Community are also involved in the development of JavaScript itself through TC39. To an extent, it is our responsibility to at least suggest to developers which JavaScript concepts they must learn in order to feel comfortable with Ember.</p>
<a class="header" href="print.html#components-1" id="components-1"><h4>Components</h4></a>
<p>Components will need the most refactor work and new content for Octane, so here’s the subtopic breakdown:</p>
<ul>
<li>Creating a component (includes Component Types post-Octane)</li>
<li>Displaying data in a Template</li>
<li>Adding actions</li>
<li>Nesting components (includes suggestions of when to break things into components)</li>
<li>Passing arguments</li>
<li>Using computed properties (extremely basic example, link to the Computed Property section)</li>
<li>Working with arrays of data</li>
<li>Lifecycle hooks</li>
</ul>
<a class="header" href="print.html#state-management" id="state-management"><h4>State management</h4></a>
<p>The State Management section is important because whether &quot;computed properties&quot; are available in their current state or as <code>@tracked</code> Decorators, the nuances must be within easy reach for existing Ember developers and future learners. We rename this topic in alignment with the Topic Naming convention mentioned above.</p>
<a class="header" href="print.html#routing" id="routing"><h4>Routing</h4></a>
<p>This RFC proposes grouping Routes, Routing, and Controllers under the same topic heading.</p>
<p>If that sounds like a lot, it's because it is. &quot;Routing&quot; is a responsibility that is divided into many pieces:</p>
<ul>
<li>the route declarations in <code>router.js</code>, including dynamic segments</li>
<li>the Handlebars route template, the middleman for passing data from the controller to components</li>
<li>the Route JavaScript file, which contains the model hook for fetching data and Transition rules in the form of hooks. The model hook receives the query params that are defined in the Controller</li>
<li>Controllers, which hold the results of the model hook, actions and other attributes that need to be passed to child components, and query param definitions.</li>
</ul>
<p>Common beginner mistakes are to define actions and attributes in a Route and try to pass them to components, plus attempts to access the result of the model hook in functions in the route JavaScript. Beginners think of Routes as &quot;special components&quot; and are surprised by their limitations. This becomes a long-lived pain point if developers hand off the controller's responsibilities to Components.</p>
<p>For better or for worse, there's a mental-model codependency between Routes and Controllers that is unlikely to change in the near term. Our Guides should reflect the best possible learning experience for today's constraints, rather than be a reflection of the codebase architecture. By grouping these topics together, we have an opportunity to heal confusion over Controllers and help new developers avoid unexpected pitfalls.</p>
<p>Based on initial feedback, this grouping is the most divisive part of the proposal. This grouping is informed by reflecting on how one might teach Controllers to a new developer, while working together in person. In order to reach consensus, any objections to the grouping should suggest solutions that include an explanation of how and where one would teach Routes, actions, routing with Query params, and passing arguments to the model hook.</p>
<a class="header" href="print.html#services" id="services"><h4>Services</h4></a>
<p>The Services documentation is currently sparse, but it is included in &quot;Fundamentals&quot; for two reasons. First, an understanding of Services is a prerequisite for understanding Ember Data's store service. Second, the Router service is not well known by new developers, as it is solely found in the API documentation, and it provides behavior that new developers expect to have. Third, the popularity of the mental model of Ember as a Components-Services framework is a signal that this may be an effective teaching strategy.</p>
<a class="header" href="print.html#ember-data-1" id="ember-data-1"><h4>Ember Data</h4></a>
<p>Ember Data will be gradually extracted into its own Guides. 2-3 years ago, there was a push to provide better official documentation of Ember Data, as a &quot;first class citizen.&quot; It was intermingled with the rest of the Ember.js Guides as a result. We will continue to treat Ember Data as a first class citizen, yet with improved separation of concerns similar to the approach to Ember CLI Guides. Ultimately, the content in other Guides topics will be refactored to show both Ember Data and non-Ember Data approaches, in an effort to lower the perceived cognitive overhead of Ember.</p>
<p>This change reflects the overall drive of the JavaScript Ecosystem towards interchangeable, composable parts.</p>
<p>The Ember Data team is especially requested to review this shift and provide feedback.</p>
<a class="header" href="print.html#deploying-and-upgrading" id="deploying-and-upgrading"><h4>Deploying and Upgrading</h4></a>
<p>These sections have some existing content. They will aim to <em>not</em> duplicate the contents of the CLI Guides, but rather reference content found there. They are included in the top-level Table of Contents for two readons, discoverability and to showcase Ember's strengths</p>
<a class="header" href="print.html#ember-inspector" id="ember-inspector"><h4>Ember Inspector</h4></a>
<p>Although the Ember.js Guides are versioned, the Inspector Guides do not need to follow the same versioning strategy. It would be reasonable to separate them out into their own, unversioned Guides. However the content is quite stable and therefore lower priority than other refactors.</p>
<p>The Ember Inspector team is requested to consider whether naming the section &quot;Debugging&quot; would improve discoverability of Ember Inspector for new developers, and whether the eventual unversioned separation aligns with expected technical development.</p>
<a class="header" href="print.html#unchanged-topics" id="unchanged-topics"><h4>Unchanged topics</h4></a>
<p>Configuration, Testing, and Addons &amp; Dependencies remain unchanged in their approach. There are plans underway to make the Tutorial an unversioned, separate resource. That is outside the scope of this RFC, however this Table of Contents assumes that work comes to completion.</p>
<a class="header" href="print.html#removals" id="removals"><h4>Removals</h4></a>
<p>Notably missing is &quot;Ember Object Model.&quot; This is on purpose. It will be pulled into other sections, in a “show, don’t tell” kind of approach. Also removed is &quot;Application Concerns,&quot; which are separated into their appropriate alternate subtopics.</p>
<a class="header" href="print.html#why-doesnt-this-rfc-include-rewriting-content" id="why-doesnt-this-rfc-include-rewriting-content"><h3>Why doesn’t this RFC include rewriting content?</h3></a>
<p>Individual pages have already been refactored over the past two years by many contributors. Examples include the Ember Objects page, Controllers, using third party libraries, and explanations of data management. Many of the pain points that current Ember devs remember from their early days have been fixed. For example, it’s clear that Ember Data/JSONAPI aren’t mandatory, that you <em>can</em> use things like fetch, that Computed Properties need to be consumed for them to fire… we’re in a pretty good place! Those improvements of individual topics may continue without the need for an RFC.</p>
<p>If we choose a good structure for the Table of Contents, it will make it much easier to write/rewrite individual sections.</p>
<p>It is also important to note here that that Ember does not have a foundation or funding arm, so although it would be great to have a dedicated writer tackle this from the ground up, we must choose an approach that would be realistic for a group of volunteers to achieve.</p>
<a class="header" href="print.html#technical-approach" id="technical-approach"><h3>Technical approach</h3></a>
<p>Thanks to Chris Manson’s work (<a href="https://github.com/mansona">@real_ate aka @mansona</a>) on the Guides app architecture, we can move content around while preserving existing links! The Table of Contents specified in the <code>pages.yml</code> file of guides-source can have any paths, and is not 100% dependent on the physical file structure to create URLs. It is very important that we don’t break existing blog articles, community tutorials, Stack Overflow answers, etc, both for user experience and SEO reasons.</p>
<p>All guides content is markdown. When we rearrange content, we’ll have to change some links and add redirects. However there are tests in place that check for bad links, so we can do this confidently.</p>
<a class="header" href="print.html#how-we-teach-this-73" id="how-we-teach-this-73"><h2>How we teach this</h2></a>
<p>Community buy-in is important to reduce perception of churn and make “leveling up” our resources a team effort. Significant attention will be put towards informing the community of upcoming changes, and giving them the opportunity to participate.</p>
<p>We will also test major changes with beginner-level developers and developers who don’t know Ember. Although the rollout for the live site will take months, a rough cut, undeployed, could be completed in 1-2 weeks. It could serve as a North Star for the work to be done.</p>
<a class="header" href="print.html#implementation-plan-1" id="implementation-plan-1"><h3>Implementation plan</h3></a>
<p>This work will need to be done incrementally over many months/the next year. It will be communicated in the form of Quest issues, with help requested via the Ember Times, Discord, Discuss, etc.</p>
<p>Community members will be asked to participate in PR reviews. A diversity of technical experience levels, language backgrounds, and use case perspectives will create a stronger output.</p>
<p>The intial steps will aim for the quick wins and the urgent changes that aid in Octane documentation.</p>
<p>Here's what we could expect a minimal first pass to look like:</p>
<ul>
<li>What is Ember?</li>
<li>Getting Started</li>
<li>Tutorial (already in progress of being split out)</li>
<li>Templates</li>
<li>Components</li>
<li>Routing (includes Routes, Router, and Controllers)</li>
<li>State management (aka computed properties)</li>
<li>Services</li>
<li>Ember Data (renamed from &quot;Models&quot;)</li>
<li>Addons and dependencies</li>
<li>Testing</li>
<li>Configuration</li>
<li>Application Concerns</li>
<li>Ember Inspector</li>
</ul>
<p>The groupings like &quot;Fundamentals&quot; require architectural work on the guides app. They can be done in parallel depending on volunteer capacity and interest, or delayed until the end.</p>
<a class="header" href="print.html#drawbacks-97" id="drawbacks-97"><h2>Drawbacks</h2></a>
<p>This refactor is biased towards new user experience, so existing Ember users could experience the most drawbacks.</p>
<ol>
<li>They will need to discover where old content lives. This is mitigated by the site search, which is now stabilized</li>
<li>Experienced developers who haven’t looked at the Guides for a long time will all reference it during the Octane upgrade, and may be surprised to find a new layout. It’s another “new thing to learn.” This is mitigated by consolidating most of the new things to learn into the Components section</li>
<li>There will likely be some wrinkles to iron out with regards to content that should have been refactored during rearranging, but was overlooked. We are confident that the community will help identify these issues.</li>
</ol>
<a class="header" href="print.html#alternatives-99" id="alternatives-99"><h2>Alternatives</h2></a>
<p>The main architectural pattern choices were as follows:</p>
<ol>
<li>On one extreme, make every section standalone</li>
<li>The middle ground, establish a “Common Core” to be read sequentially, and then have standalone sections that rely on knowledge of the core</li>
<li>The other extreme, make the entire guides sequential</li>
</ol>
<p>We choose the middle ground, because it requires the least new writing, and if we chose to move towards one of the other extremes, it does not prevent that choice nor would we throw away work.</p>
<p>It’s also useful to study the learning flow of other front end libraries in order to determine possible alternatives. Let’s look at a few.</p>
<a class="header" href="print.html#react" id="react"><h3>React</h3></a>
<p>React is known for having low learning overhead for someone who is making their first app. With its popularity, we can guess that new users may expect to find similar topics easily accessible in our guides. This list is most useful for considering what should be in our Components section.</p>
<ol>
<li>Hello World</li>
<li>Introducing JSX</li>
<li>Rendering Elements</li>
<li>Components and Props</li>
<li>State and Lifecycle</li>
<li>Handling Events</li>
<li>Conditional Rendering</li>
<li>Lists and Keys</li>
<li>Forms
<ol>
<li>Lifting State Up</li>
<li>Composition vs Inheritance</li>
<li>Thinking In React</li>
</ol>
</li>
</ol>
<p>The Overview section of the React Tutorial also helps show what we may be missing:</p>
<ul>
<li>What Is React?</li>
<li>Inspecting the Starter Code</li>
<li>Passing Data Through Props</li>
<li>Making an Interactive Component</li>
<li>Developer Tools</li>
</ul>
<p>Nowhere on our current site do we have a highly visible explanation of what Ember is, beyond snippets. In light of this glaring omission, we have added a “What is Ember” section to the Guides Table of Contents above. It is not meant to replace the ongoing “Why Ember” and marketing-focused descriptions that are underway.</p>
<a class="header" href="print.html#vue" id="vue"><h3>Vue</h3></a>
<p>As a fully-featured framework, Vue is an easier comparison for possible Table of Contents listings. Keep in mind that much of this type of content is present in our CLI docs instead, so this list will look longer than what we are aiming for.</p>
<ul>
<li>Introduction</li>
<li>What is Vue.js?</li>
<li>Getting Started</li>
<li>Declarative Rendering</li>
<li>Conditionals and Loops</li>
<li>Handling User Input</li>
<li>Composing with Components</li>
<li>Relation to Custom Elements</li>
<li>Ready for More?</li>
<li>The Vue Instance</li>
<li>Template Syntax</li>
<li>Computed Properties and Watchers</li>
<li>Class and Style Bindings</li>
<li>Conditional Rendering</li>
<li>List Rendering</li>
<li>Event Handling</li>
<li>Form Input Bindings</li>
<li>Components Basics</li>
<li>Components In-Depth</li>
<li>Component Registration</li>
<li>Props</li>
<li>Custom Events</li>
<li>Slots</li>
<li>Dynamic &amp; Async Components</li>
<li>Handling Edge Cases</li>
<li>Transitions &amp; Animation</li>
<li>Enter/Leave &amp; List Transitions</li>
<li>State Transitions</li>
<li>Reusability &amp; Composition</li>
<li>Mixins</li>
<li>Custom Directives</li>
<li>Render Functions &amp; JSX</li>
<li>Plugins</li>
<li>Filters</li>
<li>Tooling</li>
<li>Single File Components</li>
<li>Unit Testing</li>
<li>TypeScript Support</li>
<li>Production Deployment</li>
<li>Scaling Up</li>
<li>Routing</li>
<li>State Management</li>
<li>Server-Side Rendering</li>
<li>Internals</li>
<li>Reactivity in Depth</li>
<li>Migrating</li>
<li>Migration from Vue 1.x</li>
<li>Migration from Vue Router 0.7.x</li>
<li>Migration from Vuex 0.6.x to 1.0</li>
<li>Meta</li>
<li>Comparison with Other Frameworks</li>
<li>Join the Vue.js Community!</li>
<li>Meet the Team</li>
</ul>
<p>One possible lesson here is that we could split up Components like Vue did with Component Basics and Components In-Depth. Their dedicated section on Computed Properties inspired the inclusion in our new Table of Contents.</p>
<a class="header" href="print.html#angular" id="angular"><h3>Angular</h3></a>
<p>Angular is also a full-featured framework that has a lot in common with Ember.</p>
<p>FUNDAMENTALS</p>
<ul>
<li>Architecture
<ul>
<li>Architecture Overview</li>
<li>Intro to Modules</li>
<li>Intro to Components</li>
<li>Intro to Services and DI</li>
<li>Next Steps</li>
</ul>
</li>
<li>Components &amp; Templates
<ul>
<li>Displaying Data</li>
<li>Template Syntax</li>
<li>User Input</li>
<li>Lifecycle Hooks</li>
<li>Component Interaction</li>
<li>Component Styles</li>
<li>Angular Elements</li>
<li>Dynamic Components</li>
<li>Attribute Directives</li>
<li>Structural Directives</li>
<li>Pipes</li>
</ul>
</li>
<li>Forms</li>
<li>Observables &amp; RxJS</li>
<li>Bootstrapping</li>
<li>NgModules</li>
<li>Dependency Injection</li>
<li>HttpClient</li>
<li>Routing &amp; Navigation</li>
<li>Animations</li>
</ul>
<p>SETUP &amp; DEPLOYMENT</p>
<ul>
<li>Project File Structure</li>
<li>Workspace Configuration</li>
<li>npm Dependencies</li>
<li>TypeScript Configuration</li>
<li>Ahead-of-Time Compilation</li>
<li>Building &amp; Serving</li>
<li>Testing</li>
<li>Deployment</li>
<li>Browser Support</li>
<li>Dev Tool Integration</li>
</ul>
<p>Angular is the closest match to our current guides structure. Notably, they work Styles in as part of their Components section.</p>
<a class="header" href="print.html#trends" id="trends"><h3>Trends</h3></a>
<p>All three of the libraries above cover forms in their own dedicated section. They also cover styles and animation, which we do not cover at all. These are all good candidates for future guides.</p>
<a class="header" href="print.html#unresolved-questions-68" id="unresolved-questions-68"><h2>Unresolved questions</h2></a>
<ul>
<li>What does the community think of this structure? How can it be improved?</li>
<li>Is it good for new learners? Is it good for existing users?</li>
<li>What possible pain points does the community see?</li>
<li>Are there any areas missing from the Table of Contents?</li>
<li>What do people think of removing the “Ember Object Model” section?</li>
<li>Are the goals of the Ember Data and Ember Inspector teams supported by this new layout?</li>
</ul>
<a class="header" href="print.html#one-last-note" id="one-last-note"><h3>One last note</h3></a>
<p>The Guides are one of those things where everyone has an opinion, and that's ok! However, as a reminder, please be kind and constructive in your comments. The Guides and the tools they cover are the work of many dedicated community members. They are authored and maintained through donated effort, both by unpaid individuals and companies who encourage their teams to contribute. Although we always know there is room for improvement, we are proud of where we came from and excited for where we're going next!</p>
<ul>
<li>Start Date: 2018-12-17</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/432</li>
<li>Ember Issue: (leave this empty)</li>
</ul>
<a class="header" href="print.html#contextual-helpers-and-modifiers-aka-first-class-helpersmodifiers" id="contextual-helpers-and-modifiers-aka-first-class-helpersmodifiers"><h1>Contextual Helpers and Modifiers (a.k.a. &quot;first-class helpers/modifiers&quot;)</h1></a>
<a class="header" href="print.html#summary-102" id="summary-102"><h2>Summary</h2></a>
<p>We propose to extend the semantics of Handlebars helpers and modifiers such
that they can be passed around as first-class values in templates.</p>
<p>For example:</p>
<pre><code class="language-hbs">{{join-words &quot;foo&quot; &quot;bar&quot; &quot;baz&quot; separator=&quot;,&quot;}}

{{!-- ...is functionally equivalent to... --}}

{{#let (helper &quot;join-words&quot; separator=&quot;,&quot;) as |join|}}
  {{#let (helper join &quot;foo&quot;) as |foo|}}
    {{#let (helper foo &quot;bar&quot;) as |foo-bar|}}
      {{foo-bar &quot;baz&quot;}}
    {{/let}}
  {{/let}}
{{/let}}
</code></pre>
<pre><code class="language-hbs">&lt;Submit {{on
  click=(action &quot;submit&quot;)
  mouseenter=(action &quot;highlight&quot;)
  mouseleave=(action &quot;unhighlight&quot;)
}} /&gt;

{{!-- ...is functionally equivalent to... --}}

{{#let (modifier &quot;on&quot;) as |on|}}
  {{#let (modifier on click=(action &quot;submit&quot;)) as |on-click|}}
    {{#let (modifier on-click mouseenter=(action &quot;highlight&quot;)) as |on-click-enter|}}
      {{#let (modifier on-click-enter mouseleave=(action &quot;unhighlight&quot;)) as |on-click-enter-leave|}}
        &lt;Submit {{on-click-enter-leave}} /&gt;
      {{/let}}
    {{/let}}
  {{/let}}
{{/let}}
</code></pre>
<a class="header" href="print.html#motivation-103" id="motivation-103"><h2>Motivation</h2></a>
<p><a href="https://github.com/emberjs/rfcs/pull/64">RFC #64</a> introduced a feature known
as &quot;contextual components&quot;, which allowed components to be passed around as
first-class values. While this is a somewhat advanced feature, it allowed addon
authors to encapsulate internal state and logic, which in turns, allowed them
to create easy-to-use and easy-to-understand DSL-like APIs that could benefit
users of all level.</p>
<p>For example, the original RFC used form controls as a motivating example.
Without contextual components, an addon that provides form-building components
might have to expose an API like this:</p>
<pre><code class="language-hbs">&lt;SuperForm @model={{this.post}} as |f|&gt;
  &lt;SuperInput @model={{this.post}} @name=&quot;title&quot; /&gt;
  &lt;SuperTextarea @model={{this.post}} @name=&quot;body&quot; /&gt;
  &lt;SuperSubmit @form={{f}} /&gt;
&lt;/SuperForm&gt;
</code></pre>
<p>As you can see, this is far from ideal for several reasons. First, to avoid
collision, the addon author had to prefix all the components. Second, the
<code>@model</code> argument has to be passed to all the controls that needs it. Finally,
in cases where the components need to communicate with each other (the form and
the submit button in the example), they would have to expose some internal state
(the <code>|f|</code> block param) that the user would have to manually thread through. Not
only does this make the API very verbose, it also breaks encapsulation.</p>
<p>Instead, the contextual components feature allows the addon author to expose an
API like this:</p>
<pre><code class="language-hbs">&lt;SuperForm @model={{this.post}} as |f|&gt;
  &lt;f.Input @name=&quot;title&quot; /&gt;
  &lt;f.Textarea @name=&quot;body&quot; /&gt;
  &lt;f.Submit /&gt;
&lt;/SuperForm&gt;
</code></pre>
<p>Behind the scene, the <code>&lt;SuperForm&gt;</code> component's template would look something
like this:</p>
<pre><code class="language-hbs">&lt;form ...&gt;
  {{yield (hash
    Input=(component &quot;super-input&quot; form=this model=this.model)
    Textarea=(component &quot;super-textarea&quot; form=this model=this.model)
    Submit=(component &quot;super-submit&quot; form=this model=this.model)
  )}}
&lt;/form&gt;
</code></pre>
<p>Here, the <code>component</code> helper looked up the components by name (first argument)
and packaged up (&quot;curried&quot;) any additional arguments (<code>form=this</code>) into an
internal object (known as a &quot;component definition&quot; in the Glimmer VM). This
object can then be passed around like any other values and invoked at a later
time.</p>
<p>(Typically, a number of them are passed to the <code>hash</code> helper to &quot;bundle&quot; them
into a single object, but this is not required.)</p>
<p>While this is indeed a pretty advanced feature, the users of <code>SuperForm</code> do not
need to be aware of these implementation details in order to use the addon.
This had proved to be a very useful and powerful feature and enabled a number
of popular addons, such as
<a href="https://ember-learn.github.io/ember-cli-addon-docs/">ember-cli-addon-docs</a>,
<a href="https://www.ember-bootstrap.com">ember-bootstrap</a>,
<a href="https://opensource.addepar.com/ember-table/">ember-table</a>,
<a href="https://miguelcobain.github.io/ember-paper/">ember-paper</a>,
<a href="https://ember-power-calendar.com">ember-power-calendar</a>,
<a href="http://khorus.github.io/ember-accordion/">ember-accordion</a>,
<a href="https://emberx-select.netlify.com/">emberx-select</a>,
<a href="https://offirgolan.github.io/ember-light-table/">ember-light-table</a>.</p>
<p>The original RFC left an important question unanswered – <a href="https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md#unresolved-questions">should this feature
be available for helpers, too?</a></p>
<p>In this RFC, we argue – yes, this feature will be just as useful for helpers as
well as modifiers.</p>
<p>For example, the <code>SuperForm</code> addon API can be expanded to include some extra
helpers and modifiers, like so:</p>
<pre><code class="language-hbs">&lt;SuperForm @model={{this.post}} as |f|&gt;
  &lt;f.Input @name=&quot;title&quot; /&gt;

  {{!-- f.is-valid and f.error-for are contextual helpers --}}
  {{#unless (f.is-valid &quot;title&quot;)}}
    &lt;div class=&quot;error&quot;&gt;This field {{f.error-for &quot;title&quot;}}&lt;/div&gt;
  {{/unless}}

  {{!-- f.auto-resize is a contextual modifier --}}
  &lt;f.Textarea @name=&quot;body&quot; {{f.auto-resize maxHeight=&quot;500&quot;}} /&gt;

  &lt;f.Submit /&gt;
&lt;/SuperForm&gt;
</code></pre>
<p>For reference, the <code>&lt;SuperForm&gt;</code> component's template would look something like
this:</p>
<pre><code class="language-hbs">&lt;form ...&gt;
  {{yield (hash
    is-valid=(helper &quot;super-is-valid&quot; form=this model=this.model)
    error-for=(helper &quot;super-error-for&quot; form=this model=this.model)
    auto-resize=(modifier &quot;super-auto-resize&quot;)
    ...
  )}}
&lt;/form&gt;
</code></pre>
<p>This RFC proposes a complete design for enabling this capability.</p>
<a class="header" href="print.html#detailed-design-86" id="detailed-design-86"><h2>Detailed design</h2></a>
<a class="header" href="print.html#the-helper-and-modifier-helpers" id="the-helper-and-modifier-helpers"><h3>The <code>helper</code> and <code>modifier</code> helpers</h3></a>
<p>This RFC introduces two new helpers named <code>helper</code> and <code>modifier</code>, which work
similarly to the <code>component</code> helper:</p>
<ul>
<li>
<p>When passed a string (e.g. <code>(helper &quot;foo&quot;)</code>) as the first argument, it will
produce an opaque, internal &quot;helper definition&quot; or &quot;modifier definition&quot;
object that can be passed around and invoked elsewhere.</p>
</li>
<li>
<p>Any additional positional and/or named arguments (a.k.a. params and hash)
will be stored (&quot;curried&quot;) inside the definition object, such that, when
invoked, these arguments will be passed along to the referenced helper or
modifier.</p>
</li>
</ul>
<p>Some additional details:</p>
<ul>
<li>
<p>When the first argument passed to the <code>helper</code> or <code>modifier</code> helper is
<code>null</code>, <code>undefined</code> or an empty string, it will produce a no-op definition
object. In the case of the <code>helper</code> helper, this will produce <code>undefined</code>
when invoked, regardless of the arguments that are passed to the invocation.
In the case of the <code>modifier</code> helper, it will not perform any operations on
the target element.</p>
</li>
<li>
<p>When the first argument passed to the <code>helper</code> or <code>modifier</code> helper is a
string, it will be used to resolve a helper or modifier (respectively) with
the same name. If the resolution failed, it will result in a runtime error.
However, the timing of this lookup is unspecified. <code>(helper &quot;not-a-helper&quot;)</code>
may result in an immediate error, or it may happen when it is later passed
into the <code>helper</code> helper a second time, or it may happen when it is invoked.
If it is never invoked, the error may not be reported at all. This timing may
change between releases and should not be relied upon.</p>
</li>
<li>
<p>Some built-in helpers or modifiers may not be resolvable with the <code>helper</code>
and <code>modifier</code> helpers. For example, <code>(helper &quot;debugger&quot;)</code> and
<code>(helper &quot;yield&quot;)</code> will not work, as they are considered <em>keywords</em>. For
implementation simplicity, we propose to forbid resolving built-in helpers,
components and modifiers this way across the board (i.e. a runtime error).
We acknowledge that there are good use cases for this feature such as
currying the <code>array</code> and <code>hash</code> helpers, and will consider enabling them in
the future on a case-by-case basis.</p>
</li>
<li>
<p>Similarly, contextual helpers cannot be named after certain keywords. For
example, <code>{{#let ... as |yield|}} {{yield}} {{/let}}</code> will not work. We
propose to turn these cases into syntax errors.</p>
</li>
<li>
<p>A contextual helper or modifier can be further &quot;curried&quot; by passing them back
into the <code>helper</code> or <code>modifier</code> helper again, as shown in the example in the
<a href="print.html#Summary">summary</a> section. This will produce a new definition object.</p>
</li>
<li>
<p>When the first argument passed to the <code>helper</code> or <code>modifier</code> helper is a
bound value, a new definition object will be produced whenever the value
changes. This will <em>invalidate</em> all downstream invocations. If the previous
value is a <a href="https://emberjs.com/api/ember/3.7/functions/@ember%2Fcomponent%2Fhelper/helper">simple helper</a>,
this has no observable effect and Ember will simply invoke the new helper
value. If the previous value is a <a href="https://emberjs.com/api/ember/3.7/classes/Helper">class-based helper</a>,
or a modifier, the existing instance will be destroyed before the new value
is invoked. On the other hand, if only the curried arguments has changed, the
helper or modifier instances (if any) will remain.</p>
</li>
<li>
<p>An important implication of the teardown semantics is that it is possible for
a modifier to be destroyed while its target element lives on for much longer.
Therefore, it is important to actually teardown any event listeners and
cleanup any associated states in the <code>destroyModifier</code> hook.</p>
</li>
<li>
<p>Positional arguments are &quot;curried&quot; the same way as the <code>component</code> helper.
This matches the behavior of <code>Function.prototype.bind</code>.</p>
<pre><code class="language-hbs">{{#let (helper &quot;join-words&quot; separator=&quot;,&quot;) as |join|}}
  {{join &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;}} {{!-- &quot;foo,bar,baz&quot; --}}

  {{#let (helper join &quot;foo&quot;) as |foo|}}
    {{foo &quot;bar&quot; &quot;baz&quot;}} {{!-- &quot;foo,bar,baz&quot; --}}

    {{#let (helper foo &quot;bar&quot;) as |foo-bar|}}
      {{foo-bar &quot;baz&quot;}} {{!-- &quot;foo,bar,baz&quot; --}}
    {{/let}}

  {{/let}}

{{/let}}
</code></pre>
</li>
<li>
<p>Named arguments are curried the same way as the <code>component</code> helper.
This matches the &quot;last-write-wins&quot; behavior of <code>Object.assign</code>.</p>
<pre><code class="language-hbs">{{#let (helper &quot;join-words&quot; &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;) as |join|}}
  {{join separator=&quot;,&quot;}} {{!-- foo,bar,baz --}}

  {{#let (helper join separator=&quot;,&quot;) as |comma|}}
    {{comma separator=&quot; &quot;}} {{!-- foo bar baz --}}

    {{#let (helper comma separator=&quot; &quot;) as |space|}}
      {{space separator=&quot;-&quot;}} {{!-- foo-bar-baz --}}
    {{/let}}

  {{/let}}

{{/let}}
</code></pre>
</li>
<li>
<p>When a definition object is passed into JavaScipt (e.g. as an argument to a
JavaScript helper), the resulting value is unspecified (hence &quot;opaque&quot;). In
particular, for helpers, it is <em>not</em> guarenteed that it will be an invokable
JavaScript function. The only guarentee provided is that, when passed back
into Handlebars it will be an invokable value. Hanging onto a definition
object in JavaScript may result in unexpected memory leaks, as these objects
may close over arbitrary template states.</p>
</li>
</ul>
<a class="header" href="print.html#invoking-contextual-helpers" id="invoking-contextual-helpers"><h3>Invoking contextual helpers</h3></a>
<p>Invoking a contextual helper is no different from invoking any other helpers:</p>
<pre><code class="language-hbs">{{#let (helper &quot;join-words&quot; &quot;foo&quot; &quot;bar&quot; separator=&quot; &quot;) as |foo-bar|}}

  {{!-- content position --}}

  {{foo-bar}}

  {{foo-bar &quot;baz&quot;}}

  {{foo-bar separator=&quot;,&quot;}}

  {{!-- not necessary, but works --}}

  {{helper foo-bar}}

  {{helper foo-bar &quot;baz&quot;}}

  {{helper foo-bar separator=&quot;,&quot;}}

  {{!-- attribute position --}}

  &lt;div class={{foo-bar}}&gt;...&lt;/div&gt;

  &lt;div class={{foo-bar &quot;baz&quot;}}&gt;...&lt;/div&gt;

  &lt;div class={{foo-bar separator=&quot;,&quot;}}&gt;...&lt;/div&gt;

  {{!-- not necessary, but works --}}

  &lt;div class={{helper foo-bar}}&gt;...&lt;/div&gt;

  &lt;div class={{helper foo-bar &quot;baz&quot;}}&gt;...&lt;/div&gt;

  &lt;div class={{helper foo-bar separator=&quot;,&quot;}}&gt;...&lt;/div&gt;

  {{!-- curly invocation, argument position --}}

  {{my-component value=(foo-bar)}}

  {{my-component value=(foo-bar &quot;baz&quot;)}}

  {{my-component value=(foo-bar separator=&quot;,&quot;)}}

  {{!-- these will pass the helper itself into the component, instead of invoking it now --}}

  {{my-component helper=foo-bar}}

  {{my-component helper=(helper foo-bar)}}

  {{my-component helper=(helper foo-bar &quot;baz&quot;)}}

  {{my-component helper=(helper foo-bar separator=&quot;,&quot;)}}

  {{!-- angle bracket invokation, argument position --}}

  &lt;MyComponent @value={{(foo-bar)}} /&gt;

  &lt;MyComponent @value={{foo-bar &quot;baz&quot;}} /&gt;

  &lt;MyComponent @value={{foo-bar separator=&quot;,&quot;}} /&gt;

  {{!-- these will pass the helper itself into the component, instead of invoking it now --}}

  &lt;MyComponent @helper={{foo-bar}} /&gt;

  &lt;MyComponent @helper={{helper foo-bar}} /&gt;

  &lt;MyComponent @helper={{helper foo-bar &quot;baz&quot;}} /&gt;

  &lt;MyComponent @value={{helper foo-bar separator=&quot;,&quot;}} /&gt;

  {{!-- sub-expression positions --}}

  {{yield (foo-bar)}}

  {{yield (foo-bar &quot;baz&quot;)}}

  {{yield (foo-bar separator=&quot;,&quot;)}}

  {{!-- these will yield the helper itself (&quot;contextual helper&quot;), instead of invoking it now --}}

  {{yield foo-bar}}

  {{yield (helper foo-bar)}}

  {{yield (helper foo-bar &quot;baz&quot;)}}

  {{yield (helper foo-bar separator=&quot;,&quot;)}}

  {{!-- deeply nested sub-expression --}}

  {{#if (eq (concat &quot;&gt;&gt;&gt; &quot; (foo-bar &quot;baz&quot;) &quot; &lt;&lt;&lt;&quot;) &quot;&gt;&gt;&gt; foo bar baz &lt;&lt;&lt;&quot;)}}
    This is true.
  {{/if}}

  {{!-- runtime error: not a component --}}
  &lt;foo-bar /&gt;

  {{!-- runtime error: not a modifier --}}
  &lt;div {{foo-bar}}&gt;
{{/let}}
</code></pre>
<a class="header" href="print.html#invoking-contextual-modifiers" id="invoking-contextual-modifiers"><h3>Invoking contextual modifiers</h3></a>
<p>Invoking a contextual helper is no different from invoking any other modifiers:</p>
<pre><code class="language-hbs">{{#let (modifier &quot;on&quot; click=(action &quot;submit&quot;)) as |on-click|}}

  {{!-- HTML elements --}}

  &lt;button {{on-click}}&gt;Click Me!!&lt;/button&gt;

  &lt;button {{on-click &quot;extra&quot; &quot;args&quot;}}&gt;Click Me!!&lt;/button&gt;

  &lt;button {{on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}}&gt;
    Click Me!!
  &lt;/button&gt;

  {{!-- not necessary, but works --}}

  &lt;button {{modifier on-click}}&gt;Click Me!!&lt;/button&gt;

  &lt;button {{modifier on-click &quot;extra&quot; &quot;args&quot;}}&gt;Click Me!!&lt;/button&gt;

  &lt;button {{modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}}&gt;
    Click Me!!
  &lt;/button&gt;

  {{!-- components --}}

  &lt;MyComponent {{on-click}} /&gt;

  &lt;MyComponent {{on-click &quot;extra&quot; &quot;args&quot;}} /&gt;

  &lt;MyComponent {{on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}} /&gt;

  {{!-- not necessary, but works --}}

  &lt;MyComponent {{modifier on-click}} /&gt;

  &lt;MyComponent {{modifier on-click &quot;extra&quot; &quot;args&quot;}} /&gt;

  &lt;MyComponent {{modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}} /&gt;

  {{!-- these will pass the modifier itself into the component, instead of invoking it now --}}

  &lt;MyComponent @modifier={{on-click}} /&gt;

  &lt;MyComponent @modifier={{modifier on-click}} /&gt;

  &lt;MyComponent @modifier={{modifier on-click &quot;extra&quot; &quot;args&quot;}} /&gt;

  &lt;MyComponent @modifier={{modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}} /&gt;

  {{my-component modifier=on-click}}

  {{my-component modifier=(modifier on-click)}}

  {{my-component modifier=(modifier on-click &quot;extra&quot; &quot;args&quot;)}}

  {{my-component modifier=(modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;))}}

  {{!-- these will yield the modifier itself (&quot;contextual modifier&quot;), instead of invoking it now --}}

  {{yield on-click}}

  {{yield (modifier on-click)}}

  {{yield (modifier on-click &quot;extra&quot; &quot;args&quot;)}}

  {{yield (modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;))}}

  {{!-- runtime error: cannot invoke a modifier as a helper --}}

  {{yield (on-click)}}

  {{yield (on-click &quot;extra&quot; &quot;args&quot;)}}

  {{yield (on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;))}}

  {{!-- runtime error: cannot append a modifier --}}

  {{on-click}}

  {{on-click &quot;extra&quot; &quot;args&quot;}}

  {{on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}}

  {{!-- runtime error: cannot set an attribute to a modifier --}}

  &lt;div class={{on-click}} /&gt;

  &lt;div class={{on-click &quot;extra&quot; &quot;args&quot;}} /&gt;

  &lt;div class={{on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}} /&gt;

  {{!-- runtime error: not a component --}}
  &lt;on-click /&gt;
{{/let}}
</code></pre>
<a class="header" href="print.html#relationship-with-globals" id="relationship-with-globals"><h3>Relationship with globals</h3></a>
<p>Today, Ember apps rely heavily on the global namespace as the main mechanism of
making components, helpers and modifiers available. Ideally, in a world where
&quot;everything is a value&quot;, the global and local namespace should behave the same
way. Global components, helpers and modifiers should just be global variables
that are implicitly defined around every templates in the app.</p>
<p>In other words, it is as if every template has the following hidden &quot;prelude&quot;
around its content:</p>
<pre><code class="language-hbs">{{!-- prelude --}}
{{#let (component &quot;input&quot;) as |input|}}
  {{#let (helper &quot;concat&quot;) as |concat|}}
    {{#let (modifier &quot;action&quot;) as |action|}}
      {{!-- ...other global components, helpers and modifiers omitted... --}}

      {{!-- begin template content --}}
      Your name:
      {{concat this.firstName &quot; &quot; this.lastName}}

      Change it:
      {{input value=this.firstName}}
      {{input value=this.lastName}}

      &lt;button {{action &quot;submit&quot;}}&gt;&lt;/button&gt;
      {{!-- end tempalte content ---}}
    {{/let}}
  {{/let}}
{{/let}}
</code></pre>
<p>While this largely matches how things work today, there are a few notable
differences where globals behave &quot;unexpectedly&quot; in this world.</p>
<p>First of all, it is not possible to reference a component, helper or modifier
in templates without invoking them today:</p>
<pre><code class="language-hbs">{{!-- if `join-words` is a global helper, this works as expected --}}
{{!-- this invokes the helper and yield the result --}}

{{yield (join-words &quot;foo&quot; &quot;bar&quot; separator=&quot;,&quot;)}}
         ~~~~~~~~~~

{{!-- however, in this position, Ember does not &quot;see&quot; the helper --}}
{{!-- this falls back to looking up the `join-words` property on `this` --}}

{{yield join-words}}
        ~~~~~~~~~~

{{!-- as opposed to a &quot;true&quot; variable/value binding... --}}
{{!-- this yields the helper as a value, as expected --}}

{{#let (helper &quot;join-words&quot;) as |join-words|}}
  {{yield join-words}}
          ~~~~~~~~~~
{{/let}}
</code></pre>
<p>In the long term, we propose to unify the semantics such that globals will
behave exactly like local bindings (i.e. we should make this second case work).</p>
<p>However, is not possible in the short term. This is due to the ambiguity
between referencing a global variable and the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0308-deprecate-property-lookup-fallback.md">property lookup fallback</a>
feature. We propose we simply wait until the property lookup fallback is fully
deprecated and removed, at which point we can reclaim the syntax.</p>
<p>In the mean time, globals can be referenced explicitly using the <code>component</code>,
<code>helper</code>, and <code>modifier</code> helpers.</p>
<p>Another difference is how global helpers can be invoked without arguments in
named arguments position for angle bracket invocations:</p>
<pre><code class="language-hbs">{{!-- if `pi` is a global helper that returns the value of the constant 𝛑 --}}
{{!-- this invokes the helper and passes the value 3.1415... --}}
&lt;MyComponent @value={{pi}} /&gt;
                      ~~

{{!-- as opposed to a &quot;true&quot; variable/value binding... --}}

{{#let (helper &quot;pi&quot;) as |pi|}}
  {{!-- this passes the helper into the component --}}
  &lt;MyComponent @value={{pi}} /&gt;
                        ~~

  {{!-- this invokes the helper and passes the value 3.1415... --}}
  &lt;MyComponent @value={{(pi)}} /&gt;
                        ~~~~
{{/let}}
</code></pre>
<p>Notably, this problem only exists in the named arguments position and only in
angle bracket invocations. For content and attribute positions, it would not
make sense to pass a helper &quot;by value&quot;, so the ambiguity does not exist (so it
always invokes). For sub-expression positions (which includes argument
positions for curly invocations), the parentheses are already mandatory
(otherwise it invokes the property fallback).</p>
<p>We propose to deprecate auto-invoking global helpers with no arguments in named
argument positions for angle bracket invocations and require the parentheses
instead. This will make room for unifying the global semantics in the future.</p>
<p>It is also worth pointing out that, since helpers tend to be pure, helpers
that take no arguments are exceedingly rare.</p>
<p>Finally, the last challenge to the unification is it is entirely possible to
have any combinations of components, helpers and modifiers all with the same
name today. This works, as they currently live in different &quot;namespaces&quot;, and
each lookup is contextually scoped to their respective &quot;namespace&quot; depending on
the position where it is invoked:</p>
<pre><code class="language-hbs">{{!-- foo-bar, the modifier here --}}
&lt;div {{foo-bar}} /&gt;
       ~~~~~~~

{{!-- foo-bar, the helper here --}}
&lt;div class={{foo-bar}} /&gt;
             ~~~~~~~

{{!-- foo-bar, the helper here --}}
{{#let (foo-bar) as |result|}}
        ~~~~~~~
{{/let}}

{{!-- foo-bar, the component here --}}
{{#foo-bar}}...{{/foo-bar}}
   ~~~~~~~        ~~~~~~~

{{!-- prefers foo-bar, the component here --}}
{{!-- if not found, then foo-bar, the helper --}}
{{foo-bar}}
  ~~~~~~~
</code></pre>
<p>Since this could get pretty confusing, most developers already avoid giving
these unrelated the same names. However, it is certainly possible that they
may happen by accident and go unnoticed (e.g. an addon introducing a global
helper that &quot;conflicts&quot; with a component in the app).</p>
<p>These kind of naming conflicts would not make sense in the value-based world.
Imagine if this is how JavaScript works:</p>
<pre><code class="language-js">class FooBar {}

function FooBar() {}

const FooBar = 1;

class FooBarBaz extends FooBar {}
//                      ~~~~~~ FooBar, the class here

console.log(FooBar());
//          ~~~~~~ FooBar, the function here

console.log(FooBar + 1);
//          ~~~~~~ FooBar, the constant here

someObj.FooBar = FooBar;
//               ~~~~~~ well, which one is this?
</code></pre>
<p>Clearly, this would be unacceptable and is similar to the situation we find
ourselves in here.</p>
<p>We propose to issue deprecation warnings whenever we detect these conflicts,
both at build time and at invocation time, while maintaining the same lookup
precedence for the time being. For example, when invoking a component in the
content position, if we see that there is also a helper with the same name, it
should result in a deprecation asking the developer to remain one or the other.</p>
<p>Notably, there is such a conflict in Ember today where <code>action</code> is both a
helper and a modifier. Instead of deprecating one of them, we propose to use an
internal mechanism to produce a single special value such that it will be
invokable as either a modifier or a helper context. This is different than
&quot;namespace&quot; semantics in that there is only one context-independent value in this
special case, i.e. <code>(helper &quot;action&quot;) === (modifier &quot;action&quot;)</code>.</p>
<p>We also acknowledge that, so long as there are <em>implicit</em> globals, we may never
be able to truly unify global bindings with local ones, as implicit global
bindings have a high risk of conflicting with HTML elements. Consider the
built-in <code>input</code> helper, or an in-app <code>main</code> helper. If these were implicitly
turned into global identifiers, they would conflict with the HTML elements with
the same name:</p>
<pre><code class="language-hbs">&lt;input type=&quot;text&quot;&gt;
 ~~~~~ now refers to the global `input` identifier?

&lt;main&gt;...&lt;/main&gt;
 ~~~~ now refers to the global `main` identifier?
</code></pre>
<p>While the problem exists for local bindings also, it was already addressed in
<a href="https://github.com/emberjs/rfcs/pull/311">RFC #311</a>. With local bindings, this
problem is fairly noticible and understandable since the conflict is introduced
nearby. The solution is also fairly simple – just rename the local variable to
avoid the conflict. With proper linting, this could be quite easily avoided
altogether.</p>
<p>With <em>implicit</em> global bindings, this problem is much more difficult to spot
and reason about. There is also no quick way out, other than to rename the
global component, helper or modifer which could be difficult or not an option
at all for addon authors trying to maintain compatibility. To truly resolve
this conflict, we would have to eliminate implicit globals, which is out of
scope for this RFC. This also wouldn't be a problem until all the proposed
deprecations are implemented and removed, which would be quite some time.</p>
<p>We <em>speculate</em> that when all the of that is said and done, we would have an
alternative resolution mechanism (&quot;template imports&quot;) that does not have this
problem. Alternatively, we could exclude the angle bracket invocation position
from being able to &quot;see&quot; implicit global identifiers.</p>
<a class="header" href="print.html#local-helpers-and-modifiers" id="local-helpers-and-modifiers"><h3>Local helpers and modifiers</h3></a>
<p>A nice fallout of this plan is that developers will be able to define helpers
and modifiers specific to a component locally in the same JavaScript file:</p>
<pre><code class="language-js">// app/components/date-picker.js

import Component from '@ember/component';
import { helper } from '@ember/component/helper';

export default Component.extend({
  date: null, // passed in

  'format-date': helper(function(params, hash) {
    /* ... */
  })
});
</code></pre>
<pre><code class="language-hbs">{{!-- app/templates/components/date-picker.hbs --}}
{{this.format-date this.date}}
</code></pre>
<p>In additional to encapsulation and namespacing, this will also enable even more
advanced use cases that uses the component's state:</p>
<pre><code class="language-js">// app/components/filtered-each.js

import Component from '@ember/component';
import { helper } from '@ember/component/helper';
import { computed } from '@ember/object';

export default Component.extend({
  list: null, // passed in
  callback: null, // passed in

  filter: computed('callback', function() {
    return helper(params =&gt; this.callback(params[0]));
  });
});
</code></pre>
<pre><code class="language-hbs">{{!-- app/templates/components/filtered-each.hbs --}}

{{#each this.list as |item|}}
  {{#if (this.filter item)}}
    {{yield item}}
  {{/if}}
{{/each}}
</code></pre>
<p>This feature would work with element modifiers as well.</p>
<p>Ideally, this should also work with components. However, currently there are
two pieces to a component – a template and a JavaScript class, either could be
optional. This poses a challenge to invoking components this way – without
going through the component helper, there is no easy way to import or package
a component into a single value. This is a solvable problem, but to design a
solution for that would be out of scope for this RFC. For the time being, the
only way to get a handle of a &quot;component defition value&quot; would be through the
component helper. Attempting to &quot;invoke&quot; just the component template or class
this way will result in a runtime error.</p>
<a class="header" href="print.html#how-we-teach-this-74" id="how-we-teach-this-74"><h2>How we teach this</h2></a>
<p>There are two sides to this feature – the consumption side and the authoring
side.</p>
<p>The consumption side refers to learning how the contextual helper and modifier
values can be used (invoked). We expect developers to enounter this mainly
through addons that others have written. So long as there is adequate
documentation from the addon authors, we expect that this group of users can be
immediately productive by simply treating these APIs as DSLs, similar to the
Router DSL.</p>
<p>In other words, while this group of developer may not immediately understand
how to <em>author</em> these kind of APIs, or what is involved under-the-hood to make
it work, the design goal is that it should feel straightforward to <em>consume</em>
this style of API.</p>
<p>The authoring side refers to using the <code>helper</code> and <code>modifier</code> helpers, and
more importantly, the advanced composition patterns that motivated their
existence in the first place As with the <code>component</code> helper and other
&quot;higher-order functions&quot; in JavaScript, this is a somewhat advanced topic that
is mainly targeted at addon authors and advanced developers.</p>
<p>For this group of users, we expect this feature to complement and complete the
&quot;contextual components&quot; feature. Developers who are already familiar with that
feature should feel right at home. We expect to be able to introduce this new
feature at the point where we currently teach contextual components today.</p>
<p>In the long term, the unifications proposed in this RFC should make these
concepts easier to teach for this group of developers, as components, helpers
and modifiers, whether global or contextual, will all behave uniformly. The
value-based semantics also better matches JavaScript which they are probably
already familiar with.</p>
<p>The official documentations should be updated to include this feature:</p>
<ul>
<li>
<p>The new <code>helper</code> and <code>modifier</code> helpers need be be added to the API docs.
We should consider cross-linking between the <code>helper</code>, <code>modifier</code> and
<code>component</code> helpers since they solve a similar problem.</p>
</li>
<li>
<p>The guide should be updated to teach this feature as well. We recommend
teaching the two sides of the feature separately, and prioritize the
consumption side, as that is what beginners are likely to encounter first.</p>
<p>For example, when teaching component invocations, there can be a section that
mentions:</p>
<blockquote>
<p>Sometimes, components may be yielded to you as a block param. These are
called contextual components, and they can be invoked just like any other
components you have encountered so far.</p>
<p>...examples...</p>
<p>To learn how to do this yourself, skip ahead to the &quot;Composition Patterns&quot;
section (link).</p>
</blockquote>
</li>
<li>
<p>For the authoring side, we recommend teaching the helper, modifier and
component version of the feature in a single place (such as a &quot;Composition
Patterns&quot; section), cross-linked from their respective sections, rather than
repeating it three times.</p>
</li>
</ul>
<a class="header" href="print.html#drawbacks-98" id="drawbacks-98"><h2>Drawbacks</h2></a>
<p>This RFC introduces another feature that developers may encounter and have to
learn when consuming addons. However, on the whole, we think this will simplify
things more than adding to the concepts – as it ultimiately try to unify the
behavior of components, helpers and modifiers (and in the future, globals).
This should make things feel more consistent and allow developers to apply
their knowledge consistently across the board.</p>
<p>In the short term, this feature may amplify some of the mismatches and causes
confusions where the legacy semantics does not perfectly match the new world we
are building. This could be mitigated with helpful deprecation messages.</p>
<a class="header" href="print.html#alternatives-100" id="alternatives-100"><h2>Alternatives</h2></a>
<p><a href="https://github.com/emberjs/rfcs/pull/208">RFC #208</a> has previously explored
the same design space. It solves the same fundamental problems, but proposes
two seperate helpers resolution/currying and invocation. This is largely due to
limitations and ambiguities in Handlebars. This RFC attempts to remove the need
of a separate invocation helper by resolving the ambiguities and integrating
more tightly with Handlebars. If accepted, this RFC will supersede the design
proposed in RFC #208.</p>
<p>As proposed, this RFC relies heavily on context-dependent syntatic positions to
disambiguate between component, helper and modifier invocations. For example,
while they may look similar, the following syntax does not produce the same
result:</p>
<pre><code class="language-hbs">{{foo-bar baz=&quot;bat&quot;}}

{{(foo-bar baz=&quot;bar&quot;)}}
</code></pre>
<p>If <code>foo-bar</code> is a helper, either would work. However, if <code>foo-bar</code> is a
component, only the first form would work and the second form would result in
a runtime error (trying to invoke a component as helper).</p>
<p>A different design has been considered where the first form is just strictly a
syntactic sugar for the latter and <code>(...)</code> invocation is one true primitive
that ties everything together.</p>
<p>Specifically, when &quot;invoked&quot; with <code>(...)</code>, a component or modifier simply
produces a value, which is a definition object with the curried arguments, i.e.
<code>(...)</code> is a syntatic surgar for currying using the <code>helper</code> and <code>modifier</code>
helpers. The <code>{{...}}</code> syntax then simply &quot;append&quot; the curried definition
object by first invoking it.</p>
<p>This design turned out to add more complexities and confusions than the
unification has brought to the table, and so that design was abandoned in favor
of what is proposed here.</p>
<p>Another alternative is to keep the global namespace separate from the local
namespace, thus avoiding the need for most deprecations. In practice, we
believe this would result in much more confusion when things do not behave the
way you would expect, but only in some niche corner cases.</p>
<a class="header" href="print.html#unresolved-questions-69" id="unresolved-questions-69"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2019-01-18</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/435</li>
<li>Ember Issue: https://github.com/emberjs/ember.js/issues/17493</li>
</ul>
<a class="header" href="print.html#forwarding-element-modifiers-with-splattributes" id="forwarding-element-modifiers-with-splattributes"><h1>Forwarding Element Modifiers with &quot;Splattributes&quot;</h1></a>
<a class="header" href="print.html#summary-103" id="summary-103"><h2>Summary</h2></a>
<p>This is a small amendment to
<a href="https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html">RFC #311 &quot;Angle Bracket Invocation&quot;</a>
and <a href="https://emberjs.github.io/rfcs/0373-Element-Modifier-Managers.html">RFC #373 &quot;Element Modifier Manager&quot;</a>
to clarify how the &quot;splattributes&quot; feature interact with element modifiers.</p>
<a class="header" href="print.html#motivation-104" id="motivation-104"><h2>Motivation</h2></a>
<p>RFC #311 introduced the angle bracket component invocation feature. Aside from
the syntatic differences, the angle bracket invocation syntax enabled passing
HTML attributes to components, which can then be applied the underlying HTML
element(s) in the component's layout using the <code>...attributes</code> &quot;splattributes&quot;
syntax.</p>
<p>For example, given the following invocation:</p>
<pre><code class="language-hbs">&lt;FooBar class=&quot;foo-bar&quot; /&gt;
</code></pre>
<p>...and the following layout for the <code>FooBar</code> component:</p>
<pre><code class="language-hbs">&lt;div ...attributes&gt;foo bar!&lt;/div&gt;
</code></pre>
<p>Ember will render the following HTML content:</p>
<pre><code class="language-html">&lt;div class=&quot;foo-bar&quot;&gt;foo bar!&lt;/div&gt;
</code></pre>
<p>See the <a href="https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html#html-attributes">HTML Attributes section</a>
of RFC #311 for more information on this feature.</p>
<p>On the other hand, RFC #373 introduced the element modifier manager feature.
This enabled Ember developers to define custom element modifiers, similar to
the built-in <code>{{action}}</code> modifier that ships with Ember.</p>
<p>This feature can be quite useful for encapsulating, among other things, DOM
event handling and accessibility concerns. For example:</p>
<pre><code class="language-hbs">&lt;a {{on click=(action this.onClick)}} {{act-as &quot;button&quot;}}&gt;Click Me!&lt;/a&gt;
</code></pre>
<p>While these features are both very useful on their own, they can be combined
to enable powerful abstraction and composition patterns. Unfortunately, the
two RFCs did not explicitly describe how these features would interact with
each other. This RFC proposes three admenments to clarify their relationship:</p>
<ol>
<li>
<p>It is legal to apply modifiers to angle bracket component invocations, i.e.</p>
<pre><code class="language-hbs">{{!-- this is legal --}}
&lt;MyButton {{action this.onClick}}&gt;Click Me!&lt;/MyButton&gt;
</code></pre>
</li>
<li>
<p>Element modifiers can be applied to the underlying HTML element(s), along
with any HTML attributes, using the splattributes syntax.</p>
<pre><code class="language-hbs">{{!-- this apply any modifiers in addition to HTML attributes --}}
&lt;a ...attributes&gt;{{yield}}&lt;/a&gt;
</code></pre>
</li>
<li>
<p>In addition, the splattributes syntax can be used to forward HTML attributes
and element modifiers to subsequent angle bracket component invocations.</p>
<pre><code class="language-hbs">{{!-- this is also legal, does the same as the above --}}
&lt;InternalButton ...attributes&gt;{{yield}}&lt;/InternalButton&gt;
</code></pre>
</li>
</ol>
<p>This allows the end-users to retain some control over DOM event handling and
other HTML concerns (such as CSS and ARIA roles/accessibility concerns) when
invoking components.</p>
<p>Fundamentally, element modifiers simply enable more fine-grained customization
of an HTML element, on top of what one could accomplish with HTML attributes.
If it is possible to configure the <code>class</code> and <code>aria-role</code> attributes of a
component's HTML element, it should also be possible to extract them into a
custom element modifier.</p>
<p>It is also adventageous to allow modifiers like <code>action</code> to work consistently,
whether the invocation happens to be an HTML element or a component. This allow
features like the <a href="https://github.com/emberjs/rfcs/pull/389">element helper</a> to
compose better.</p>
<p>For these reasons, we believe it is important and consistent to allow these
interactions.</p>
<a class="header" href="print.html#detailed-design-87" id="detailed-design-87"><h2>Detailed design</h2></a>
<p>From Glimmer VM's perspective, the foundation for these features are already
in-place. Specifically, when applied on an angle bracket invocation, HTML
attributes and element modifiers are collected into an internal block, and the
splattributes syntax simply yields back to that block. Similarly, when applying
the splattributes to another angle bracket invocation, it simply fowards the
block recurrsively. This feature is only currently gated by a precautionary
&quot;compile time error&quot; which can be easily removed once this RFC is accepted.</p>
<p>As laid out in the <a href="https://github.com/emberjs/rfcs/pull/373">modifier manager RFC</a>,
the <code>createModifier</code> hook is called in the order they appear in the template.
This means that given the following invocation:</p>
<pre><code class="language-hbs">&lt;MyComponent {{bar}} /&gt;
</code></pre>
<p>And the following template for <code>MyComponent</code>:</p>
<pre><code class="language-hbs">&lt;div {{foo}} ...attributes {{baz}} /&gt;
</code></pre>
<p>The creation order will be <code>{{foo}}</code>, <code>{{bar}}</code>, <code>{{baz}}</code>. However, the RFC
only provide relative timing guarentees for <code>createModifier</code>, and notably <em>not</em>
for <code>installModifier</code> and <code>updateModifier</code> where most of the interesting work
happen (<code>createModifier</code> does not receive the element). Therefore, in practice,
it is both not very useful to rely on this timing guarentee, nor is it a good
idea.</p>
<a class="header" href="print.html#how-we-teach-this-75" id="how-we-teach-this-75"><h2>How we teach this</h2></a>
<p>This should be taught in the guides:</p>
<ol>
<li>
<p>When teaching angle bracket invocations, we should mention that HTML
attributes and modifiers, in addition to named arguments, can be passed to
components. Some examples would be passing <code>class</code>, <code>aria-role</code> and the
built-in <code>action</code> modifier.</p>
</li>
<li>
<p>When teaching how to author component layouts, we should introduce the
splattributes syntax and explain why it is a good practice to include it on
the primary element(s) in the layout, in order to allow custom styling and
accessibility management by the end-user.</p>
</li>
<li>
<p>When teaching advanced component composition patterns, we can introduce the
concept of &quot;components that invokes other components&quot;. This would be a good
place to explain how the splattributes can be used to forward both HTML
attributes as well as modifiers to child components.</p>
</li>
<li>
<p>When teaching element modifiers, we can give use cases of refactoring common
set of HTML attributes (e.g. classes that goes together with aria-roles)
into named element modifiers (e.g. <code>{{act-as &quot;button&quot;}}</code>).</p>
</li>
</ol>
<p>With the changes proposed in this RFC, it becomes more important to emphasize
that element modifier is a &quot;sharp tool&quot;. As with lifecycle hooks in the classic
<code>Ember.Component</code>, element modifier is an escape valve from the declarative,
pure and functional world of Handlebars templates, into the messy world of
imperative code, shared states and mutability. While they are very flexible,
that flexibility comes at a cost. When used incorrectly, they can easily leak
state, stomp over each other and causes problems in the app.</p>
<p>Therefore, when authoring element modifiers, it is important to be a &quot;good
citizen&quot;, keeping in mind that the underlying HTML element is &quot;shared&quot; among
any bound attributes in the template and other element modifiers. For example,
it is probably a bad idea to prevent event propagation from within an element
modifier, as it may break other modifiers that are listening to the same DOM
event.</p>
<p>This problem is not new, as it is already possible to have multiple element
modifiers attached to the same HTML element. However, when intermediate
components are involved, this could become very difficult to notice.</p>
<p>Therefore, it is even more important to teach and encourage users to author
element modifiers that play well with each other to allow the kind of
composition proposed in this RFC to work at scale.</p>
<p>On the flip side, installing element modifiers on extenal components (i.e.
those that came from outside the app, such as those provided by addons) is also
a somewhat fragile act as it pierces through an encapsulation boundries. Very
generic modifiers like <code>{{action}}</code> and <code>{{on}}</code> are unlikely to cause problems,
but more special-purpose ones may not be appropiate, unless they are sanctioned
by the component authors.</p>
<p>This is already a risk with splattributes in general, as there are plenty of
context-specific HTML attributes. However, allowing element modifiers here is
going to increase the risk as the operations they perform are hidden further
away.</p>
<a class="header" href="print.html#drawbacks-99" id="drawbacks-99"><h2>Drawbacks</h2></a>
<p>The main drawback is the added risk of breaking encapsulation boundries of
components. Specifically, because the element modifiers have access to the raw
underlying HTML element, they may inadvertently depend upon details about the
element (it is of a particular type, has certain attributes or properties set,
etc), beyond what was intended by the component author as a public API. If this
turned out to be a wide-spread problem, it can be mitigated by adding linting
rules to the template linter.</p>
<p>Separately, as proposed, this API does not allow the element modifiers to &quot;see&quot;
any intermediate components, only the final HTML element. If this turned out to
be useful, we can consider introducing it as an optional capability in future
extensions.</p>
<a class="header" href="print.html#alternatives-101" id="alternatives-101"><h2>Alternatives</h2></a>
<p>We can disallow using element modifiers on components, as well as using
splattributes to forward HTML attributes on child component invocations.</p>
<a class="header" href="print.html#unresolved-questions-70" id="unresolved-questions-70"><h2>Unresolved questions</h2></a>
<p>None.</p>
<ul>
<li>Start Date: 2019-02-06</li>
<li>Relevant Team(s): Ember.js, Ember Data, Ember CLI, Learning, Steering</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/440</li>
<li>Tracking: (leave this empty)</li>
</ul>
<a class="header" href="print.html#decorator-support" id="decorator-support"><h1>Decorator Support</h1></a>
<a class="header" href="print.html#summary-104" id="summary-104"><h2>Summary</h2></a>
<p>Move forward with the Decorators RFC via stage 1 decorators, and await a stable
future decorators proposal.</p>
<a class="header" href="print.html#motivation-105" id="motivation-105"><h2>Motivation</h2></a>
<p>The recently merged <a href="https://github.com/emberjs/rfcs/blob/master/text/0408-decorators.md">Decorators
RFC</a>
contained an explicit condition: That it was premised on decorators moving from
stage 2 in the TC39 process to stage 3. If this were to not happen, the original
RFC stipulates that a followup (this RFC) should be created to clarify whether
or not we should move forward with decorators while they remain in stage 2, and
how we would do so.</p>
<p>This RFC proposes that we do so. As discussed in the original, the decorator
pattern has been in use in Ember since the beginning, and there is no easy path
forward to native class syntax without a native equivalent to &quot;classic&quot;
decorators.</p>
<p><a href="https://tc39.github.io/process-document/">Stage 2 in TC39</a> signals that the
committee expects this feature to be included in the language in the future, and
is working out the details and semantics. The fact that decorators <em>remain</em> in
stage 2, and have not been rejected, signals that they still expect this to be
the case. However, it is clear based on the initial work following the January
TC39 meeting that <a href="https://github.com/tc39/proposal-decorators/pull/250">the proposal could change
significantly</a> between now
and stage 3.</p>
<p>Parts of the proposal, such as how decorators are invoked, seem solid based on
the feedback we received at the January TC39 meeting, and based on the draft of
the new spec. The definition of decorators is the most likely thing to change.
As such, user code should be minimally affected by any changes, and most changes
should be codemod-able. This reduces the risk of adopting decorators now, since
code <em>written</em> with decorators shouldn't need to change that much.</p>
<p><a href="https://github.com/tc39/proposal-decorators/tree/static#how-should-i-use-decorators-in-transpilers-today">The current recommendation from the authors of the
spec</a>
is to use the stage 1 decorators proposal until the next iteration is ready.
Stage 1 decorators are very stable, and used by a large community of developers
outside of Ember. By standardizing on this version of the spec, we'll be able to
gain the benefits of using a shared solution with the wider ecosystem while we
wait for the next iteration.</p>
<a class="header" href="print.html#detailed-design-88" id="detailed-design-88"><h2>Detailed design</h2></a>
<a class="header" href="print.html#classic-classes-1" id="classic-classes-1"><h3>Classic Classes</h3></a>
<p>The first thing to note is that Ember.js will continue to work with classic
classes and classic class syntax for the forseeable future, as a way for users
to opt-out if they don't want to take the risk of using native classes. This
includes:</p>
<ul>
<li>Classic Classes</li>
<li>Classic Components</li>
<li>Mixins</li>
<li>Computed Properties</li>
<li>Observers</li>
<li>Tracked Properties</li>
<li>Injections</li>
<li>All existing classes defined with classic class syntax</li>
</ul>
<p>Notably, <code>GlimmerComponent</code> will <em>not</em> support classic class syntax, due to its
constraint of having to support both Ember.js <em>and</em> Glimmer.js, where the
classic class model is not available. However, creating an API compatible
classic class version using Ember's component manager API should be possible if
users want to write Glimmer-like components with classic syntax.</p>
<a class="header" href="print.html#decorator-semantics" id="decorator-semantics"><h3>Decorator Semantics</h3></a>
<p>Ember will support Babel's stage 1 decorator transforms. Since Babel and
TypeScript's decorators overlap so much, most TypeScript decorators should also
work in Ember apps. However, due to subtle differences in the way Babel and
TypeScript's decorators work, we can't support them both in <em>all</em> cases. In
cases where there are nuanced differences, Babel's transforms will be considered
the canonical source of truth. For <code>ember-cli-typescript</code> users this shouldn't
be an issue, since they can use Babel's transforms in the latest versions of
<code>ember-cli-typescript</code>.</p>
<a class="header" href="print.html#class-field-assigment-order" id="class-field-assigment-order"><h4>Class Field Assigment Order</h4></a>
<p>Ember also does <em>not</em> guarantee a particular ordering for the assignment of
decorated fields in order to support users who want to use <em>native</em> class fields
when they are available. All that Ember guarantees is that by the time the
<code>constructor</code>'s <code>super</code> method completes (or the constructor code begins, if the
class is not extending), all class fields will be assigned.</p>
<p>Assigning class fields based on the values of other class fields is somewhat of
an anti-pattern as is, so this would reinforce discouraging problematic
patterns. To be clear:</p>
<pre><code class="language-js">class MyComponent extends Component {
  // This is ok, because the component instance exists
  // for all class fields.
  stateManager = new StateManager(this);

  @service time;

  // This is ok, because the `time` is an injection,
  // and always available for all class fields.
  createdAt = this.time.now();

  // This is problematic in general, not just with decorators, because
  // it relies on the order of class field assignment within this class.
  // It is a refactoring hazard, and should likely be done in the
  // constructor instead.
  registry = new Registry();
  container = new Container(this.registry);
}
</code></pre>
<p>Ember will attempt to provide a lint rule which can handle this level of nuance
and prevent frustration when users copy and paste code around the class body.</p>
<a class="header" href="print.html#class-field-assignment-semantics" id="class-field-assignment-semantics"><h4>Class Field Assignment Semantics</h4></a>
<p>Currently, the Babel stage 1 transforms require <code>loose</code> mode for class fields
which causes them to be assigned directly rather than using
<code>Object.defineProperty</code>, which is not inline with the class fields spec. The
biggest difference in behavior is when a child class attempts to override a
getter/setter on the parent class:</p>
<pre><code class="language-js">class Foo {
  get baz() {
    return this._baz;
  }

  set baz(value) {
    this._baz = value;
  }
}

class Bar extends Foo {
  baz = 123;
}
</code></pre>
<p>In strict mode, <code>baz</code> in the child class would completely override the
getter/setter, and they would not exist/be usable on an instance of <code>Bar</code>
(except through calls to <code>super</code>). In loose mode, <code>baz</code> in the child class would
go through the getter/setter, and be assigned to <code>_baz</code> on the instance.</p>
<p>In order to mitigate this, Ember will provide an assertion in development builds
via a babel transform for fields that are assigned in a non-spec compliant way
that throws in this scenario. This will prevent users from accidentally writing
code that will be hard to migrate forward to class fields in the future.</p>
<a class="header" href="print.html#decorator-support-timeframe" id="decorator-support-timeframe"><h3>Decorator Support Timeframe</h3></a>
<p>Stage 1 decorators will be considered a first class Ember API. They will be
supported until:</p>
<ol>
<li>A new RFC has been made to introduce a new decorator API as a parallel API to
the stage 1 decoraters.</li>
<li>A deprecation RFC has been created for Stage 1 decorators.</li>
</ol>
<p>They will follow the same deprecation flow, and same SemVer requirements, as any
other Ember feature.</p>
<a class="header" href="print.html#how-we-teach-this-76" id="how-we-teach-this-76"><h2>How we teach this</h2></a>
<p>There are a few different important aspects of this that should be taught:</p>
<ol>
<li>
<p><strong>Class Field and Decorator semantics</strong>, specifically around the ordering of
class fields. While any step to change a user's class field ordering would
likely be based on their target browsers and configuration, and would be
unlikely to change in a patch or minor version release, users writing code
that could be difficult to upgrade or dependent on a particular version of
the class field/decorator transforms is a failure case we want to avoid.</p>
</li>
<li>
<p><strong>Support timeframe and alternatives.</strong> Users should be aware that this will
be a feature that will <em>likely</em> change in the future, if only subtly. We
should highlight that there <em>is</em> an alternative, classic class syntax, and
that it will still be fully supported. Ultimately, this point is about
setting expectations - that a year or so from now, when decorators are truly
final, there will be another shift.</p>
</li>
<li>
<p><strong>Custom Decorators.</strong> We should document how users can write their own
decorators, but also caution against behaviors that will be difficult to
replicate in Stage 3 decorators when they are ready. This will <em>necessarily</em>
be a moving target, since stage 3 decorators are not yet finished, but we can
try our best to recommend against usages that could be problematic.</p>
<p>We should also warn that decorator definition code will almost definitely
have to be rewritten for stage 3. This should be very clear, so that users
understand that adopting custom decorators in their apps means taking on more
tech debt than just using official Ember decorators, and decorators provided
by addons.</p>
</li>
</ol>
<a class="header" href="print.html#drawbacks-100" id="drawbacks-100"><h2>Drawbacks</h2></a>
<ul>
<li>
<p>The fact that decorators did not move to stage 3 signals that there may be
additional changes to the spec in the near future. Adopting them now could
cause more churn than it's worth.</p>
</li>
<li>
<p>By adopting decorators now, we are essentially taking on some amount of debt
that we know will have to be repaid in the future as a community. This is less
than ideal, since we know that standardization is coming, it's just a matter
of when. This is also the situation we've been in for quite some time already,
and with the latest turn of events, it seems unlikely that decorators will be
fully standardized within the year.</p>
<p>We can continue to wait, but there is no deadline on the design process, and
we could be stuck here indefinitely. This move is pragmatic in that it
unblocks us for now, and moves us toward using modern syntax that will be
compatible with stage 3 decorators - it allows us to begin unwinding other
layers of technical debt. It also represents minimal risk and debt to <em>users</em>
of decorators, since the invocation style will likely be the same.</p>
</li>
</ul>
<a class="header" href="print.html#alternatives-102" id="alternatives-102"><h2>Alternatives</h2></a>
<ul>
<li>
<p>We could continue to rely on unofficial addons such as <code>ember-decorators</code>,
which allow users to opt-in to using decorators. However, these libaries have
limitations that first class decorators will not have, and they don't allow us
to update the official guides to use them.</p>
</li>
<li>
<p>We could create an official decorators addon. However, this means that
decorators would be available at a different import path, meaning that any
code which seeks to work with <em>both</em> classic classes and native classes would
have to be written twice. This would be very difficult for applications that
are mid-transition, and even more difficult throughout the ecosystem for addon
authors.</p>
</li>
</ul>
<ul>
<li>Start Date: 2019-02-13</li>
<li>Relevant Teams: Ember.js, Learning</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/445</li>
<li>Tracking: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecate-with" id="deprecate-with"><h1>Deprecate <code>{{with}}</code></h1></a>
<a class="header" href="print.html#summary-105" id="summary-105"><h2>Summary</h2></a>
<p>The <code>{{with}}</code> helper has always had slightly confusing conditional semantics, this was one of the motivators for <a href="https://github.com/emberjs/rfcs/blob/master/text/0286-block-let-template-helper.md">introducing</a> the easier to understand <code>{{let}}</code> helper. Now that <code>{{let}}</code> exists, the remaining use case for using <code>{{with}}</code> is for its unique conditional semantics. These conditional semantics can be cleanly represented with a combination of <code>{{let}}</code> and <code>{{if}}</code> statements so we should deprecate <code>{{with}}</code>.</p>
<a class="header" href="print.html#motivation-106" id="motivation-106"><h2>Motivation</h2></a>
<p>The difference between <code>{{let}}</code> and <code>{{with}}</code> is with how they handle conditional arguments. The <code>{{let}}</code> helper's block content is always rendered, regardless of its parameters. In contrast, <code>{{with}}</code> only renders its main block when the first position parameter is truthy. For example:</p>
<pre><code class="language-hbs">{{#with &quot;Alex&quot; as |value|}}
  {{value}} is truthy
{{else}}
  The first positional param was falsy
{{/with}}
</code></pre>
<p>Will render &quot;[Alex] is truthy&quot;.</p>
<pre><code class="language-hbs">{{#with false as |value|}}
  {{value}} is truthy
{{else}}
  The first positional param was falsy
{{/with}}
</code></pre>
<p>Will render &quot;The first positional param was falsy&quot;.</p>
<p>The conditional arguments behavior of <code>{{with}}</code> can easily be replicated using a combination of <code>{{let}}</code> and <code>{{if}}</code> in a way that's easily readable:</p>
<pre><code class="language-hbs">{{#let &quot;Alex&quot; as |value|}}
  {{#if value}}
    {{value}} is truthy
  {{else}}
    The first positional param was falsy
  {{/if}}
{{/let}}
</code></pre>
<a class="header" href="print.html#detailed-design-89" id="detailed-design-89"><h2>Detailed design</h2></a>
<p>We'll create an AST transform in <a href="https://github.com/emberjs/ember.js/tree/master/packages/ember-template-compiler"><code>packages/ember-template-compiler</code></a> which will emit a deprecation warning for all uses of <code>{{with}}</code>. The deprecation warning will be:</p>
<pre><code>Using `{{with}}` is deprecated, please use `{{let}}` instead.
</code></pre>
<p>This message will link to the following deprecation details which aim to give clear guidance on how to migrate to using <code>{{let}}</code>, <code>{{if}}</code> and <code>{{else}}</code> in different combinations:</p>
<hr />
<p>The use of <code>{{with}}</code> has been deprecated, you should replace it with either <code>{{let}}</code> or a combination of <code>{{let}}</code>, <code>{{if}}</code> and <code>{{else}}</code>:</p>
<p><strong>If you always want the block to render, replace <code>{{with}}</code> with <code>{{let}}</code> directly:</strong></p>
<p>Before:</p>
<pre><code class="language-hbs">{{#with (hash name=&quot;Ben&quot; age=4) as |person|}}
  Hi {{person.name}}, you are {{person.age}} years old.
{{/with}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{#let (hash name=&quot;Ben&quot; age=4) as |person|}}
  Hi {{person.name}}, you are {{person.age}} years old.
{{/let}}
</code></pre>
<p><strong>If you want to render a block conditionally, use a combination of <code>{{let}}</code> and <code>{{if}}</code>:</strong></p>
<p>Before:</p>
<pre><code class="language-hbs">{{#with user.posts as |blogPosts|}}
  There are {{blogPosts.length}} blog posts
{{/with}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{#let user.posts as |blogPosts|}}
  {{#if blogPosts}}
    There are {{blogPosts.length}} blog posts
  {{/if}}
{{/let}}
</code></pre>
<p><strong>If you want to render a block conditionally, and otherwise render an alternative block, use a combination of <code>{{let}}</code>, <code>{{if}}</code> and <code>{{else}}</code>:</strong></p>
<p>Before:</p>
<pre><code class="language-hbs">{{#with user.posts as |blogPosts|}}
  There are {{blogPosts.length}} blog posts
{{else}}
  There are no blog posts
{{/with}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{#let user.posts as |blogPosts|}}
  {{#if blogPosts}}
    There are {{blogPosts.length}} blog posts
  {{else}}
    There are no blog posts
  {{/if}}
{{/let}}
</code></pre>
<hr />
<p>For people on older versions of Ember that support <code>{{let}}</code>, we'll create an <code>ember-template-lint</code> rule that they can use to prevent the use of <code>{{with}}</code>.</p>
<p>We'll also create a codemod which will assist people when migrating from <code>{{with}}</code> to <code>{{let}}</code>.</p>
<a class="header" href="print.html#how-we-teach-this-77" id="how-we-teach-this-77"><h2>How we teach this</h2></a>
<p>We'll mentiton the deprecation in an Ember point release blog post.</p>
<p>As mentioned above, the deprecation message will contain a link to clear guidelines on how to migrate to using <code>{{let}}</code>.</p>
<p>There is nothing to remove from the Ember.js Guides since we already teach only the use of <code>{{let}}</code>.</p>
<a class="header" href="print.html#drawbacks-101" id="drawbacks-101"><h2>Drawbacks</h2></a>
<p>This adds a little churn to Ember's API.</p>
<a class="header" href="print.html#alternatives-103" id="alternatives-103"><h2>Alternatives</h2></a>
<p>We could leave <code>{{with}}</code> as is. I don't believe that this is a good option as the name <code>{{with}}</code> is confusing.</p>
<p>We could deprecate <code>{{with}}</code> and introduce <code>{{if-let}}</code> in Ember core. This RFC originally made that exact proposal, I was strongly persuaded of the <a href="https://github.com/emberjs/rfcs/pull/445#issuecomment-463594185">lack of need for <code>{{if-let}}</code> by @tcjr</a>.</p>
<p>We could deprecate <code>{{with}}</code> and introduce <code>{{if-let}}</code> in an addon instead of Ember core.</p>
<a class="header" href="print.html#unresolved-questions-71" id="unresolved-questions-71"><h2>Unresolved questions</h2></a>
<p>(none)</p>
<ul>
<li>Start Date: 2019-02-14</li>
<li>Relevant Team(s): Learning, Infrastructure</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/446</li>
<li>Tracking: (leave this empty)</li>
</ul>
<a class="header" href="print.html#contribution-guides" id="contribution-guides"><h1>Contribution Guides</h1></a>
<a class="header" href="print.html#summary-106" id="summary-106"><h2>Summary</h2></a>
<p>This RFC proposes the creation of an official <strong>Contribution Guide</strong> that aims to improve the discoverability of Ember-related projects that require help by the community and outlines the general contribution workflow for these projects.</p>
<a class="header" href="print.html#motivation-107" id="motivation-107"><h2>Motivation</h2></a>
<p>In the past year alone, <a href="https://github.com/emberjs/ember.js/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">43</a>, <a href="https://github.com/ember-cli/ember-cli/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">34</a>, <a href="https://github.com/emberjs/data/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">29</a>, <a href="https://github.com/ember-learn/guides-source/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">81</a> and <a href="https://github.com/emberjs/website/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">31</a> people made contributions to the <a href="https://github.com/emberjs/ember.js">core framework library</a>, the <a href="https://github.com/ember-cli/ember-cli">Ember CLI</a>, Ember’s <a href="https://github.com/emberjs/data">Data library</a>, the source for <a href="https://github.com/ember-learn/guides-source">the official framework Guides</a>, and the <a href="https://github.com/emberjs/website">project website</a>, respectively. An already impressive amount of developers decided to dedicate their time and effort to contribute to Ember - a project, that has been actively supported, maintained and developed by a strong open-source community for over seven years. Besides the code contributions to the main project repositories, the community can also look back on years of immense effort that has been put into the development of community-maintained packages which resulted in the vast Ember addon ecosystem as we know it today, as well as independent documentation and learning resources.</p>
<p>We are confident that there is an even greater potential for the community to contribute and that this can be unlocked by facilitating the contribution process - especially in regards to the on-boarding process for first-time contributors to Ember. Today, new community members oftentimes need to spend some time and effort to find a suitable project that allows them to apply a) their skills efficiently and b) is in their eyes worthwhile.</p>
<p>This RFC proposes to create and release a Contribution Guide - a new website as part of the <code>emberjs.com</code> domain. This new site should allow contributors to find Ember-related projects to work on easily and should provide more information on the workflow for their potentially (but not necessarily) first open-source contribution.</p>
<a class="header" href="print.html#detailed-design-90" id="detailed-design-90"><h2>Detailed design</h2></a>
<p>The new Contribution Guides should be as <strong>beginner-friendly</strong> as possible to accommodate the needs of those who might make their very first code contribution to an open-source project.</p>
<p>The list of topics covered should therefore include:</p>
<ul>
<li>
<p><strong>A summary of the motivation of open-source and its meaning for Ember as an OSS project.</strong> This aims to provide more context to those new to Ember and open-source in general about the purpose of the project and how Ember values a collaborative approach in the development of the framework.</p>
</li>
<li>
<p><strong>A How-To for code contributions with a real-world example.</strong> This can include tips on how to find and claim a suitable issue, an introduction to Git and how to send a pull request, tips for the review process about finding a reviewer, communicating effectively and submitting changes and easy-to-review chunks of contribution work.</p>
</li>
<li>
<p><strong>A How-To for filing a new issue on an Ember project</strong></p>
</li>
<li>
<p><strong>An issue finder functionality inspired by the <a href="https://whatcanidoformozilla.org/#!/progornoprog/teach">What Can I Do for Mozilla landing page</a></strong>. This should lead users to a) a list of relevant issues on the <a href="https://help-wanted.emberjs.com/">Ember Help Wanted App</a>, b) a related strike team channel on the Ember Discord chat, c) a link to the description of an on-going initiative on the <a href="https://emberjs.com/statusboard/">Status Board</a>.</p>
</li>
</ul>
<p>Any subjects covered in the Guides should be presented as text instruction at least, but each topic can be enhanced with relevant code examples and multi-media content (e.g. slides of a relevant community talk, video content among others).</p>
<p>To help with the integration of the issue finder on the Contribution Guides with the Ember Help Wanted app, this proposes to extend the Ember Help Wanted App with a search filter for the main programming language used in the project. To make the Contribution Guides easy to discover from Ember projects, each project's specific contribution guidelines (e.g. <a href="https://github.com/ember-cli/ember-cli/blob/master/CONTRIBUTING.md">Ember CLI's <code>CONTRIBUTING.md</code></a>) should cross link back to the new Contribution Guides site for reference.</p>
<p>To improve discoverability of the Contribution Guides via search engines, it is also proposed to host the Guides on their own Ember sub domain: <strong>contribute.emberjs.com</strong></p>
<a class="header" href="print.html#alternatives-104" id="alternatives-104"><h2>Alternatives</h2></a>
<p>An alternative would be to not create a dedicated Contribution Guide and instead refer those that want to contribute to <a href="https://guides.emberjs.com/release/contributing/adding-new-features/">the related section in the Ember Guides</a>. It would also be possible to expand this section of the Ember Guides further with more content we'd like to share with contributors.</p>
<p>Also, the Ember Help Wanted App already works in favour of one of the goals of this proposal which is increasing the discoverability of issues that require contribution help. Instead of creating a new, dedicated website for the Contribution Guides, it would also make sense to progressively enhance the Help Wanted App with relevant content on contribution, e.g. with a short tutorial on the contribution workflow or How-Tos on other kinds of contribution work.</p>
<a class="header" href="print.html#unresolved-questions-72" id="unresolved-questions-72"><h2>Unresolved questions</h2></a>
<p>Although this RFC already answers questions about the kind of content we’d like to see with an Contribution Guide for Ember, it is not clear yet, how the infrastructure for this guide looks like. Some of related questions are:</p>
<ul>
<li>
<p>Should the Guide be another Ember app, e.g another dedicated Guides app, in a similar to the official Ember and <a href="https://github.com/ember-learn/cli-guides">Ember CLI Guides</a>? Making it an Ember app might in return help community members to contribute to it since they’re most likely already familiar with Ember. Choosing a similar format as the one of the Ember CLI Guides comes with the additional benefit of making it particularly easy to contribute to the Guide’s content since this only requires an understanding of Markdown, lowering the entry hurdle for a first-time contribution</p>
</li>
<li>
<p>If we decide to not create another Guides app for the Contribution Guides, how should the design for the new website look like?</p>
</li>
<li>
<p>This RFC only considered content related to code contributions relevant for the Contribution Guides. This excludes other types of important contribution work to Ember and the community, as event organisation, blogging, release management and many other topics. Should the Guides be expanded by relevant information about other types of contribution work as we iterate on it? This could include How-Tos for organising meetups, a collection of workshop materials for reuse, an introduction to the RFC process and other pieces of information</p>
</li>
</ul>
<ul>
<li>Start Date: 2019-02-17</li>
<li>Relevant Teams: Ember.js, Learning</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/449</li>
<li>Tracking: (leave this empty)</li>
</ul>
<a class="header" href="print.html#deprecate-partial" id="deprecate-partial"><h1>Deprecate <code>{{partial}}</code></h1></a>
<a class="header" href="print.html#summary-107" id="summary-107"><h2>Summary</h2></a>
<p>Partials are an old Ember construct that have no benefits and many downsides when compared to modern Ember components. We should deprecate them in favor of components.</p>
<a class="header" href="print.html#motivation-108" id="motivation-108"><h2>Motivation</h2></a>
<p>Partials have a number of downsides when compared with components:</p>
<ul>
<li>They are hard to reason about as they inherit the scope of the calling template</li>
<li>They perform poorly in comparison to components</li>
</ul>
<p>Partials should have no place in modern Ember applications, components should always be preferred.</p>
<p>Once removed, Ember's API will become smaller and more consistent.</p>
<a class="header" href="print.html#detailed-design-91" id="detailed-design-91"><h2>Detailed design</h2></a>
<p>We'll create an AST transform in <a href="https://github.com/emberjs/ember.js/tree/master/packages/ember-template-compiler"><code>packages/ember-template-compiler</code></a> which will emit a deprecation warning for all uses of <code>{{partial}}</code>. The deprecation warning will be:</p>
<pre><code>Using `{{partial}}` is deprecated, please use a component instead.
</code></pre>
<p>This message will link to the following deprecation details which aim to give clear guidance on how to migrate to component:</p>
<hr />
<p>The use of <code>{{partial}}</code> has been deprecated, you should replace the partial with a component as follows:</p>
<p>Let's consider a simple example of a <code>partials/quick-tip</code> partial being invoked from the <code>application.hbs</code> template:</p>
<p><code>app/templates/application.hbs</code></p>
<pre><code class="language-hbs">{{#let (hash title=&quot;Don't use partials&quot; body=&quot;Components are always better&quot;) as |tip|}}
  {{partial &quot;partials/quick-tip&quot;}}
{{/let}}
</code></pre>
<p><code>app/templates/partials/quick-tip.hbs</code></p>
<pre><code class="language-hbs">&lt;h1&gt;Tip: {{tip.title}}&lt;/h1&gt;
&lt;p&gt;{{tip.body}}&lt;/p&gt;
&lt;button {{action 'dismissTip'}}&gt;OK&lt;/button&gt;
</code></pre>
<p>Here's the same template code after migrating the <code>partials/quick-tip</code> partial to be a component.</p>
<p><code>app/templates/application.hbs</code></p>
<pre><code class="language-hbs">{{#let (hash title=&quot;Don't use partials&quot; body=&quot;Components are always better&quot;) as |tip|}}
  &lt;QuickTip @tip={{tip}} @onDismiss={{action 'dismissTip'}} /&gt;
{{/let}}
</code></pre>
<p><code>app/templates/components/quick-tip.hbs</code></p>
<pre><code class="language-hbs">&lt;h1&gt;Tip: {{@tip.title}}&lt;/h1&gt;
&lt;p&gt;{{@tip.body}}&lt;/p&gt;
&lt;button {{action @onDismiss}}&gt;OK&lt;/button&gt;
</code></pre>
<hr />
<p>A codemod, while not necessary for this RFC to land, would greatly simplify the migration of partials to components. We should endeavor to create this codemod as part of efforts to implement this RFC. The codemod might work as follows:</p>
<ul>
<li>Examine each partial template to recognize which properties originate from the caller scope</li>
<li>Generate a component to replace each partial</li>
<li>Replace each <code>{{partial &quot;foo-bar&quot;}}</code> invocation with a component invocation, passing arguments as required</li>
<li>Delete the partial handlebars files</li>
</ul>
<p>If we do implement a codemod, we should mention it in the deprecation details above.</p>
<a class="header" href="print.html#how-we-teach-this-78" id="how-we-teach-this-78"><h2>How we teach this</h2></a>
<p>We'll mentiton the deprecation in an Ember point release blog post.</p>
<p>The deprecation message will contain a link to clear guidelines on how to migrate from a <code>{{partial}}</code> to a component. See the section above beginning with &quot;The use of <code>{{partial}}</code> has been deprecated...&quot; for the content.</p>
<p>There are no changes to make to the Ember.js guides, since mentions of <code>{{partial}}</code> were removed in 2.x guides.</p>
<a class="header" href="print.html#drawbacks-102" id="drawbacks-102"><h2>Drawbacks</h2></a>
<p>This adds a little churn to Ember's API.</p>
<a class="header" href="print.html#alternatives-105" id="alternatives-105"><h2>Alternatives</h2></a>
<p>We could do nothing and leave things as is.</p>
<a class="header" href="print.html#unresolved-questions-73" id="unresolved-questions-73"><h2>Unresolved questions</h2></a>
<p>None</p>
<ul>
<li>Start Date: 2019-03-05</li>
<li>Relevant Team(s): Ember.js</li>
<li>RFC PR: <a href="https://github.com/emberjs/rfcs/pull/457">#457</a></li>
<li>Tracking: (leave this empty)</li>
</ul>
<a class="header" href="print.html#nested-invocations-in-angle-bracket-syntax" id="nested-invocations-in-angle-bracket-syntax"><h1>Nested Invocations in Angle Bracket Syntax</h1></a>
<a class="header" href="print.html#summary-108" id="summary-108"><h2>Summary</h2></a>
<p>Create a syntax for invoking components nested inside of directories in angle-bracket syntax. The invocation <code>&lt;AppIcons::Warning&gt;</code> refers to the component <code>app/components/app-icons/warning.js</code> when using the default resolver, and looks up <code>component:app-icons/warning</code> in the container.</p>
<a class="header" href="print.html#motivation-109" id="motivation-109"><h2>Motivation</h2></a>
<p>Today's angle-bracket syntax conversion guide says this:</p>
<p><img src="../images/457-when-to-use-curlies.jpg" alt="existing documentation" /></p>
<p>This has been an acceptable interim step as we have worked on completing the work of revamping the component model, but it's a source of incoherence (and a reported adoption blocker for some apps) in the Ember design, and we need to eliminate this source of incoherence in order to recommend angle bracket components in the Octane edition.</p>
<p>For positional arguments, we recommend that add-on authors migrate to named arguments. There is one exception to this rule: addons that are mimicking control-flow syntax (like <code>liquid-if</code>). These addons should clearly document that they are meant to be used with curly syntax.</p>
<p>For components nested inside of directories, this RFC proposes a new syntax to allow users to migrate directly to angle bracket invocation.</p>
<a class="header" href="print.html#detailed-design-92" id="detailed-design-92"><h2>Detailed design</h2></a>
<blockquote>
<p>Note: This RFC uses curly syntax without blocks for illustrative purposes. In all cases, adding a block doesn't change the normalization or lookup rules described here.</p>
</blockquote>
<p>When using curly syntax, component invocation looks like this:</p>
<pre><code class="language-hbs">{{some-component some=parameters}}
</code></pre>
<p>If <code>some-component</code> is not a local variable in scope, the semantics of this invocation are:</p>
<ol>
<li>look up <code>component:some-component</code> in the container</li>
<li>look up <code>template:components/some-component</code> in the container</li>
<li>invoke the component with its template (using the relevant component manager semantics)</li>
</ol>
<p>When using angle-bracket syntax, the equivalent invocation looks like this:</p>
<pre><code class="language-hbs">&lt;SomeComponent @some={{parameters}}&gt;
</code></pre>
<p>The syntax means the same thing, with one additional step:</p>
<ol>
<li><strong>normalize <code>SomeComponent</code> into <code>some-component</code> using the dasherization rule specified in <a href="https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html#tag-name">RFC #311</a></strong></li>
<li>look up <code>component:some-component</code> in the container</li>
<li>look up <code>template:components/some-component</code> in the container</li>
<li>invoke the component with its template (using the relevant component manager semantics)</li>
</ol>
<p>Curly bracket syntax also allows the user to invoke a component nested inside of a directory. This syntax:</p>
<pre><code class="language-hbs">{{app-icons/warning color=&quot;yellow&quot;}}
</code></pre>
<p>has these semantics:</p>
<ol>
<li>look up <code>component:app-icons/warning</code> in the container</li>
<li>look up <code>template:components/app-icons/warning</code> in the container</li>
<li>invoke the component with its template (using the relevant component manager semantics)</li>
</ol>
<p>However, RFC #311 didn't specify an angle-bracket equivalent syntax for the same semantics.</p>
<p>This RFC proposes that the <code>::</code> separator serve the same purpose, with the same semantics, in angle-bracket notation:</p>
<pre><code class="language-hbs">&lt;AppIcons::Warning @color=&quot;yellow&quot; /&gt;
</code></pre>
<hr />
<p>This RFC is an extension to the <strong>normalization</strong> rules that already occur in angle bracket notation.</p>
<p>RFC #311 specified the normalization rules as:</p>
<blockquote>
<p>The tag name will be normalized using the dasherize function, which is the same rules used by existing use cases, such as service injections</p>
</blockquote>
<p>This RFC amends the normalization rule by first replacing any occurrences of <code>::</code> in the tag name with a <code>/</code>, but otherwise doesn't change the semantics of RFC #311.</p>
<p><a href="https://emberjs.github.io/rfcs/0143-module-unification.html">RFC #143</a>, Module Unification, uses <code>::</code> as a package separator, but because of problems with scoped packages in npm, we no longer intend to use the <code>::</code> syntax in that way. Instead, we intend to allow templates to import components from other packages using import syntax, and the <code>::</code> syntax is therefore available for this purpose.</p>
<a class="header" href="print.html#how-we-teach-this-79" id="how-we-teach-this-79"><h2>How we teach this</h2></a>
<p>We currently don't cover directory nesting in the guides, and directory nesting is not an extremely early-stage Ember feature. That said, most Ember developers encounter a need or desire to group components together relatively quickly, and it does make sense to cover it.</p>
<p>RFC #311 introduced a normalization rule for angle bracket invocation, and the guides mention that <code>&lt;NavBar&gt;</code> invokes a component that appears in the file system as <code>nav-bar</code>.</p>
<p><img src="../images/457-dasherization.jpg" alt="rental-listing in the docs" /></p>
<p>After this RFC, the documentation should add a &quot;Zoey says&quot; sidebar that describes the rule in more detail, and mentions that you can refer to components nested in a directory with the <code>::</code> separator.</p>
<p>Finally, the goal of this RFC is to make it possible to recommend that users always use angle-bracket invocation for components other than control flow (<code>if</code>, <code>each</code>).</p>
<p>This means that we should update the syntax conversion guide to no longer say that <code>{{</code> syntax is sometimes required, and avoid recommending it.</p>
<p>We should also recommend that component authors who are using positional parameters (other than control flow components like <code>liquid-if</code>) should stabilize, document and recommend named argument for their parameters so that their users can uniformly use angle bracket invocation syntax.</p>
<a class="header" href="print.html#drawbacks-and-alternatives" id="drawbacks-and-alternatives"><h2>Drawbacks and Alternatives</h2></a>
<p>This RFC introduces another normalization rule--Ember developers will need to understand that <code>::</code> refers to nested directories in the file system. It also introduces another divergence from the <code>{{</code> syntax, which already uses <code>/</code> for the same purpose.</p>
<p>Alternatively, we could use <code>/</code> as the separator for the same purpose. This would have the benefit of matching the idiomatic way that people describe file system nesting as well as matching the existing <code>{{</code> syntax.</p>
<p>On the other hand, it has poor syntax highlighting in virtually all existing highlighters:</p>
<pre><code class="language-hbs">&lt;AppIcons::Warning&gt;&lt;/AppIcons::Warning&gt;
&lt;AppIcons/Warning&gt;&lt;/AppIcons/Warning&gt;
</code></pre>
<p>Additionally, some autocomplete systems assume that <code>&lt;AppIcons/</code> is the beginning of a self-closing tag.</p>
<p><img src="../images/457-autocomplete-problem.gif" alt="an example of an IDE confusing this syntax as a self-closing tag" /></p>
<p>Another drawback of this proposal is that it uses <code>::</code> syntax for today's templates, and we don't expect that syntax to be relevant to templates using template imports. It's possible that we would want to use this syntax, which might be considered valuable, in templates using template imports. That said, there is no specific proposal for what we might want to use this syntax for, and we could compatibly reclaim it in the context of template imports, at the cost of some mental churn.</p>
<p>Another alternative is to recommend that people use <code>#let</code> with <code>(component)</code> in situations where nesting is required.</p>
<pre><code class="language-hbs">{{#let (component 'app-icons/warning') as |Warning|}}
  &lt;Warning&gt;&lt;/Warning&gt;
{{/let}}
</code></pre>
<p>The primary drawback of this approach is that the need to group components together in directories comes up earlier in the typical Ember developer's experience than learning the ins and outs of <code>let</code> and the <code>component</code> helper. It seems likely that developers could encounter a desire to group components in directories even before they have a full understanding of <code>let</code> and block parameters.</p>
<p>Secondarily, this is a fairly verbose syntax that introduces a significant cliff from top-level components to grouped components.</p>
<p>Another alternative is to introduce a new non-block syntax for bringing components into scope, such as:</p>
<pre><code class="language-hbs">{{resolve-component 'app-icons/warning' as Warning}}

&lt;Warning&gt;&lt;/Warning&gt;
</code></pre>
<p>This avoids introducing rightward drift, but it is still relatively verbose. It also creates a question that we would need to provide guidance on whether people should use this feature for all components or just nested ones (both sides have plausible arguments).</p>
<p>I also comes at the cost of creating a brand new way to bring variables into scope in Glimmer templates. Up to this point, we have carefully maintained the constraint that variables come into scope using nesting and <code>as |name|</code> syntax. While we might be willing to introduce new variable binding forms in the future, adding such a form to this proposal would significantly increase its design scope, and maintaining a small scope is a key goal of this RFC.</p>
<p>Another alternative is to avoid introducing a solution to this problem, and wait for the expected longer-term solution, template imports. While this is indeed expected to serve our longer-term goals, it would mean that Ember users couldn't use angle-bracket invocation, with all the benefits they bring, with nested components, or choose not to nest components at all.</p>
<p>On balance, it seems better to introduce an interim syntax that restores feature parity with curly invocation.</p>
<ul>
<li>Start Date: 2019-03-05</li>
<li>Relevant Team(s): Ember.js</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/459</li>
<li>Tracking: (leave this empty)</li>
</ul>
<a class="header" href="print.html#angle-bracket-invocations-for-built-in-components" id="angle-bracket-invocations-for-built-in-components"><h1>Angle Bracket Invocations For Built-in Components</h1></a>
<a class="header" href="print.html#summary-109" id="summary-109"><h2>Summary</h2></a>
<p><a href="./0311-angle-bracket-invocation.md">RFC #311</a> introduced the angle bracket
component invocation syntax. Many developers in the Ember community have since
adopted this feature with very positive feedback. This style of component
invocation will become the default style in the Octane edition and become the
primary way component invocations are taught.</p>
<p>However, Ember ships with three built-in components – <code>{{link-to}}</code>, <code>{{input}}</code>
and <code>{{textarea}}</code>. To date, it is not possible to invoke them with the angle
bracket syntax due to various API mismatches and implementation details.</p>
<p>This RFC proposes some small amendments to these APIs and their implementations
to allow them to be invoked with the angle bracket syntax, i.e. <code>&lt;LinkTo&gt;</code>,
<code>&lt;Input&gt;</code> and <code>&lt;Textarea&gt;</code>.</p>
<a class="header" href="print.html#motivation-110" id="motivation-110"><h2>Motivation</h2></a>
<p>As mentioned above, this will allow Ember developers to invoke components with
a consistent syntax, which should make it easier to teach.</p>
<p>This RFC <em>does not</em> aim to &quot;fix&quot; issues or quirks with the existing APIs – it
merely attempts to provide a way to do the equivalent invocation in angle
bracket syntax.</p>
<a class="header" href="print.html#detailed-design-93" id="detailed-design-93"><h2>Detailed design</h2></a>
<a class="header" href="print.html#linkto" id="linkto"><h3><code>&lt;LinkTo&gt;</code></h3></a>
<p>There are two main problem with <code>{{link-to}}</code>:</p>
<ul>
<li>It uses positional arguments as the main API.</li>
<li>It supports an &quot;inline&quot; form (i.e. without a block).</li>
</ul>
<p>In the new world, components are expected to work with named arguments. This is
both to improve clarity and to match the HTML tags model (which angle bracket
invocations are loosely modelled after). Positional arguments are reserved for
&quot;control-flow-like&quot; components (e.g. <code>liquid-if</code>) and to be paired with the
curly bracket invocation style. Since links are not that, it is not appropiate
for this component to use positional params.</p>
<p>When invoked with a block, the first argument is the route to navigate to. We
propose to name this argument explicitly, with <code>@route</code>:</p>
<pre><code class="language-hbs">{{#link-to &quot;about&quot;}}About Us{{/link-to}}

...becomes...

&lt;LinkTo @route=&quot;about&quot;&gt;About Us&lt;/LinkTo&gt;
</code></pre>
<p>The second argument can be used to provide a model to the route. We propose to
name this argument explicitly, with <code>@model</code>:</p>
<pre><code class="language-hbs">{{#let this.model.posts.firstObject as |post|}}

  {{#link-to &quot;post&quot; post}}Read {{post.title}}...{{/link-to}}

  ...becomes...

  &lt;LinkTo @route=&quot;post&quot; @model={{post}}&gt;Read {{post.title}}...&lt;/LinkTo&gt;

{{/let}}
</code></pre>
<p>In fact, it is possible to pass multiple models to deeply nested routes with
additional positional arguments. For this use case, we propose the <code>@models</code>
named argument which accepts an array:</p>
<pre><code class="language-hbs">{{#let this.model.posts.firstObject as |post|}}
  {{#each post.comments as |comment|}}

    {{#link-to &quot;post.comment&quot; post comment}}
      Comment by {{comment.author.name}} on {{comment.date}}
    {{/link-to}}

    ...becomes...

    &lt;LinkTo @route=&quot;post.comment&quot; @models={{array post comment}}&gt;
      Comment by {{comment.author.name}} on {{comment.date}}
    &lt;/LinkTo&gt;

  {{/each}}
{{/let}}
</code></pre>
<p>The singular <code>@model</code> argument is a special case of <code>@models</code>, provided as a
convenience for the common case. Passing both <code>@model</code> and <code>@models</code> will be an
error. Passing insufficient amount of models for the given route, will continue
to be an error.</p>
<p>It is also possible to pass query params to the <code>{{link-to}}</code> component with
the somewhat awkward <code>(query-params)</code> API. We propose to replace it with a
<code>@query</code> named argument that simply take a regular hash (or POJO):</p>
<pre><code class="language-hbs">{{#link-to &quot;posts&quot; (query-params direction=&quot;desc&quot; showArchived=false)}}
  Recent Posts
{{/link-to}}

...becomes...

&lt;LinkTo @route=&quot;posts&quot; @query={{hash direction=&quot;desc&quot; showArchived=false}}&gt;
  Recent Posts
&lt;/LinkTo&gt;
</code></pre>
<p>Finally, as mentioned above, <code>{{link-to}}</code> supports an &quot;inline&quot; form without a
block. This form doesn't bring much value and causes confusion around
the ordering of the arguments. We propose to simply not support this for the
angle bracket invocation style:</p>
<pre><code class="language-hbs">{{link-to &quot;About Us&quot; &quot;about&quot;}}

...becomes...

&lt;LinkTo @route=&quot;about&quot;&gt;About Us&lt;/LinkTo&gt;
</code></pre>
<p>Other APIs of this compoment are already based on named arguments.</p>
<a class="header" href="print.html#migration-path-3" id="migration-path-3"><h4>Migration Path</h4></a>
<p>We would provide a codemod to convert the old invocation style into the new
style.</p>
<a class="header" href="print.html#template-lints" id="template-lints"><h4>Template Lints</h4></a>
<p>Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, <code>{{link-to}}</code> would still work and
invoke the same component.</p>
<p>We propose to add template lint rules to using this component with the curly
invocation style.</p>
<a class="header" href="print.html#input" id="input"><h3><code>&lt;Input&gt;</code></h3></a>
<p>Today, the <code>{{input}}</code> component is internally implemented as several internal
components that are selected based on the <code>type</code> argument. This is intended as
an internal implementation detail, but as a result, it is not possible to invoke
the component with <code>&lt;Input&gt;</code> since it does not exist as a &quot;real&quot; component.</p>
<p>We propose to change this internal implementation strategy to make it possible
to invoke it with angle brackets just like any other components.</p>
<p>For example:</p>
<pre><code class="language-hbs">{{input type=&quot;text&quot; value=this.model.name}}

...becomes...

&lt;Input @type=&quot;text&quot; @value={{this.model.name}} /&gt;
</code></pre>
<p>Another example:</p>
<pre><code class="language-hbs">{{input type=&quot;checkbox&quot; name=&quot;email-opt-in&quot; checked=this.model.emailPreference}}

...becomes...

&lt;Input @type=&quot;checkbox&quot; @name=&quot;email-opt-in&quot; @checked={{this.model.emailPreference}} /&gt;
</code></pre>
<a class="header" href="print.html#migration-path-4" id="migration-path-4"><h4>Migration Path</h4></a>
<p>We would provide a codemod to convert the old invocation style into the new
style.</p>
<a class="header" href="print.html#template-lints-1" id="template-lints-1"><h4>Template Lints</h4></a>
<p>Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, <code>{{input}}</code> would still work and
invoke the same component.</p>
<p>We propose to add template lint rules to using this component with the curly
invocation style.</p>
<a class="header" href="print.html#textarea" id="textarea"><h3><code>&lt;Textarea&gt;</code></h3></a>
<p>Due to a similar implementation issue, it is also not possible to invoke the
<code>{{textarea}}</code> component with angle bracket invocation style.</p>
<p>We propose to change this internal implementation strategy to make it possible
to invoke this with angle brackets just like any other components.</p>
<p>For example:</p>
<pre><code class="language-hbs">{{textarea value=this.model.body}}

...becomes...

&lt;Textarea @value={{this.model.body}} /&gt;
</code></pre>
<a class="header" href="print.html#migration-path-5" id="migration-path-5"><h4>Migration Path</h4></a>
<p>We would provide a codemod to convert the old invocation style into the new
style.</p>
<p><a href="./0176-javascript-module-api.md">RFC #176</a> picked <code>text-area</code>/<code>TextArea</code> for
this component. To prevent confusion, we will add a helpful hint to the error
message (&quot;did you mean <code>&lt;Textarea&gt;</code>?&quot;) when a user mistakenly typed
<code>{{text-area}}</code> or <code>&lt;TextArea&gt;</code> in development mode.</p>
<a class="header" href="print.html#template-lints-2" id="template-lints-2"><h4>Template Lints</h4></a>
<p>Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, <code>{{textarea}}</code> would still work and
invoke the same component.</p>
<p>We propose to add template lint rules to using this component with the curly
invocation style.</p>
<a class="header" href="print.html#how-we-teach-this-80" id="how-we-teach-this-80"><h2>How we teach this</h2></a>
<p>Going forward, we will focus on teaching the angle bracket invocation style as
the main (only?) way of invoking components. In that world, there wouldn't be
anything extra to teach, as the invocation style proposed in this RFC is not
different from any other components, which is the purpose of this proposal. Of
course, the APIs of these components will still need to be taught, but that is
not a new change.</p>
<p>The only caveat is that, since the advanced <code>&lt;LinkTo&gt;</code> APIs require passing
arrays and hashes, the <code>{{array}}</code> and <code>{{hash}}</code> helper would have to be
taught before those advanced features can be introduced. However, since the
basic usage (linking to top-level routes) does not require either of those
helpers, it doesn't really affect things from a getting started perspective.</p>
<p>It should also be mentioned that, other built-ins, such as <code>{{yield}}</code>,
<code>{{outlet}}</code>, <code>{{mount}}</code>, etc are considered &quot;keywords&quot; not components, they
are also &quot;control-flow-like&quot;, so it wouldn't be appropiate to invoke them with
angle brackets.</p>
<p>The technical implementation of this RFC will need to be accompanied by changes to the API docs for the built-in template helpers, <a href="https://emberjs.com/api/ember/3.8/classes/Ember.Templates.helpers/methods/link-to?anchor=link-to">link-to</a> and <a href="https://emberjs.com/api/ember/3.8/classes/Ember.Templates.helpers/methods/input?anchor=input">input</a>. In keeping with past decisions for Angle Brackets, the API docs should show both curly and Angle Bracket invocations of these helpers. The API docs are expected to show the full supported API surface of Ember.</p>
<p><code>link-to</code> and <code>input</code> are used liberally throughout the Ember.js Guides, Tutorial, and <code>super-rentals</code> <a href="https://github.com/ember-learn/super-rentals">sample app</a>, so those examples will need to be updated. In the Guides, we want to show solely Angle Brackets invocation. The <a href="https://guides.emberjs.com/release/reference/syntax-conversion-guide/">syntax conversion guide</a> should be revised to include these helpers.</p>
<a class="header" href="print.html#drawbacks-103" id="drawbacks-103"><h2>Drawbacks</h2></a>
<p>None.</p>
<a class="header" href="print.html#alternatives-106" id="alternatives-106"><h2>Alternatives</h2></a>
<ul>
<li>
<p><code>&lt;LinkTo&gt;</code> could only support <code>@models</code> without special casing <code>@model</code> as a
convenience.</p>
</li>
<li>
<p><code>&lt;LinkTo&gt;</code> could support a <code>@text</code> argument for inline usage.</p>
</li>
<li>
<p><code>&lt;Textarea&gt;</code> could be named <code>&lt;TextArea&gt;</code>.</p>
</li>
</ul>
<a class="header" href="print.html#unresolved-questions-74" id="unresolved-questions-74"><h2>Unresolved questions</h2></a>
<p>None.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
